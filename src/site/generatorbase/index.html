<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>MultiBackendBaseClass - PythiaSource</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "MultiBackendBaseClass";
    var mkdocs_page_input_path = "generatorbase.md";
    var mkdocs_page_url = "/generatorbase/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> PythiaSource</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">MultiBackendBaseClass</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#transpiler-base-class">Transpiler Base Class</a></li>
                
            
                <li class="toctree-l3"><a href="#imports">Imports</a></li>
                
            
                <li class="toctree-l3"><a href="#call-functionmethod">Call Function/Method</a></li>
                
            
                <li class="toctree-l3"><a href="#import-import-x-and-from-x-import-y">Import import x and from x import y</a></li>
                
            
                <li class="toctree-l3"><a href="#is_prim_type">is_prim_type</a></li>
                
            
                <li class="toctree-l3"><a href="#function-decorators">Function Decorators</a></li>
                
            
                <li class="toctree-l3"><a href="#function">Function</a></li>
                
            
                <li class="toctree-l3"><a href="#with">With</a></li>
                
            
                <li class="toctree-l3"><a href="#go-hacks">Go hacks</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../jstranslator/">JavascriptTranslator</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../gotranslator/">GolangTranslator</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../cpprustbase/">SharedRustC++Class</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../cpptranslator/">C++Translator</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../typedpython/">PreProcessor</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../intermediateform/">PreTranslator</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">PythiaSource</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>MultiBackendBaseClass</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/secureosv/pythia" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="transpiler-base-class">Transpiler Base Class</h2>
<p>shared methods used by most backends are here.
TODO move <code>__init__</code> from jstranslator.md to here.</p>
<h2 id="imports">Imports</h2>
<ul>
<li><a href="clikelang.md">@import clikelang.md</a></li>
</ul>
<pre><code class="python">
class GeneratorBase( CLikeLanguage ):

    def visit_IfExp(self, node):
        ## ternary operator ##
        test    = self.visit(node.test)
        iftrue  = self.visit(node.body)
        iffalse = self.visit(node.orelse)
        return '(%s ? %s : %s)' %(test, iftrue, iffalse)


    def visit_Expr(self, node):
        ## note: the javascript backend overloads this ##
        s = self.visit(node.value)
        if s is None:
            raise RuntimeError('GeneratorBase ExpressionError: %s' %node.value)
        if s.strip() and not s.endswith(';'):
            s += ';'
        if s==';': return ''
        else: return s

    def function_has_getter_or_setter(self, node):
        options = {'getter':False, 'setter':False}
        for d in node.decorator_list:
            self._visit_decorator(d, options=options)
        return options['getter'] or options['setter']


    def visit_Tuple(self, node, force_make_tuple=False):
        if self._rust:
            return 'vec!(%s)' % ', '.join(map(self.visit, node.elts))
        elif self._cpp:
            if len(self._stack) &gt;= 2 and isinstance(self._stack[-2], ast.Call) or force_make_tuple:
                if isinstance(self._stack[-2].func, ast.Name) and self._stack[-2].func.id=='__array__':  ## special case
                    return '{%s}' %','.join(map(self.visit, node.elts))
                else:
                    tupletype, tupleinit = self.make_tuple(node.elts)
                    if self._memory[-1]=='STACK':
                        return 'std::make_tuple(%s)' %','.join(tupleinit)
                    else:
                        #declargs = ['decltype(%s)'%self.visit(da) for da in node.elts]
                        return 'std::make_shared&lt;std::tuple&lt;%s&gt;&gt;(std::make_tuple(%s))' %(','.join(tupletype), ','.join(tupleinit))
            else:
                return '{%s}' %','.join(map(self.visit, node.elts))
        else:
            return '[%s]' % ', '.join(map(self.visit, node.elts))

    def visit_List(self, node):
        a = []
        for elt in node.elts:
            b = self.visit(elt)
            if b is None: raise SyntaxError( self.format_error(elt) )
            a.append( b )
        return '[%s]' % ', '.join(a)

    def visit_Subscript(self, node):
        if isinstance(node.slice, ast.Ellipsis):
            return self._visit_subscript_ellipsis( node )
        else:
            return '%s[%s]' % (self.visit(node.value), self.visit(node.slice))

    def visit_Index(self, node):
        return self.visit(node.value)

    def _visit_call_helper_instanceof(self, node):
        args = map(self.visit, node.args)
        if len(args) == 2:
            return '%s instanceof %s' %tuple(args)
        else:
            raise SyntaxError( args )

    def _visit_call_helper_new(self, node):
        args = map(self.visit, node.args)
        if len(args) == 1:
            return ' new %s' %args[0]
        else:
            raise SyntaxError( args )

    def _visit_call_special( self, node ):
        raise NotImplementedError('special call')

</code></pre>

<h2 id="call-functionmethod">Call Function/Method</h2>
<p>The backends subclass _visit_call_helper, which gets called here after doing some bookeeping like
tracking what function names have been called, so backends can check <code>self._called_funtions</code> and
do extra things like inline extra helper code for things like <code>hasattr</code>, etc.</p>
<pre><code class="python">
    def visit_Call(self, node):
        name = self.visit(node.func)
        if name not in self._called_functions:
            self._called_functions[name] = 0
        self._called_functions[name] += 1

        if name in typedpython.GO_SPECIAL_CALLS.values():
            return self._visit_call_helper_go( node )

        elif name in self.catch_call:
            return self._visit_call_special( node )

        elif name == 'instanceof':  ## it is safer to use the builtin `isinstance`
            return self._visit_call_helper_instanceof( node )

        elif name == 'new':
            return self._visit_call_helper_new( node )

        elif name == '__ternary_operator__':
            args = map(self.visit, node.args)
            if len(args) == 2:
                return '((%s) ? %s : %s)' %(args[0], args[0], args[1])
            elif len(args) == 3:
                return '((%s) ? %s : %s)' %(args[0], args[1], args[2])
            else:
                raise SyntaxError( args )

        elif name == 'numpy.array':
            return self._visit_call_helper_numpy_array(node)

        elif name == 'JSObject':
            return self._visit_call_helper_JSObject( node )

        elif name == 'var':
            return self._visit_call_helper_var( node )

        elif name == 'JSArray':
            return self._visit_call_helper_JSArray( node )

        elif name == 'inline' or name == 'JS':
            assert len(node.args)==1 and isinstance(node.args[0], ast.Str)
            return self._inline_code_helper( node.args[0].s )

        elif name == 'list':
            return self._visit_call_helper_list( node )

        elif name == '__get__' and len(node.args)==2 and isinstance(node.args[1], ast.Str) and node.args[1].s=='__call__':
            raise SyntaxError('deprecated')
            return self._visit_call_helper_get_call_special( node )

        elif name.split('.')[-1] == '__go__receive__':
            raise SyntaxError('this should not happen __go__receive__')

        else:
            return self._visit_call_helper(node)



</code></pre>

<h2 id="import-import-x-and-from-x-import-y">Import <code>import x</code> and <code>from x import y</code></h2>
<pre><code class="python">
    def _importfrom_helper(self, node):
        return ''

    def visit_ImportFrom(self, node):
        # print node.module
        # print node.names[0].name
        # print node.level
        if self._rust:
            crate = self._crates[node.module]
            for alias in node.names:
                crate.add( alias.name )
        if node.module=='runtime':
            self._insert_runtime = True
        else:
            return self._importfrom_helper(node)

        return ''

    def visit_Import(self, node):
        r = [alias.name.replace('__SLASH__', '/') for alias in node.names]
        res = []
        if r:
            for name in r:
                if self._rust:  ## TODO move this to rusttranslator.md
                    if name not in self._crates:
                        self._crates[name] = set()
                else:
                    raise SyntaxError('import not yet support for this backend')

        if res:
            return '\n'.join(res)
        else:
            return ''

</code></pre>

<h2 id="is_prim_type">is_prim_type</h2>
<p>the typed backends like: go, rust and c++ need to know if a variable type is a builtin primitive,
or something that needs to be wrapped by a pointer/shared-reference.</p>
<pre><code class="python">
    def is_prim_type(self, T):
        prims = 'auto void bool unsigned int float double long string str char byte u32 u64 i32 i64 f32 f64 float32 float64 std::string cstring'.split()
        if hasattr(self, '_typedefs'):
            prims.extend( self._typedefs.keys() )

        if self._go:
            prims.append( 'interface{}' )
        if T in prims:
            return True
        elif T.endswith(']'):  ## c-style array
            return True
        else:
            return False

    def indent(self): return '\t' * self._indent
    def push(self): self._indent += 1
    def pull(self):
        if self._indent &gt; 0: self._indent -= 1

</code></pre>

<h2 id="function-decorators">Function Decorators</h2>
<p><code>_visit_decorator</code> is called by the other backends, the shared decorator logic is here.</p>
<pre><code class="python">
    def _visit_decorator(self, decor, node=None, options=None, args_typedefs=None, chan_args_typedefs=None, generics=None, args_generics=None, func_pointers=None, arrays=None, args_super_classes=None ):
        assert node
        if options is None: options = dict()
        if args_typedefs is None: args_typedefs = dict()
        if chan_args_typedefs is None: chan_args_typedefs = dict()
        if generics is None: generics = set()
        if args_generics is None: args_generics = dict()
        if func_pointers is None: func_pointers = set()
        if arrays is None: arrays = dict()
        if args_super_classes is None: args_super_classes = dict()

        if isinstance(decor, ast.Name) and decor.id == 'classmethod':
            options['classmethod'] = True

        elif isinstance(decor, ast.Name) and decor.id == 'property':
            ## a function is marked as a getter with `@property`
            options['getter'] = True
        elif isinstance(decor, ast.Attribute) and isinstance(decor.value, ast.Name) and decor.attr == 'setter':
            ## a function is marked as a setter with `@name.setter`
            options['setter'] = True

        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef__':
            if len(decor.args) == 3:
                vname = self.visit(decor.args[0])
                if isinstance(decor.args[1], ast.Str):
                    vtype = decor.args[1].s
                else:
                    vtype = self.visit(decor.args[1])
                vptr = decor.args[2].s

                ## note: the space is required because it could be `mut` rust-keyword, or `struct` C type.
                args_typedefs[ vname ] = '%s %s' %(vptr, vtype)

            else:
                args_user_classes = {}
                for key in decor.keywords:
                    args_user_classes[key.arg] = None

                    if isinstance( key.value, ast.Str):
                        args_typedefs[ key.arg ] = key.value.s
                        if key.value.s in self._classes:  ## TODO check if endswith *
                            args_user_classes[key.arg] = key.value.s
                        elif key.value.s.startswith('['):
                            n,T = key.value.s.split(']')
                            n += ']'
                            args_typedefs[key.arg]=T+n

                    elif isinstance(key.value, ast.Name):
                        T = key.value.id
                        if T in self._classes:
                            args_user_classes[key.arg] = T

                        if self.is_prim_type(T) or self._memory[-1]=='STACK':
                            args_typedefs[key.arg] = T
                        elif self._cpp:
                            if self.usertypes and 'shared' in self.usertypes:
                                args_typedefs[ key.arg ] = self.usertypes['shared']['template'] %T
                            elif not self._shared_pointers:
                                args_typedefs[ key.arg ] = '%s*' %T
                            elif self._unique_ptr:
                                args_typedefs[ key.arg ] = 'std::unique_ptr&lt;%s&gt;' %T
                            else:
                                assert self._memory[-1]=='HEAP'
                                args_typedefs[ key.arg ] = 'std::shared_ptr&lt;%s&gt;' %T

                        else:  ## javascript runtime checked types
                            args_typedefs[key.arg] = T

                    else:
                        if isinstance(key.value, ast.Call) and isinstance(key.value.func, ast.Name) and key.value.func.id=='__arg_array__':
                            arrays[ key.arg ] = key.value.args[0].s
                            dims = arrays[ key.arg ].count('[')
                            arrtype = arrays[ key.arg ].split(']')[-1]

                            if self._rust:
                                if not self.is_prim_type(arrtype):
                                    arrtype = 'Rc&lt;RefCell&lt;%s&gt;&gt;' %arrtype

                                args_typedefs[ key.arg ] = 'Rc&lt;RefCell&lt;Vec&lt;%s&gt;&gt;&gt;' %arrtype

                            elif self._cpp:
                                ## non primitive types (objects and arrays) can be None, `[]MyClass( None, None)`
                                ## use a pointer or smart pointer. 
                                if not self.is_prim_type(arrtype) and self._memory[-1]=='HEAP':
                                    if not self._shared_pointers:
                                        arrtype += '*'
                                    elif self.usertypes and 'shared' in self.usertypes:
                                        arrtype = self.usertypes['shared']['template'] % arrtype
                                    elif self._unique_ptr:
                                        arrtype = 'std::unique_ptr&lt;%s&gt;' %arrtype
                                    else:
                                        arrtype = 'std::shared_ptr&lt;%s&gt;' %arrtype


                                T = []

                                for i in range(dims):
                                    if not self._shared_pointers or self._memory[-1]=='STACK':
                                        T.append('std::vector&lt;')
                                    elif self.usertypes and 'vector' in self.usertypes:
                                        sptr = self.usertypes['shared']['type']
                                        vptr = self.usertypes['vector']['template'].split(&quot;%s&quot;)[0]
                                        T.append('%s%s' %(sptr, vptr))                                  
                                    elif self._unique_ptr:
                                        T.append('std::unique_ptr&lt;std::vector&lt;')
                                    else:
                                        T.append('std::shared_ptr&lt;std::vector&lt;')
                                T.append( arrtype )

                                if self._memory[-1]=='STACK':
                                    for i in range(dims):
                                        #if i: T.append('*&gt;')
                                        #else: T.append('&gt;')
                                        T.append('&gt;')
                                    T.append('*')

                                elif self._shared_pointers or 'vector' in self.usertypes:
                                    for i in range(dims):
                                        T.append('&gt;&gt;')
                                else:
                                    for i in range(dims):
                                        if i: T.append('*&gt;')
                                        else: T.append('&gt;')
                                    T.append('*')

                                args_typedefs[ key.arg ] = ''.join(T)

                            else:  ## javascript backend
                                args_typedefs[ key.arg ] = key.value.args[0].s

                        else:
                            args_typedefs[ key.arg ] = self.visit(key.value)

                    if args_typedefs[key.arg].startswith('func(') or args_typedefs[key.arg].startswith('lambda('):
                        is_lambda_style = args_typedefs[key.arg].startswith('lambda(')
                        func_pointers.add( key.arg )
                        funcdef = args_typedefs[key.arg]
                        ## TODO - better parser
                        hack = funcdef.replace(')', '(').split('(')
                        lambda_args = []
                        TODO_REPLACE_PIPE_HACK = '|'  ## note new syntax is space separated
                        for larg in hack[1].strip().split(TODO_REPLACE_PIPE_HACK):
                            if self.is_prim_type(larg):
                                lambda_args.append(larg)
                            elif not larg:
                                lambda_args.append('void')
                            else:
                                lambda_args.append('std::shared_ptr&lt;%s&gt;'%larg)

                        lambda_args = ','.join(lambda_args)
                        lambda_return = hack[3].strip()
                        if not lambda_return: lambda_return = 'void'
                        if not self.is_prim_type(lambda_return):
                            lambda_return = 'std::shared_ptr&lt;%s&gt;'%lambda_return

                        if self._cpp:
                            if is_lambda_style:
                                if lambda_return:  ## c++11
                                    args_typedefs[ key.arg ] = 'std::function&lt;%s(%s)&gt;  %s' %(lambda_return, lambda_args, key.arg)
                                else:
                                    args_typedefs[ key.arg ] = 'std::function&lt;void(%s)&gt;  %s' %(lambda_args, key.arg)

                            else:  ## old C style function pointers
                                if lambda_return:
                                    args_typedefs[ key.arg ] = '%s(*%s)(%s)' %(lambda_return, key.arg, lambda_args)
                                else:
                                    args_typedefs[ key.arg ] = 'void(*%s)(%s)' %(key.arg, lambda_args)

                        elif self._rust:
                            if lambda_return:
                                args_typedefs[ key.arg ] = '|%s|-&gt;%s' %(lambda_args, lambda_return)
                            else:
                                args_typedefs[ key.arg ] = '|%s|' %lambda_args

                        elif self._dart:
                            args_typedefs[ key.arg ] = 'var'

                    ## check for super classes - generics ##
                    ## this was originally for the Go backend, still used in the c++ or rust backends?
                    #if (self._go or self._cpp or self._rust) and args_typedefs[ key.arg ] in self._classes:
                    if (self._go or self._cpp or self._rust) and args_user_classes[ key.arg ]:
                        classname = args_user_classes[ key.arg ]
                        options['generic_base_class'] = classname

                        if self._cpp:
                            #if self._memory[-1]=='STACK':
                            #   #args_typedefs[key.arg] = 'const %s' %classname
                            #   pass
                            #elif not self._shared_pointers:
                            #   args_typedefs[ key.arg ] = '%s*' %classname
                            #elif self.usertypes and 'shared' in self.usertypes:
                            #   args_typedefs[ key.arg ] = self.usertypes['shared']['template'] % classname
                            #elif self._unique_ptr:
                            #   args_typedefs[ key.arg ] = 'std::unique_ptr&lt;%s&gt;' %classname
                            #else:
                            #   args_typedefs[ key.arg ] = 'std::shared_ptr&lt;%s&gt;' %classname
                            #args_generics[ key.arg ] = classname

                            #for subclass in self._classes[classname]._subclasses:
                            #   generics.add( subclass )

                            cnode = self._classes[classname]
                            if cnode._parents:
                                args_super_classes[key.arg] = []
                                for base in cnode._parents:
                                    args_super_classes[key.arg].append(base)

                        elif self._rust:
                            args_typedefs[ key.arg ] = 'Rc&lt;RefCell&lt;%s&gt;&gt;' %classname

                        elif self._go:  ## TODO test if this is still working in the Go backend
                            if node.name=='__init__':
                                ## generics type switch is not possible in __init__ because
                                ## it is used to generate the type struct, where types are static.
                                ## as a workaround generics passed to init always become `interface{}`
                                args_typedefs[ key.arg ] = 'interface{}'
                                #self._class_stack[-1]._struct_def[ key.arg ] = 'interface{}'
                            else:
                                generics.add( classname ) # switch v.(type) for each
                                generics = generics.union( self._classes[classname]._subclasses )  ## TODO
                                args_typedefs[ key.arg ] = 'interface{}'
                                args_generics[ key.arg ] = classname

        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef_chan__':
            for key in decor.keywords:
                if isinstance(key.value, ast.Str):
                    chan_args_typedefs[ key.arg ] = key.value.s.strip()
                else:
                    chan_args_typedefs[ key.arg ] = self.visit(key.value)
        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'returns':
            if decor.keywords:
                raise SyntaxError('invalid go return type')
            elif isinstance(decor.args[0], ast.Name):
                options['returns'] = decor.args[0].id
            else:
                options['returns'] = decor.args[0].s

            if options['returns'].startswith('[]'):
                options['returns_array'] = True
                options['returns_array_dim'] = options['returns'].count('[]')

                vectype = options['returns'].split(']')[-1]
                if self._cpp and vectype.startswith('tuple(') and vectype.endswith(')'):
                    tupletypes = vectype[ len('tuple(') : -1 ].split(',')
                    vectype = 'std::tuple&lt;%s&gt;' %','.join(tupletypes)
                    if self._memory[-1]=='HEAP':
                        vectype = 'std::shared_ptr&lt;%s&gt;' %vectype
                options['returns_array_type'] = vectype

                if self._cpp:
                    if options['returns_array_type']=='string':
                        options['returns_array_type'] = 'std::string'

                    T = []
                    for i in range(options['returns_array_dim']):
                        if not self._shared_pointers or self._memory[-1]=='STACK':
                            T.append('std::vector&lt;')
                        elif self._unique_ptr:
                            T.append('std::unique_ptr&lt;std::vector&lt;')
                        else:
                            T.append('std::shared_ptr&lt;std::vector&lt;')

                    T.append(options['returns_array_type'])

                    if self._memory[-1]=='STACK':
                        for i in range(options['returns_array_dim']):
                            T.append('&gt;')
                        #T.append('*')  ## return copy
                    elif self._shared_pointers and self._memory[-1]=='HEAP':
                        for i in range(options['returns_array_dim']):
                            T.append('&gt;&gt;')
                    else:
                        for i in range(options['returns_array_dim']):
                            if i: T.append('*&gt;')
                            else: T.append('&gt;')
                        T.append('*')
                    options['returns'] = ''.join(T)
                elif self._rust:
                    raise SyntaxError('TODO return 2d array rust backend')
                else:
                    raise SyntaxError('TODO return 2d array some backend')

            if options['returns'] == 'self' and len(self._class_stack):
                options['returns_self'] = True
                self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)

                if self._go:
                    options['returns'] = '*' + self._class_stack[-1].name  ## go hacked generics

</code></pre>

<h2 id="function">Function</h2>
<p>calls <code>_visit_function</code> which is subclassed by other backends.</p>
<pre><code class="python">
    def visit_FunctionDef(self, node):
        self._function_stack.append( node )
        node._local_vars = set()
        buffer = self._visit_function( node )

        if node == self._function_stack[0]:  ## global function
            self._global_functions[ node.name ] = node

        self._function_stack.pop()
        return buffer

</code></pre>

<h2 id="with">With</h2>
<p>Special syntax that triggers different things depending on the backend.
Also implements extra syntax like <code>switch</code> and <code>select</code>.</p>
<pre><code class="python">
    def visit_With(self, node):
        r = []
        is_select = False
        is_switch = False
        is_switch_type = False
        is_match  = False
        is_case   = False
        is_extern = False
        has_default = False
        withvalue = self.visit(node.context_expr)
        if withvalue.startswith('return_'):
            ## STACK MODE ##
            ## all variables must be on or moved onto stack for these operations.
            ## see also: 
            ##      `repeat(...):`
            ##      `return foo() and then(capture=[], ...):`

            self._memory.append('STACK')
            has_then = False
            if 'then(' in withvalue:
                has_then = withvalue.split('.then(')[-1].split(')')[0]

            rcall = withvalue.split('return_')[-1].split('(')[0].split()[0]
            rargs = withvalue.split('(')[1].split(')')[0].split(',')
            if rcall=='do_with':
                cargs = ','.join('auto&amp; %s'%ra.strip() for ra in rargs)
                rargs = ','.join('std::move(%s)'%ra.strip() for ra in rargs)
                body = ['return do_with(%s, [] (%s) {' %(rargs, cargs)]
            else:
                rargs = ','.join('&amp;'+ra.strip() for ra in rargs)
                body = ['return %s([%s] {' %(rcall, rargs)]

            self.push()
            for b in node.body:
                body.append(self.indent()+self.visit(b))
            self.pull()

            if has_then:
                #if rcall=='repeat':
                #   raise RuntimeError(withvalue+':'+rargs+':'+has_then)
                body.append(self.indent()+'}).then(%s);' %has_then)
            else:
                body.append(self.indent()+'});')

            self._memory.pop()
            return '\n'.join(body)

        elif isinstance(node.context_expr, ast.Name) and node.context_expr.id in ('oo', 'operator_overloading'):
            self._with_oo = True
            body = []
            for b in node.body: body.append(self.visit(b))
            self._with_oo = False
            return '\n'.join(body)

        elif isinstance( node.context_expr, ast.Name ) and node.context_expr.id == '__default__':
            has_default = True
            if self._rust and not self._cpp:
                r.append(self.indent()+'}, _ =&gt; {')
            else:
                r.append(self.indent()+'default:')

        elif isinstance( node.context_expr, ast.Name ) and node.context_expr.id == '__select__':
            is_select = True
            self._match_stack.append( list() )
            self._in_select_hack = True
            self._with_type.append('SELECT')

            if self._rust:
                r.append(self.indent()+'select! (')
            elif self._cpp:
                r.append(self.indent()+'cpp::select _select_;')  ## TODO nested, _select_N
            elif self._go:
                r.append(self.indent()+'select {')
            else:  ## javascript
                r.append('while (true) {        /* select loop */')


        elif isinstance( node.context_expr, ast.Call ):
            if not isinstance(node.context_expr.func, ast.Name):
                raise SyntaxError( self.visit(node.context_expr))

            #if len(node.context_expr.args):  ## what was this used for?
            #   a = self.visit(node.context_expr.args[0])
            #else:
            #   assert len(node.context_expr.keywords)
            #   ## need to catch if this is a new variable ##
            #   name = node.context_expr.keywords[0].arg
            #   if name not in self._known_vars:
            #       a = 'let %s = %s' %(name, self.visit(node.context_expr.keywords[0].value))
            #   else:
            #       a = '%s = %s' %(name, self.visit(node.context_expr.keywords[0].value))

            if node.context_expr.func.id == 'chain_then':
                self._lambda_stack[-1].chain_then.append(node)
                #self.chain_then.append(node)
                return ''
            elif node.context_expr.func.id == '__case__':
                is_case = True
                case_match = None
                select_hack = None
                if not len(node.context_expr.args):
                    assert len(node.context_expr.keywords)==1
                    kw = node.context_expr.keywords[0]
                    if self._go:
                        case_match = '%s := %s' %(kw.arg, self.visit(kw.value))
                    elif hasattr(self, '_in_select_hack') and self._in_select_hack:
                        select_hack = True
                        if self._cpp:
                            case_match = '_select_.recv(%s, %s);' %(self.visit(kw.value), kw.arg)                       

                        else:  ## javascript backend ##
                            #self.visit(kw.value) ## TODO allow worker returned from some call
                            cid = kw.value.right.id
                            case_match = 'if (𝑾𝒐𝒓𝒌𝒆𝒓𝑷𝒐𝒐𝒍.select(%s).length) {var %s = 𝑾𝒐𝒓𝒌𝒆𝒓𝑷𝒐𝒐𝒍.select(%s).pop();' %(cid, kw.arg, cid)
                    elif is_switch_type:
                        raise SyntaxError('invalid switch type')
                    else:
                        case_match = '%s = %s' %(kw.arg, self.visit(kw.value))
                else:
                    if isinstance(node.context_expr.args[0], ast.Compare):
                        raise SyntaxError('&quot;case x==n:&quot; is not allowed in a case statement, use &quot;case n:&quot; instead.')
                    case_match = self.visit(node.context_expr.args[0])

                if select_hack:
                    r.append(self.indent()+case_match)
                elif self._rust and not self._cpp:
                    if len(self._match_stack[-1])==0:
                        r.append(self.indent()+'%s =&gt; {' %case_match)
                    else:
                        r.append(self.indent()+'}, %s =&gt; { ' %case_match )
                else:
                    if self._with_type[-1]=='SWITCH_TYPE':
                        T = case_match
                        o = self._switch_on_type_object[-1]
                        classid = self._classes.keys().index(T)
                        r.append(self.indent()+'case %s: {' %classid) ## extra scope
                        r.append(self.indent()+'    auto _cast_%s = std::static_pointer_cast&lt;%s&gt;(%s);' %(o, T, o))
                        case_match = '&quot;%s&quot;' %case_match
                    else:
                        r.append(self.indent()+'case %s: {' %case_match) ## extra scope

                if not len(self._match_stack):
                    raise SyntaxError('case statement used outside of a select or switch block')

                self._match_stack[-1].append(case_match)


            elif node.context_expr.func.id == '__switch__':
                is_switch = True
                self._match_stack.append( list() )

                if self._rust and not self._cpp:
                    r.append(self.indent()+'match (%s) {' %self.visit(node.context_expr.args[0]))
                    is_match = True
                else:
                    switch_value = self.visit(node.context_expr.args[0])
                    if switch_value.startswith('type(') and switch_value.endswith(')'):
                        is_switch_type = True
                        switch_object = switch_value[ len('type(') : -1 ].strip()
                        self._rename_hacks[switch_object] = '_cast_' + switch_object
                        self._switch_on_type_object.append(switch_object)
                        switch_value = switch_object + '-&gt;__classid__'
                    r.append(self.indent()+'switch (%s) {' %switch_value)

                if is_switch_type:
                    self._with_type.append('SWITCH_TYPE')
                elif is_match:
                    self._with_type.append('SWITCH_MATCH')
                else:
                    self._with_type.append('SWITCH')


            elif node.context_expr.func.id == 'extern':
                is_extern = True
                link = None
                for kw in node.context_expr.keywords:
                    if kw.arg=='link':
                        link = kw.value.s
                if self._cpp:
                    r.append('extern &quot;C&quot; {')  ## TODO other abis
                elif self._rust:
                    assert link
                    r.append('#[link(name = &quot;%s&quot;)]' %link)
                    r.append('extern {')

                else:
                    raise SyntaxError('with extern: not supported yet for backend')

                ## strip the bodies from function defs, that should be just defined as `def f(args):pass`
                for b in node.body:
                    if isinstance(b, ast.FunctionDef):
                        if b.body and len(b.body) &lt;= 2 and isinstance(b.body[-1], ast.Pass):
                            b.body = []
                            b.declare_only = True

            elif node.context_expr.func.id == 'syntax':
                assert len(node.context_expr.args)==1
                keys = []
                if isinstance(node.context_expr.args[0], ast.Dict):
                    #self.usertypes = {'string':None}  ## force plain strings
                    cfg = eval(self.visit(node.context_expr.args[0]))
                    keys.extend( cfg.keys() )
                    self.usertypes.update( cfg )
                else:
                    assert isinstance(node.context_expr.args[0], ast.Str)
                    jsonfile = node.context_expr.args[0].s
                    if jsonfile in self.cached_json_files:
                        jdata = self.cached_json_files[jsonfile]
                        cfg   = json.loads( jdata )
                        keys.extend( cfg.keys() )
                        self.usertypes.update( cfg )
                    elif os.path.isfile(jsonfile):
                        cfg   = json.load(jsonfile)
                        keys.extend( cfg.keys() )
                        self.usertypes.update( cfg )
                    else:
                        raise RuntimeError('can not load custom types json: %s' %jsonfile)

                r = []
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)

                #self.usertypes = None  ## restore default types
                for k in keys:
                    if k in self.usertypes:
                        self.usertypes.pop(k)

                return '\n'.join(r)

            elif node.context_expr.func.id == 'timeout':
                assert len(node.context_expr.args)==1
                self._timeout = self.visit(node.context_expr.args[0])

                r = [
                    'var __clk__ = (new Date()).getTime();',
                    'while (true) {     /* timeout: %s */' %self._timeout,
                ]
                self._in_timeout = True
                for b in node.body:
                    a = self.visit(b)
                    if a:
                        r.append(self.indent()+a)
                        if b is node.body[-1]:
                            break
                        if '(' in a and ')' in a:
                            r.append(
                                self.indent()+'if ( (new Date()).getTime() - __clk__ &gt;= %s )  { break;}' % self._timeout
                            )
                r.append('break; }')
                self._in_timeout = False
                return '\n'.join(r)

            elif node.context_expr.func.id == 'macro':
                assert len(node.context_expr.args)==1
                cppmacro = node.context_expr.args[0].s
                r = [cppmacro + '{']
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)
                r.append(self.indent()+'}')
                return '\n'.join(r)

            else:
                raise SyntaxError( 'invalid use of with: %s' %node.context_expr)

        elif isinstance(node.context_expr, ast.Str):
            if self._cpp:
                body = ['namespace %s {' %node.context_expr.s]
                self.push()
                for b in node.body:
                    body.append(self.visit(b))
                self.pull()
                body.append('}')
                return  '\n'.join(body)

            else:
                raise RuntimeError('TODO namespace for some backend')

        elif isinstance(node.context_expr, ast.Name) and node.optional_vars:
            assert isinstance(node.optional_vars, ast.Subscript)
            assert isinstance(node.optional_vars.slice, ast.Index)
            assert node.optional_vars.slice.value.id == 'MACRO'
            assert isinstance(node.optional_vars.value, ast.Str)
            if self._cpp:
                macro_string = self.visit_Str(node.optional_vars.value, wrap=False)
            else:
                macro_string = self.visit(node.optional_vars.value)[1:-1]

            macro_string = macro_string.replace('\\&quot;', '&quot;')

            if macro_string.startswith('&quot;'):
                raise SyntaxError('bad macro: ' + macro_string)

            macro_name   = self.visit(node.context_expr)
            self.macros[ macro_name ] = macro_string  ## set macro
            r = []
            for b in node.body:
                a = self.visit(b)
                if a:
                    if len(r): r.append(self.indent()+a)
                    else: r.append(a)

            self.macros.pop( macro_name )  ## remove macro
            return '\n'.join(r)

        elif isinstance(node.context_expr, ast.Name):
            if node.context_expr.id == 'typedef':
                r = []
                for b in node.body:
                    assert isinstance(b, ast.Assign)
                    tdef  = self.visit(b.value)
                    tname = self.visit(b.targets[0])
                    self._typedefs[tname] = tdef
                    if isinstance(tdef, tuple):
                        self._typedefs[tname] = tdef[0]
                        if tdef[0]=='std::vector&lt;tuple&gt;':
                            if self._memory[-1]=='STACK':
                                tdef = 'std::vector&lt;std::tuple&lt;%s&gt;&gt;' %','.join(tdef[1])
                            else:
                                tdef = 'std::shared_ptr&lt; std::vector&lt;std::shared_ptr&lt;std::tuple&lt;%s&gt;&gt;&gt; &gt;' %','.join(tdef[1])
                        else:
                            ## ignore constructor part `foo = []bar()` ##
                            if self._memory[-1]=='STACK':
                                tdef = tdef[0]
                            else:
                                tdef = 'std::shared_ptr&lt;%s&gt;' %tdef[0]
                    elif tdef.startswith('tuple('):
                        if self._memory[-1]=='STACK':
                            tdef = 'std::tuple&lt;%s&gt;' %','.join([self.visit(t) for t in b.value.args])
                        else:
                            tdef = 'std::shared_ptr&lt;std::tuple&lt;%s&gt;&gt;' %','.join([self.visit(t) for t in b.value.args])

                    r.append('typedef %s %s;' %(tdef, tname))
                return '\n'.join(r)

            elif node.context_expr.id == 'constant':
                self._in_constant = True
                r = []
                for b in node.body:
                    a = self.visit(b)
                    if a:
                        if isinstance(b, ast.Assign) and '=' in a:
                            a = 'const ' + a
                        r.append(self.indent()+a)
                self._in_constant = False
                return '\n'.join(r)

            elif node.context_expr.id in ('atomic', 'relaxed', 'transaction'):
                self._has_gnu_stm = True
                r = []
                if node.context_expr.id=='atomic':
                    r.append('__transaction_atomic {')
                else:
                    r.append('__transaction_relaxed {')  ## slightly slower

                self.push()
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)
                self.pull()
                r.append(self.indent()+'}')
                return '\n'.join(r)

            elif node.context_expr.id == 'stack':
                self._memory.append('STACK')
                r = []
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)
                self._memory.pop()
                return '\n'.join(r)
            elif node.context_expr.id == 'heap':
                self._memory.append('HEAP')
                r = []
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)
                self._memory.pop()
                return '\n'.join(r)

            elif node.context_expr.id == 'unique_ptr':
                self._unique_ptr = True
                r = []
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)
                self._unique_ptr = False
                return '\n'.join(r)
            elif node.context_expr.id == 'pointers':
                self._shared_pointers = False
                r = []
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)
                self._shared_pointers = True
                return '\n'.join(r)
            elif node.context_expr.id == 'gil':
                r = ['auto __gstate__ = PyGILState_Ensure();']
                for b in node.body:
                    a = self.visit(b)
                    if a: r.append(self.indent()+a)
                r.append('PyGILState_Release(__gstate__);')
                return '\n'.join(r)

            else:
                raise RuntimeError('TODO with syntax:%s'%node.context_expr.id)

        elif isinstance(node.context_expr, ast.List) and node.optional_vars and self.visit(node.optional_vars)=='future':
            assert self._memory[-1]=='STACK'
            self._lambda_stack.append( node )
            node.chain_then = []

            r = []
            fut = self.visit(node.context_expr.elts[0])
            #then_cap = self.visit(node.context_expr.elts[1].keywords[0])[ 1 ]  ## TODO more `and then(..)` chains
            then_cap = ''
            then_fut = ''
            then_callback = None

            if len(node.context_expr.elts[1].keywords):
                if node.context_expr.elts[1].keywords[0].arg == 'callback':
                    then_callback = self.visit(node.context_expr.elts[1].keywords[0].value)
                elif node.context_expr.elts[1].keywords[0].arg == 'capture':

                    then_cap = node.context_expr.elts[1].keywords[0].value
                    then_cap = ['&amp;'+self.visit(a) for a in then_cap.elts ]


                    assert node.context_expr.elts[1].keywords[1].arg == 'future'
                    then_fut = node.context_expr.elts[1].keywords[1].value
                    then_fut = ['auto '+self.visit(a) for a in then_fut.elts ]
                else:
                    raise SyntaxError('invalid use of then() keyword option')


            if fut.startswith('return_'):
                fut = fut[len('return_'):]

                if then_callback or fut.startswith('repeat('):
                    r.append(
                        'return %s([&amp;] {' %fut.split('(')[0]
                    )
                else:
                    r.append(
                        'return %s.then([%s] (%s){' % (fut, ','.join(then_cap), ','.join(then_fut) )
                    )
            else:
                #raise RuntimeError('TODO `continue foo() and then:`')

                if then_callback or fut.startswith('repeat('):
                    r.append(
                        '%s([&amp;] {' %fut.split('(')[0]
                    )
                else:
                    r.append(
                        '%s.then([%s] (%s){' % (fut, ','.join(then_cap), ','.join(then_fut) )
                    )


            self.push()
            for b in node.body:
                a = self.visit(b)
                if a: r.append(self.indent()+a)
            self.pull()

            if then_callback:
                r.append(self.indent()+'}).then(%s)' %then_callback)
            else:
                r.append(self.indent()+'})')  ## note closes: lambda{, then(, return;

            if len(self._lambda_stack):
                chain_then = self._lambda_stack[-1].chain_then
                if chain_then:
                    chain_then.reverse()
                    while chain_then:
                        n = chain_then.pop()
                        r[-1] += '.then([]() {'
                        self.push()
                        for b in n.body:
                            a = self.visit(b)
                            if a: r.append(self.indent()+a)
                        self.pull()
                        r.append(self.indent()+'})')

            r[-1] += ';'
            self._lambda_stack.pop()

            return '\n'.join(r)

        elif isinstance(node.context_expr, ast.Tuple) or isinstance(node.context_expr, ast.List):
            for elt in node.context_expr.elts:
                if elt.id == 'pointers':
                    self._shared_pointers = False
                elif elt.id == 'noexcept':
                    self._noexcept = True
                elif elt.id == 'unique_ptr':
                    self._unique_ptr = True
                elif elt.id == 'stack':
                    self._memory.append('STACK')
                elif elt.id == 'heap':
                    self._memory.append('HEAP')

            r = []
            for b in node.body:
                a = self.visit(b)
                if a: r.append(self.indent()+a)

            for elt in node.context_expr.elts:
                if elt.id == 'pointers':
                    self._shared_pointers = True
                elif elt.id == 'noexcept':
                    self._noexcept = False
                elif elt.id == 'unique_ptr':
                    self._unique_ptr = False
                elif elt.id == 'stack':
                    self._memory.pop()
                elif elt.id == 'heap':
                    self._memory.pop()

            return '\n'.join(r)

        else:
            raise SyntaxError( 'invalid use of with', node.context_expr)


        for b in node.body:
            a = self.visit(b)
            if a: r.append(self.indent()+a)

        if is_case and not self._rust:  ## always break after each case - do not fallthru to default: block
            if select_hack or self._go:
                r.append(self.indent()+' break;}')
            else:
                r.append(self.indent()+'} break;')  ## } extra scope
        ###################################

        if is_extern:
            r.append(self.indent()+'}')

        elif is_select:
            if self._cpp:
                r.append(self.indent()+'_select_.wait();')
            elif self._rust:
                r.append(self.indent()+'})')  ## rust needs extra closing brace for the match-block
            elif self._go:
                r.append(self.indent()+'}')
            else:
                r.append(self.indent()+'break; }')

            self._with_type.pop()

        elif is_switch:
            if self._rust and not self._cpp:
                r.append(self.indent()+'}}')  ## rust needs extra closing brace for the match-block
            else:
                r.append(self.indent()+'}')

            self._with_type.pop()
            self._rename_hacks.clear()   ## TODO properly clear

        return '\n'.join(r)

</code></pre>

<h2 id="go-hacks">Go hacks</h2>
<p>TODO clean up.</p>
<pre><code class="python">
    def parse_go_style_arg( self, s ):
        if isinstance(s, ast.Str): s = s.s
        return s.split(']')[-1]

    def _visit_call_helper_go(self, node):
        go_types = 'bool string int float64'.split()

        name = self.visit(node.func)
        if name == '__go__':
            if self._cpp:
                ## simple auto threads
                thread = '__thread%s__' %len(self._threads)
                self._threads.append(thread)
                ## do not capture all variables by reference `&amp;`,
                ## because threads spawned in a for loop will all share
                ## references to loop variants.
                #closure_wrapper = '[&amp;]{%s;}'%self.visit(node.args[0])
                ## TODO: capture by reference list of arrays and objects,
                ## unknown variables default to copy into thread.
                closure_wrapper = '[=]{%s;}'%self.visit(node.args[0])

                return 'std::thread %s( %s );' %(thread, closure_wrapper)
            elif self._rust:
                return 'thread::spawn( move || {%s;} );' % self.visit(node.args[0])
            elif self._go:
                return 'go %s' %self.visit(node.args[0])
            else:  ## javascript
                r = self.visit(node.args[0])
                mode = 'call'
                fname = self.visit(node.args[0].func)
                args = [self.visit(a) for a in node.args[0].args]
                if fname == 'new':
                    mode = 'new'
                    fname = self.visit(node.args[0].args[0].func)
                    args = [self.visit(a) for a in node.args[0].args[0].args]
                if node.keywords:
                    if not node.keywords[0].arg=='cpu':
                        raise SyntaxError('invalid keyword argument to the builtin `spawn`')
                    cpuid = self.visit(node.keywords[0].value)
                    return 'ⲢⲑⲑⲒ.spawn({%s:&quot;%s&quot;, args:[%s]}, {cpu:%s})' %(mode,fname, ','.join(args), cpuid)
                else:
                    return 'ⲢⲑⲑⲒ.spawn({%s:&quot;%s&quot;, args:[%s]})' %(mode,fname, ','.join(args))

        elif name == '__go_make__':
            if len(node.args)==2:
                return 'make(%s, %s)' %(self.visit(node.args[0]), self.visit(node.args[1]))
            elif len(node.args)==3:
                return 'make(%s, %s, %s)' %(self.visit(node.args[0]), self.visit(node.args[1]), self.visit(node.args[1]))
            else:
                raise SyntaxError('go make requires 2 or 3 arguments')
        elif name == '__go_make_chan__':
            ## channel constructors
            if self._cpp:
                ## cpp-channel API supports input/output
                T = self.visit(node.args[0])
                if self.is_prim_type(T):
                    return 'cpp::channel&lt;%s&gt;{}'%T
                else:
                    return 'cpp::channel&lt;%s*&gt;{}'%T
            elif self._rust:
                ## rust returns a tuple input/output that needs to be destructured by the caller
                return 'channel::&lt;%s&gt;()' %self.visit(node.args[0])
            else:  ## Go
                return 'make(chan %s)' %self.visit(node.args[0])

        elif name == '__go__array__':
            if isinstance(node.args[0], ast.BinOp):# and node.args[0].op == '&lt;&lt;':  ## todo assert right is `typedef`
                a = self.visit(node.args[0].left)
                T = self.visit(node.args[0])
                if type(T) is tuple:
                    assert T[1]=='typedef'
                    T = T[0]

                if self._cpp:
                    if self._memory[-1]=='STACK':
                        return 'std::vector&lt;%s&gt;' %T
                    else:
                        return 'std::shared_ptr&lt;std::vector&lt;%s&gt;&gt;' %T
                else:
                    if a in go_types:
                        if self._go:
                            return '*[]%s' %a
                        elif self._rust:
                            return '&amp;mut Vec&lt;%s&gt;' %a  ## TODO test this
                        else:
                            raise RuntimeError('todo')
                    else:
                        return '*[]*%s' %a  ## todo - self._catch_assignment_array_of_obs = true

            else:
                a = self.visit(node.args[0])
                if a in go_types:
                    return '[]%s{}' %a
                else:
                    return '[]*%s{}' %a
        elif name == '__go__addr__':
            return '&amp;%s' %self.visit(node.args[0])
        else:
            raise SyntaxError(name)

</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../jstranslator/" class="btn btn-neutral float-right" title="JavascriptTranslator">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/secureosv/pythia" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../jstranslator/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
