{
    "docs": [
        {
            "location": "/", 
            "text": "AST Translation\n\n\nAbstract Syntax Trees (AST) translate source code into objects you can traverse over\nand generate new code in the process.  The \nast\n module is built into Python, and is\nthe standard way to translate python source code into another language. \n\n\nThe best documentation on the Python \nast\n module is \nGreen Tree Snakes\n\n\nPythia Source Code\n\n\nMost of Pythia's source code is written in markdown files, and compiled by \npythia.py\n which loads \nmain.md", 
            "title": "Home"
        }, 
        {
            "location": "/#ast-translation", 
            "text": "Abstract Syntax Trees (AST) translate source code into objects you can traverse over\nand generate new code in the process.  The  ast  module is built into Python, and is\nthe standard way to translate python source code into another language.   The best documentation on the Python  ast  module is  Green Tree Snakes", 
            "title": "AST Translation"
        }, 
        {
            "location": "/#pythia-source-code", 
            "text": "Most of Pythia's source code is written in markdown files, and compiled by  pythia.py  which loads  main.md", 
            "title": "Pythia Source Code"
        }, 
        {
            "location": "/generatorbase/", 
            "text": "Transpiler Base Class\n\n\nshared methods used by most backends are here.\nTODO move \n__init__\n from jstranslator.md to here.\n\n\nImports\n\n\n\n\n@import clikelang.md\n\n\n\n\n\nclass GeneratorBase( CLikeLanguage ):\n\n    def visit_IfExp(self, node):\n        ## ternary operator ##\n        test    = self.visit(node.test)\n        iftrue  = self.visit(node.body)\n        iffalse = self.visit(node.orelse)\n        return '(%s ? %s : %s)' %(test, iftrue, iffalse)\n\n\n    def visit_Expr(self, node):\n        ## note: the javascript backend overloads this ##\n        s = self.visit(node.value)\n        if s is None:\n            raise RuntimeError('GeneratorBase ExpressionError: %s' %node.value)\n        if s.strip() and not s.endswith(';'):\n            s += ';'\n        if s==';': return ''\n        else: return s\n\n    def function_has_getter_or_setter(self, node):\n        options = {'getter':False, 'setter':False}\n        for d in node.decorator_list:\n            self._visit_decorator(d, options=options)\n        return options['getter'] or options['setter']\n\n\n    def visit_Tuple(self, node, force_make_tuple=False):\n        if self._rust:\n            return 'vec!(%s)' % ', '.join(map(self.visit, node.elts))\n        elif self._cpp:\n            if len(self._stack) \n= 2 and isinstance(self._stack[-2], ast.Call) or force_make_tuple:\n                if isinstance(self._stack[-2].func, ast.Name) and self._stack[-2].func.id=='__array__':  ## special case\n                    return '{%s}' %','.join(map(self.visit, node.elts))\n                else:\n                    tupletype, tupleinit = self.make_tuple(node.elts)\n                    if self._memory[-1]=='STACK':\n                        return 'std::make_tuple(%s)' %','.join(tupleinit)\n                    else:\n                        #declargs = ['decltype(%s)'%self.visit(da) for da in node.elts]\n                        return 'std::make_shared\nstd::tuple\n%s\n(std::make_tuple(%s))' %(','.join(tupletype), ','.join(tupleinit))\n            else:\n                return '{%s}' %','.join(map(self.visit, node.elts))\n        else:\n            return '[%s]' % ', '.join(map(self.visit, node.elts))\n\n    def visit_List(self, node):\n        a = []\n        for elt in node.elts:\n            b = self.visit(elt)\n            if b is None: raise SyntaxError( self.format_error(elt) )\n            a.append( b )\n        return '[%s]' % ', '.join(a)\n\n    def visit_Subscript(self, node):\n        if isinstance(node.slice, ast.Ellipsis):\n            return self._visit_subscript_ellipsis( node )\n        else:\n            return '%s[%s]' % (self.visit(node.value), self.visit(node.slice))\n\n    def visit_Index(self, node):\n        return self.visit(node.value)\n\n    def _visit_call_helper_instanceof(self, node):\n        args = map(self.visit, node.args)\n        if len(args) == 2:\n            return '%s instanceof %s' %tuple(args)\n        else:\n            raise SyntaxError( args )\n\n    def _visit_call_helper_new(self, node):\n        args = map(self.visit, node.args)\n        if len(args) == 1:\n            return ' new %s' %args[0]\n        else:\n            raise SyntaxError( args )\n\n    def _visit_call_special( self, node ):\n        raise NotImplementedError('special call')\n\n\n\n\n\nCall Function/Method\n\n\nThe backends subclass _visit_call_helper, which gets called here after doing some bookeeping like\ntracking what function names have been called, so backends can check \nself._called_funtions\n and\ndo extra things like inline extra helper code for things like \nhasattr\n, etc.\n\n\n\n    def visit_Call(self, node):\n        name = self.visit(node.func)\n        if name not in self._called_functions:\n            self._called_functions[name] = 0\n        self._called_functions[name] += 1\n\n        if name in typedpython.GO_SPECIAL_CALLS.values():\n            return self._visit_call_helper_go( node )\n\n        elif name in self.catch_call:\n            return self._visit_call_special( node )\n\n        elif name == 'instanceof':  ## it is safer to use the builtin `isinstance`\n            return self._visit_call_helper_instanceof( node )\n\n        elif name == 'new':\n            return self._visit_call_helper_new( node )\n\n        elif name == '__ternary_operator__':\n            args = map(self.visit, node.args)\n            if len(args) == 2:\n                return '((%s) ? %s : %s)' %(args[0], args[0], args[1])\n            elif len(args) == 3:\n                return '((%s) ? %s : %s)' %(args[0], args[1], args[2])\n            else:\n                raise SyntaxError( args )\n\n        elif name == 'numpy.array':\n            return self._visit_call_helper_numpy_array(node)\n\n        elif name == 'JSObject':\n            return self._visit_call_helper_JSObject( node )\n\n        elif name == 'var':\n            return self._visit_call_helper_var( node )\n\n        elif name == 'JSArray':\n            return self._visit_call_helper_JSArray( node )\n\n        elif name == 'inline' or name == 'JS':\n            assert len(node.args)==1 and isinstance(node.args[0], ast.Str)\n            return self._inline_code_helper( node.args[0].s )\n\n        elif name == 'list':\n            return self._visit_call_helper_list( node )\n\n        elif name == '__get__' and len(node.args)==2 and isinstance(node.args[1], ast.Str) and node.args[1].s=='__call__':\n            raise SyntaxError('deprecated')\n            return self._visit_call_helper_get_call_special( node )\n\n        elif name.split('.')[-1] == '__go__receive__':\n            raise SyntaxError('this should not happen __go__receive__')\n\n        else:\n            return self._visit_call_helper(node)\n\n\n\n\n\n\n\nImport \nimport x\n and \nfrom x import y\n\n\n\n    def _importfrom_helper(self, node):\n        return ''\n\n    def visit_ImportFrom(self, node):\n        # print node.module\n        # print node.names[0].name\n        # print node.level\n        if self._rust:\n            crate = self._crates[node.module]\n            for alias in node.names:\n                crate.add( alias.name )\n        if node.module=='runtime':\n            self._insert_runtime = True\n        else:\n            return self._importfrom_helper(node)\n\n        return ''\n\n    def visit_Import(self, node):\n        r = [alias.name.replace('__SLASH__', '/') for alias in node.names]\n        res = []\n        if r:\n            for name in r:\n                if self._rust:  ## TODO move this to rusttranslator.md\n                    if name not in self._crates:\n                        self._crates[name] = set()\n                else:\n                    raise SyntaxError('import not yet support for this backend')\n\n        if res:\n            return '\\n'.join(res)\n        else:\n            return ''\n\n\n\n\n\nis_prim_type\n\n\nthe typed backends like: go, rust and c++ need to know if a variable type is a builtin primitive,\nor something that needs to be wrapped by a pointer/shared-reference.\n\n\n\n    def is_prim_type(self, T):\n        prims = 'auto void bool unsigned int float double long string str char byte u32 u64 i32 i64 f32 f64 float32 float64 std::string cstring'.split()\n        if hasattr(self, '_typedefs'):\n            prims.extend( self._typedefs.keys() )\n\n        if self._go:\n            prims.append( 'interface{}' )\n        if T in prims:\n            return True\n        elif T.endswith(']'):  ## c-style array\n            return True\n        else:\n            return False\n\n    def indent(self): return '\\t' * self._indent\n    def push(self): self._indent += 1\n    def pull(self):\n        if self._indent \n 0: self._indent -= 1\n\n\n\n\n\nFunction Decorators\n\n\n_visit_decorator\n is called by the other backends, the shared decorator logic is here.\n\n\n\n    def _visit_decorator(self, decor, node=None, options=None, args_typedefs=None, chan_args_typedefs=None, generics=None, args_generics=None, func_pointers=None, arrays=None, args_super_classes=None ):\n        assert node\n        if options is None: options = dict()\n        if args_typedefs is None: args_typedefs = dict()\n        if chan_args_typedefs is None: chan_args_typedefs = dict()\n        if generics is None: generics = set()\n        if args_generics is None: args_generics = dict()\n        if func_pointers is None: func_pointers = set()\n        if arrays is None: arrays = dict()\n        if args_super_classes is None: args_super_classes = dict()\n\n        if isinstance(decor, ast.Name) and decor.id == 'classmethod':\n            options['classmethod'] = True\n\n        elif isinstance(decor, ast.Name) and decor.id == 'property':\n            ## a function is marked as a getter with `@property`\n            options['getter'] = True\n        elif isinstance(decor, ast.Attribute) and isinstance(decor.value, ast.Name) and decor.attr == 'setter':\n            ## a function is marked as a setter with `@name.setter`\n            options['setter'] = True\n\n        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef__':\n            if len(decor.args) == 3:\n                vname = self.visit(decor.args[0])\n                if isinstance(decor.args[1], ast.Str):\n                    vtype = decor.args[1].s\n                else:\n                    vtype = self.visit(decor.args[1])\n                vptr = decor.args[2].s\n\n                ## note: the space is required because it could be `mut` rust-keyword, or `struct` C type.\n                args_typedefs[ vname ] = '%s %s' %(vptr, vtype)\n\n            else:\n                args_user_classes = {}\n                for key in decor.keywords:\n                    args_user_classes[key.arg] = None\n\n                    if isinstance( key.value, ast.Str):\n                        args_typedefs[ key.arg ] = key.value.s\n                        if key.value.s in self._classes:  ## TODO check if endswith *\n                            args_user_classes[key.arg] = key.value.s\n                        elif key.value.s.startswith('['):\n                            n,T = key.value.s.split(']')\n                            n += ']'\n                            args_typedefs[key.arg]=T+n\n\n                    elif isinstance(key.value, ast.Name):\n                        T = key.value.id\n                        if T in self._classes:\n                            args_user_classes[key.arg] = T\n\n                        if self.is_prim_type(T) or self._memory[-1]=='STACK':\n                            args_typedefs[key.arg] = T\n                        elif self._cpp:\n                            if self.usertypes and 'shared' in self.usertypes:\n                                args_typedefs[ key.arg ] = self.usertypes['shared']['template'] %T\n                            elif not self._shared_pointers:\n                                args_typedefs[ key.arg ] = '%s*' %T\n                            elif self._unique_ptr:\n                                args_typedefs[ key.arg ] = 'std::unique_ptr\n%s\n' %T\n                            else:\n                                assert self._memory[-1]=='HEAP'\n                                args_typedefs[ key.arg ] = 'std::shared_ptr\n%s\n' %T\n\n                        else:  ## javascript runtime checked types\n                            args_typedefs[key.arg] = T\n\n                    else:\n                        if isinstance(key.value, ast.Call) and isinstance(key.value.func, ast.Name) and key.value.func.id=='__arg_array__':\n                            arrays[ key.arg ] = key.value.args[0].s\n                            dims = arrays[ key.arg ].count('[')\n                            arrtype = arrays[ key.arg ].split(']')[-1]\n\n                            if self._rust:\n                                if not self.is_prim_type(arrtype):\n                                    arrtype = 'Rc\nRefCell\n%s\n' %arrtype\n\n                                args_typedefs[ key.arg ] = 'Rc\nRefCell\nVec\n%s\n' %arrtype\n\n                            elif self._cpp:\n                                ## non primitive types (objects and arrays) can be None, `[]MyClass( None, None)`\n                                ## use a pointer or smart pointer. \n                                if not self.is_prim_type(arrtype) and self._memory[-1]=='HEAP':\n                                    if not self._shared_pointers:\n                                        arrtype += '*'\n                                    elif self.usertypes and 'shared' in self.usertypes:\n                                        arrtype = self.usertypes['shared']['template'] % arrtype\n                                    elif self._unique_ptr:\n                                        arrtype = 'std::unique_ptr\n%s\n' %arrtype\n                                    else:\n                                        arrtype = 'std::shared_ptr\n%s\n' %arrtype\n\n\n                                T = []\n\n                                for i in range(dims):\n                                    if not self._shared_pointers or self._memory[-1]=='STACK':\n                                        T.append('std::vector\n')\n                                    elif self.usertypes and 'vector' in self.usertypes:\n                                        sptr = self.usertypes['shared']['type']\n                                        vptr = self.usertypes['vector']['template'].split(\n%s\n)[0]\n                                        T.append('%s%s' %(sptr, vptr))                                  \n                                    elif self._unique_ptr:\n                                        T.append('std::unique_ptr\nstd::vector\n')\n                                    else:\n                                        T.append('std::shared_ptr\nstd::vector\n')\n                                T.append( arrtype )\n\n                                if self._memory[-1]=='STACK':\n                                    for i in range(dims):\n                                        #if i: T.append('*\n')\n                                        #else: T.append('\n')\n                                        T.append('\n')\n                                    T.append('*')\n\n                                elif self._shared_pointers or 'vector' in self.usertypes:\n                                    for i in range(dims):\n                                        T.append('\n')\n                                else:\n                                    for i in range(dims):\n                                        if i: T.append('*\n')\n                                        else: T.append('\n')\n                                    T.append('*')\n\n                                args_typedefs[ key.arg ] = ''.join(T)\n\n                            else:  ## javascript backend\n                                args_typedefs[ key.arg ] = key.value.args[0].s\n\n                        else:\n                            args_typedefs[ key.arg ] = self.visit(key.value)\n\n                    if args_typedefs[key.arg].startswith('func(') or args_typedefs[key.arg].startswith('lambda('):\n                        is_lambda_style = args_typedefs[key.arg].startswith('lambda(')\n                        func_pointers.add( key.arg )\n                        funcdef = args_typedefs[key.arg]\n                        ## TODO - better parser\n                        hack = funcdef.replace(')', '(').split('(')\n                        lambda_args = []\n                        TODO_REPLACE_PIPE_HACK = '|'  ## note new syntax is space separated\n                        for larg in hack[1].strip().split(TODO_REPLACE_PIPE_HACK):\n                            if self.is_prim_type(larg):\n                                lambda_args.append(larg)\n                            elif not larg:\n                                lambda_args.append('void')\n                            else:\n                                lambda_args.append('std::shared_ptr\n%s\n'%larg)\n\n                        lambda_args = ','.join(lambda_args)\n                        lambda_return = hack[3].strip()\n                        if not lambda_return: lambda_return = 'void'\n                        if not self.is_prim_type(lambda_return):\n                            lambda_return = 'std::shared_ptr\n%s\n'%lambda_return\n\n                        if self._cpp:\n                            if is_lambda_style:\n                                if lambda_return:  ## c++11\n                                    args_typedefs[ key.arg ] = 'std::function\n%s(%s)\n  %s' %(lambda_return, lambda_args, key.arg)\n                                else:\n                                    args_typedefs[ key.arg ] = 'std::function\nvoid(%s)\n  %s' %(lambda_args, key.arg)\n\n                            else:  ## old C style function pointers\n                                if lambda_return:\n                                    args_typedefs[ key.arg ] = '%s(*%s)(%s)' %(lambda_return, key.arg, lambda_args)\n                                else:\n                                    args_typedefs[ key.arg ] = 'void(*%s)(%s)' %(key.arg, lambda_args)\n\n                        elif self._rust:\n                            if lambda_return:\n                                args_typedefs[ key.arg ] = '|%s|-\n%s' %(lambda_args, lambda_return)\n                            else:\n                                args_typedefs[ key.arg ] = '|%s|' %lambda_args\n\n                        elif self._dart:\n                            args_typedefs[ key.arg ] = 'var'\n\n                    ## check for super classes - generics ##\n                    ## this was originally for the Go backend, still used in the c++ or rust backends?\n                    #if (self._go or self._cpp or self._rust) and args_typedefs[ key.arg ] in self._classes:\n                    if (self._go or self._cpp or self._rust) and args_user_classes[ key.arg ]:\n                        classname = args_user_classes[ key.arg ]\n                        options['generic_base_class'] = classname\n\n                        if self._cpp:\n                            #if self._memory[-1]=='STACK':\n                            #   #args_typedefs[key.arg] = 'const %s' %classname\n                            #   pass\n                            #elif not self._shared_pointers:\n                            #   args_typedefs[ key.arg ] = '%s*' %classname\n                            #elif self.usertypes and 'shared' in self.usertypes:\n                            #   args_typedefs[ key.arg ] = self.usertypes['shared']['template'] % classname\n                            #elif self._unique_ptr:\n                            #   args_typedefs[ key.arg ] = 'std::unique_ptr\n%s\n' %classname\n                            #else:\n                            #   args_typedefs[ key.arg ] = 'std::shared_ptr\n%s\n' %classname\n                            #args_generics[ key.arg ] = classname\n\n                            #for subclass in self._classes[classname]._subclasses:\n                            #   generics.add( subclass )\n\n                            cnode = self._classes[classname]\n                            if cnode._parents:\n                                args_super_classes[key.arg] = []\n                                for base in cnode._parents:\n                                    args_super_classes[key.arg].append(base)\n\n                        elif self._rust:\n                            args_typedefs[ key.arg ] = 'Rc\nRefCell\n%s\n' %classname\n\n                        elif self._go:  ## TODO test if this is still working in the Go backend\n                            if node.name=='__init__':\n                                ## generics type switch is not possible in __init__ because\n                                ## it is used to generate the type struct, where types are static.\n                                ## as a workaround generics passed to init always become `interface{}`\n                                args_typedefs[ key.arg ] = 'interface{}'\n                                #self._class_stack[-1]._struct_def[ key.arg ] = 'interface{}'\n                            else:\n                                generics.add( classname ) # switch v.(type) for each\n                                generics = generics.union( self._classes[classname]._subclasses )  ## TODO\n                                args_typedefs[ key.arg ] = 'interface{}'\n                                args_generics[ key.arg ] = classname\n\n        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef_chan__':\n            for key in decor.keywords:\n                if isinstance(key.value, ast.Str):\n                    chan_args_typedefs[ key.arg ] = key.value.s.strip()\n                else:\n                    chan_args_typedefs[ key.arg ] = self.visit(key.value)\n        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'returns':\n            if decor.keywords:\n                raise SyntaxError('invalid go return type')\n            elif isinstance(decor.args[0], ast.Name):\n                options['returns'] = decor.args[0].id\n            else:\n                options['returns'] = decor.args[0].s\n\n            if options['returns'].startswith('[]'):\n                options['returns_array'] = True\n                options['returns_array_dim'] = options['returns'].count('[]')\n\n                vectype = options['returns'].split(']')[-1]\n                if self._cpp and vectype.startswith('tuple(') and vectype.endswith(')'):\n                    tupletypes = vectype[ len('tuple(') : -1 ].split(',')\n                    vectype = 'std::tuple\n%s\n' %','.join(tupletypes)\n                    if self._memory[-1]=='HEAP':\n                        vectype = 'std::shared_ptr\n%s\n' %vectype\n                options['returns_array_type'] = vectype\n\n                if self._cpp:\n                    if options['returns_array_type']=='string':\n                        options['returns_array_type'] = 'std::string'\n\n                    T = []\n                    for i in range(options['returns_array_dim']):\n                        if not self._shared_pointers or self._memory[-1]=='STACK':\n                            T.append('std::vector\n')\n                        elif self._unique_ptr:\n                            T.append('std::unique_ptr\nstd::vector\n')\n                        else:\n                            T.append('std::shared_ptr\nstd::vector\n')\n\n                    T.append(options['returns_array_type'])\n\n                    if self._memory[-1]=='STACK':\n                        for i in range(options['returns_array_dim']):\n                            T.append('\n')\n                        #T.append('*')  ## return copy\n                    elif self._shared_pointers and self._memory[-1]=='HEAP':\n                        for i in range(options['returns_array_dim']):\n                            T.append('\n')\n                    else:\n                        for i in range(options['returns_array_dim']):\n                            if i: T.append('*\n')\n                            else: T.append('\n')\n                        T.append('*')\n                    options['returns'] = ''.join(T)\n                elif self._rust:\n                    raise SyntaxError('TODO return 2d array rust backend')\n                else:\n                    raise SyntaxError('TODO return 2d array some backend')\n\n            if options['returns'] == 'self' and len(self._class_stack):\n                options['returns_self'] = True\n                self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n\n                if self._go:\n                    options['returns'] = '*' + self._class_stack[-1].name  ## go hacked generics\n\n\n\n\n\nFunction\n\n\ncalls \n_visit_function\n which is subclassed by other backends.\n\n\n\n    def visit_FunctionDef(self, node):\n        self._function_stack.append( node )\n        node._local_vars = set()\n        buffer = self._visit_function( node )\n\n        if node == self._function_stack[0]:  ## global function\n            self._global_functions[ node.name ] = node\n\n        self._function_stack.pop()\n        return buffer\n\n\n\n\n\nWith\n\n\nSpecial syntax that triggers different things depending on the backend.\nAlso implements extra syntax like \nswitch\n and \nselect\n.\n\n\n\n    def visit_With(self, node):\n        r = []\n        is_select = False\n        is_switch = False\n        is_switch_type = False\n        is_match  = False\n        is_case   = False\n        is_extern = False\n        has_default = False\n        withvalue = self.visit(node.context_expr)\n        if withvalue.startswith('return_'):\n            ## STACK MODE ##\n            ## all variables must be on or moved onto stack for these operations.\n            ## see also: \n            ##      `repeat(...):`\n            ##      `return foo() and then(capture=[], ...):`\n\n            self._memory.append('STACK')\n            has_then = False\n            if 'then(' in withvalue:\n                has_then = withvalue.split('.then(')[-1].split(')')[0]\n\n            rcall = withvalue.split('return_')[-1].split('(')[0].split()[0]\n            rargs = withvalue.split('(')[1].split(')')[0].split(',')\n            if rcall=='do_with':\n                cargs = ','.join('auto\n %s'%ra.strip() for ra in rargs)\n                rargs = ','.join('std::move(%s)'%ra.strip() for ra in rargs)\n                body = ['return do_with(%s, [] (%s) {' %(rargs, cargs)]\n            else:\n                rargs = ','.join('\n'+ra.strip() for ra in rargs)\n                body = ['return %s([%s] {' %(rcall, rargs)]\n\n            self.push()\n            for b in node.body:\n                body.append(self.indent()+self.visit(b))\n            self.pull()\n\n            if has_then:\n                #if rcall=='repeat':\n                #   raise RuntimeError(withvalue+':'+rargs+':'+has_then)\n                body.append(self.indent()+'}).then(%s);' %has_then)\n            else:\n                body.append(self.indent()+'});')\n\n            self._memory.pop()\n            return '\\n'.join(body)\n\n        elif isinstance(node.context_expr, ast.Name) and node.context_expr.id in ('oo', 'operator_overloading'):\n            self._with_oo = True\n            body = []\n            for b in node.body: body.append(self.visit(b))\n            self._with_oo = False\n            return '\\n'.join(body)\n\n        elif isinstance( node.context_expr, ast.Name ) and node.context_expr.id == '__default__':\n            has_default = True\n            if self._rust and not self._cpp:\n                r.append(self.indent()+'}, _ =\n {')\n            else:\n                r.append(self.indent()+'default:')\n\n        elif isinstance( node.context_expr, ast.Name ) and node.context_expr.id == '__select__':\n            is_select = True\n            self._match_stack.append( list() )\n            self._in_select_hack = True\n            self._with_type.append('SELECT')\n\n            if self._rust:\n                r.append(self.indent()+'select! (')\n            elif self._cpp:\n                r.append(self.indent()+'cpp::select _select_;')  ## TODO nested, _select_N\n            elif self._go:\n                r.append(self.indent()+'select {')\n            else:  ## javascript\n                r.append('while (true) {        /* select loop */')\n\n\n        elif isinstance( node.context_expr, ast.Call ):\n            if not isinstance(node.context_expr.func, ast.Name):\n                raise SyntaxError( self.visit(node.context_expr))\n\n            #if len(node.context_expr.args):  ## what was this used for?\n            #   a = self.visit(node.context_expr.args[0])\n            #else:\n            #   assert len(node.context_expr.keywords)\n            #   ## need to catch if this is a new variable ##\n            #   name = node.context_expr.keywords[0].arg\n            #   if name not in self._known_vars:\n            #       a = 'let %s = %s' %(name, self.visit(node.context_expr.keywords[0].value))\n            #   else:\n            #       a = '%s = %s' %(name, self.visit(node.context_expr.keywords[0].value))\n\n            if node.context_expr.func.id == 'chain_then':\n                self._lambda_stack[-1].chain_then.append(node)\n                #self.chain_then.append(node)\n                return ''\n            elif node.context_expr.func.id == '__case__':\n                is_case = True\n                case_match = None\n                select_hack = None\n                if not len(node.context_expr.args):\n                    assert len(node.context_expr.keywords)==1\n                    kw = node.context_expr.keywords[0]\n                    if self._go:\n                        case_match = '%s := %s' %(kw.arg, self.visit(kw.value))\n                    elif hasattr(self, '_in_select_hack') and self._in_select_hack:\n                        select_hack = True\n                        if self._cpp:\n                            case_match = '_select_.recv(%s, %s);' %(self.visit(kw.value), kw.arg)                       \n\n                        else:  ## javascript backend ##\n                            #self.visit(kw.value) ## TODO allow worker returned from some call\n                            cid = kw.value.right.id\n                            case_match = 'if (\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8c\ud835\udc86\ud835\udc93\ud835\udc77\ud835\udc90\ud835\udc90\ud835\udc8d.select(%s).length) {var %s = \ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8c\ud835\udc86\ud835\udc93\ud835\udc77\ud835\udc90\ud835\udc90\ud835\udc8d.select(%s).pop();' %(cid, kw.arg, cid)\n                    elif is_switch_type:\n                        raise SyntaxError('invalid switch type')\n                    else:\n                        case_match = '%s = %s' %(kw.arg, self.visit(kw.value))\n                else:\n                    if isinstance(node.context_expr.args[0], ast.Compare):\n                        raise SyntaxError('\ncase x==n:\n is not allowed in a case statement, use \ncase n:\n instead.')\n                    case_match = self.visit(node.context_expr.args[0])\n\n                if select_hack:\n                    r.append(self.indent()+case_match)\n                elif self._rust and not self._cpp:\n                    if len(self._match_stack[-1])==0:\n                        r.append(self.indent()+'%s =\n {' %case_match)\n                    else:\n                        r.append(self.indent()+'}, %s =\n { ' %case_match )\n                else:\n                    if self._with_type[-1]=='SWITCH_TYPE':\n                        T = case_match\n                        o = self._switch_on_type_object[-1]\n                        classid = self._classes.keys().index(T)\n                        r.append(self.indent()+'case %s: {' %classid) ## extra scope\n                        r.append(self.indent()+'    auto _cast_%s = std::static_pointer_cast\n%s\n(%s);' %(o, T, o))\n                        case_match = '\n%s\n' %case_match\n                    else:\n                        r.append(self.indent()+'case %s: {' %case_match) ## extra scope\n\n                if not len(self._match_stack):\n                    raise SyntaxError('case statement used outside of a select or switch block')\n\n                self._match_stack[-1].append(case_match)\n\n\n            elif node.context_expr.func.id == '__switch__':\n                is_switch = True\n                self._match_stack.append( list() )\n\n                if self._rust and not self._cpp:\n                    r.append(self.indent()+'match (%s) {' %self.visit(node.context_expr.args[0]))\n                    is_match = True\n                else:\n                    switch_value = self.visit(node.context_expr.args[0])\n                    if switch_value.startswith('type(') and switch_value.endswith(')'):\n                        is_switch_type = True\n                        switch_object = switch_value[ len('type(') : -1 ].strip()\n                        self._rename_hacks[switch_object] = '_cast_' + switch_object\n                        self._switch_on_type_object.append(switch_object)\n                        switch_value = switch_object + '-\n__classid__'\n                    r.append(self.indent()+'switch (%s) {' %switch_value)\n\n                if is_switch_type:\n                    self._with_type.append('SWITCH_TYPE')\n                elif is_match:\n                    self._with_type.append('SWITCH_MATCH')\n                else:\n                    self._with_type.append('SWITCH')\n\n\n            elif node.context_expr.func.id == 'extern':\n                is_extern = True\n                link = None\n                for kw in node.context_expr.keywords:\n                    if kw.arg=='link':\n                        link = kw.value.s\n                if self._cpp:\n                    r.append('extern \nC\n {')  ## TODO other abis\n                elif self._rust:\n                    assert link\n                    r.append('#[link(name = \n%s\n)]' %link)\n                    r.append('extern {')\n\n                else:\n                    raise SyntaxError('with extern: not supported yet for backend')\n\n                ## strip the bodies from function defs, that should be just defined as `def f(args):pass`\n                for b in node.body:\n                    if isinstance(b, ast.FunctionDef):\n                        if b.body and len(b.body) \n= 2 and isinstance(b.body[-1], ast.Pass):\n                            b.body = []\n                            b.declare_only = True\n\n            elif node.context_expr.func.id == 'syntax':\n                assert len(node.context_expr.args)==1\n                keys = []\n                if isinstance(node.context_expr.args[0], ast.Dict):\n                    #self.usertypes = {'string':None}  ## force plain strings\n                    cfg = eval(self.visit(node.context_expr.args[0]))\n                    keys.extend( cfg.keys() )\n                    self.usertypes.update( cfg )\n                else:\n                    assert isinstance(node.context_expr.args[0], ast.Str)\n                    jsonfile = node.context_expr.args[0].s\n                    if jsonfile in self.cached_json_files:\n                        jdata = self.cached_json_files[jsonfile]\n                        cfg   = json.loads( jdata )\n                        keys.extend( cfg.keys() )\n                        self.usertypes.update( cfg )\n                    elif os.path.isfile(jsonfile):\n                        cfg   = json.load(jsonfile)\n                        keys.extend( cfg.keys() )\n                        self.usertypes.update( cfg )\n                    else:\n                        raise RuntimeError('can not load custom types json: %s' %jsonfile)\n\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n\n                #self.usertypes = None  ## restore default types\n                for k in keys:\n                    if k in self.usertypes:\n                        self.usertypes.pop(k)\n\n                return '\\n'.join(r)\n\n            elif node.context_expr.func.id == 'timeout':\n                assert len(node.context_expr.args)==1\n                self._timeout = self.visit(node.context_expr.args[0])\n\n                r = [\n                    'var __clk__ = (new Date()).getTime();',\n                    'while (true) {     /* timeout: %s */' %self._timeout,\n                ]\n                self._in_timeout = True\n                for b in node.body:\n                    a = self.visit(b)\n                    if a:\n                        r.append(self.indent()+a)\n                        if b is node.body[-1]:\n                            break\n                        if '(' in a and ')' in a:\n                            r.append(\n                                self.indent()+'if ( (new Date()).getTime() - __clk__ \n= %s )  { break;}' % self._timeout\n                            )\n                r.append('break; }')\n                self._in_timeout = False\n                return '\\n'.join(r)\n\n            elif node.context_expr.func.id == 'macro':\n                assert len(node.context_expr.args)==1\n                cppmacro = node.context_expr.args[0].s\n                r = [cppmacro + '{']\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                r.append(self.indent()+'}')\n                return '\\n'.join(r)\n\n            else:\n                raise SyntaxError( 'invalid use of with: %s' %node.context_expr)\n\n        elif isinstance(node.context_expr, ast.Str):\n            if self._cpp:\n                body = ['namespace %s {' %node.context_expr.s]\n                self.push()\n                for b in node.body:\n                    body.append(self.visit(b))\n                self.pull()\n                body.append('}')\n                return  '\\n'.join(body)\n\n            else:\n                raise RuntimeError('TODO namespace for some backend')\n\n        elif isinstance(node.context_expr, ast.Name) and node.optional_vars:\n            assert isinstance(node.optional_vars, ast.Subscript)\n            assert isinstance(node.optional_vars.slice, ast.Index)\n            assert node.optional_vars.slice.value.id == 'MACRO'\n            assert isinstance(node.optional_vars.value, ast.Str)\n            if self._cpp:\n                macro_string = self.visit_Str(node.optional_vars.value, wrap=False)\n            else:\n                macro_string = self.visit(node.optional_vars.value)[1:-1]\n\n            macro_string = macro_string.replace('\\\\\n', '\n')\n\n            if macro_string.startswith('\n'):\n                raise SyntaxError('bad macro: ' + macro_string)\n\n            macro_name   = self.visit(node.context_expr)\n            self.macros[ macro_name ] = macro_string  ## set macro\n            r = []\n            for b in node.body:\n                a = self.visit(b)\n                if a:\n                    if len(r): r.append(self.indent()+a)\n                    else: r.append(a)\n\n            self.macros.pop( macro_name )  ## remove macro\n            return '\\n'.join(r)\n\n        elif isinstance(node.context_expr, ast.Name):\n            if node.context_expr.id == 'typedef':\n                r = []\n                for b in node.body:\n                    assert isinstance(b, ast.Assign)\n                    tdef  = self.visit(b.value)\n                    tname = self.visit(b.targets[0])\n                    self._typedefs[tname] = tdef\n                    if isinstance(tdef, tuple):\n                        self._typedefs[tname] = tdef[0]\n                        if tdef[0]=='std::vector\ntuple\n':\n                            if self._memory[-1]=='STACK':\n                                tdef = 'std::vector\nstd::tuple\n%s\n' %','.join(tdef[1])\n                            else:\n                                tdef = 'std::shared_ptr\n std::vector\nstd::shared_ptr\nstd::tuple\n%s\n \n' %','.join(tdef[1])\n                        else:\n                            ## ignore constructor part `foo = []bar()` ##\n                            if self._memory[-1]=='STACK':\n                                tdef = tdef[0]\n                            else:\n                                tdef = 'std::shared_ptr\n%s\n' %tdef[0]\n                    elif tdef.startswith('tuple('):\n                        if self._memory[-1]=='STACK':\n                            tdef = 'std::tuple\n%s\n' %','.join([self.visit(t) for t in b.value.args])\n                        else:\n                            tdef = 'std::shared_ptr\nstd::tuple\n%s\n' %','.join([self.visit(t) for t in b.value.args])\n\n                    r.append('typedef %s %s;' %(tdef, tname))\n                return '\\n'.join(r)\n\n            elif node.context_expr.id == 'constant':\n                self._in_constant = True\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a:\n                        if isinstance(b, ast.Assign) and '=' in a:\n                            a = 'const ' + a\n                        r.append(self.indent()+a)\n                self._in_constant = False\n                return '\\n'.join(r)\n\n            elif node.context_expr.id in ('atomic', 'relaxed', 'transaction'):\n                self._has_gnu_stm = True\n                r = []\n                if node.context_expr.id=='atomic':\n                    r.append('__transaction_atomic {')\n                else:\n                    r.append('__transaction_relaxed {')  ## slightly slower\n\n                self.push()\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self.pull()\n                r.append(self.indent()+'}')\n                return '\\n'.join(r)\n\n            elif node.context_expr.id == 'stack':\n                self._memory.append('STACK')\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._memory.pop()\n                return '\\n'.join(r)\n            elif node.context_expr.id == 'heap':\n                self._memory.append('HEAP')\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._memory.pop()\n                return '\\n'.join(r)\n\n            elif node.context_expr.id == 'unique_ptr':\n                self._unique_ptr = True\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._unique_ptr = False\n                return '\\n'.join(r)\n            elif node.context_expr.id == 'pointers':\n                self._shared_pointers = False\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._shared_pointers = True\n                return '\\n'.join(r)\n            elif node.context_expr.id == 'gil':\n                r = ['auto __gstate__ = PyGILState_Ensure();']\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                r.append('PyGILState_Release(__gstate__);')\n                return '\\n'.join(r)\n\n            else:\n                raise RuntimeError('TODO with syntax:%s'%node.context_expr.id)\n\n        elif isinstance(node.context_expr, ast.List) and node.optional_vars and self.visit(node.optional_vars)=='future':\n            assert self._memory[-1]=='STACK'\n            self._lambda_stack.append( node )\n            node.chain_then = []\n\n            r = []\n            fut = self.visit(node.context_expr.elts[0])\n            #then_cap = self.visit(node.context_expr.elts[1].keywords[0])[ 1 ]  ## TODO more `and then(..)` chains\n            then_cap = ''\n            then_fut = ''\n            then_callback = None\n\n            if len(node.context_expr.elts[1].keywords):\n                if node.context_expr.elts[1].keywords[0].arg == 'callback':\n                    then_callback = self.visit(node.context_expr.elts[1].keywords[0].value)\n                elif node.context_expr.elts[1].keywords[0].arg == 'capture':\n\n                    then_cap = node.context_expr.elts[1].keywords[0].value\n                    then_cap = ['\n'+self.visit(a) for a in then_cap.elts ]\n\n\n                    assert node.context_expr.elts[1].keywords[1].arg == 'future'\n                    then_fut = node.context_expr.elts[1].keywords[1].value\n                    then_fut = ['auto '+self.visit(a) for a in then_fut.elts ]\n                else:\n                    raise SyntaxError('invalid use of then() keyword option')\n\n\n            if fut.startswith('return_'):\n                fut = fut[len('return_'):]\n\n                if then_callback or fut.startswith('repeat('):\n                    r.append(\n                        'return %s([\n] {' %fut.split('(')[0]\n                    )\n                else:\n                    r.append(\n                        'return %s.then([%s] (%s){' % (fut, ','.join(then_cap), ','.join(then_fut) )\n                    )\n            else:\n                #raise RuntimeError('TODO `continue foo() and then:`')\n\n                if then_callback or fut.startswith('repeat('):\n                    r.append(\n                        '%s([\n] {' %fut.split('(')[0]\n                    )\n                else:\n                    r.append(\n                        '%s.then([%s] (%s){' % (fut, ','.join(then_cap), ','.join(then_fut) )\n                    )\n\n\n            self.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: r.append(self.indent()+a)\n            self.pull()\n\n            if then_callback:\n                r.append(self.indent()+'}).then(%s)' %then_callback)\n            else:\n                r.append(self.indent()+'})')  ## note closes: lambda{, then(, return;\n\n            if len(self._lambda_stack):\n                chain_then = self._lambda_stack[-1].chain_then\n                if chain_then:\n                    chain_then.reverse()\n                    while chain_then:\n                        n = chain_then.pop()\n                        r[-1] += '.then([]() {'\n                        self.push()\n                        for b in n.body:\n                            a = self.visit(b)\n                            if a: r.append(self.indent()+a)\n                        self.pull()\n                        r.append(self.indent()+'})')\n\n            r[-1] += ';'\n            self._lambda_stack.pop()\n\n            return '\\n'.join(r)\n\n        elif isinstance(node.context_expr, ast.Tuple) or isinstance(node.context_expr, ast.List):\n            for elt in node.context_expr.elts:\n                if elt.id == 'pointers':\n                    self._shared_pointers = False\n                elif elt.id == 'noexcept':\n                    self._noexcept = True\n                elif elt.id == 'unique_ptr':\n                    self._unique_ptr = True\n                elif elt.id == 'stack':\n                    self._memory.append('STACK')\n                elif elt.id == 'heap':\n                    self._memory.append('HEAP')\n\n            r = []\n            for b in node.body:\n                a = self.visit(b)\n                if a: r.append(self.indent()+a)\n\n            for elt in node.context_expr.elts:\n                if elt.id == 'pointers':\n                    self._shared_pointers = True\n                elif elt.id == 'noexcept':\n                    self._noexcept = False\n                elif elt.id == 'unique_ptr':\n                    self._unique_ptr = False\n                elif elt.id == 'stack':\n                    self._memory.pop()\n                elif elt.id == 'heap':\n                    self._memory.pop()\n\n            return '\\n'.join(r)\n\n        else:\n            raise SyntaxError( 'invalid use of with', node.context_expr)\n\n\n        for b in node.body:\n            a = self.visit(b)\n            if a: r.append(self.indent()+a)\n\n        if is_case and not self._rust:  ## always break after each case - do not fallthru to default: block\n            if select_hack or self._go:\n                r.append(self.indent()+' break;}')\n            else:\n                r.append(self.indent()+'} break;')  ## } extra scope\n        ###################################\n\n        if is_extern:\n            r.append(self.indent()+'}')\n\n        elif is_select:\n            if self._cpp:\n                r.append(self.indent()+'_select_.wait();')\n            elif self._rust:\n                r.append(self.indent()+'})')  ## rust needs extra closing brace for the match-block\n            elif self._go:\n                r.append(self.indent()+'}')\n            else:\n                r.append(self.indent()+'break; }')\n\n            self._with_type.pop()\n\n        elif is_switch:\n            if self._rust and not self._cpp:\n                r.append(self.indent()+'}}')  ## rust needs extra closing brace for the match-block\n            else:\n                r.append(self.indent()+'}')\n\n            self._with_type.pop()\n            self._rename_hacks.clear()   ## TODO properly clear\n\n        return '\\n'.join(r)\n\n\n\n\n\nGo hacks\n\n\nTODO clean up.\n\n\n\n    def parse_go_style_arg( self, s ):\n        if isinstance(s, ast.Str): s = s.s\n        return s.split(']')[-1]\n\n    def _visit_call_helper_go(self, node):\n        go_types = 'bool string int float64'.split()\n\n        name = self.visit(node.func)\n        if name == '__go__':\n            if self._cpp:\n                ## simple auto threads\n                thread = '__thread%s__' %len(self._threads)\n                self._threads.append(thread)\n                ## do not capture all variables by reference `\n`,\n                ## because threads spawned in a for loop will all share\n                ## references to loop variants.\n                #closure_wrapper = '[\n]{%s;}'%self.visit(node.args[0])\n                ## TODO: capture by reference list of arrays and objects,\n                ## unknown variables default to copy into thread.\n                closure_wrapper = '[=]{%s;}'%self.visit(node.args[0])\n\n                return 'std::thread %s( %s );' %(thread, closure_wrapper)\n            elif self._rust:\n                return 'thread::spawn( move || {%s;} );' % self.visit(node.args[0])\n            elif self._go:\n                return 'go %s' %self.visit(node.args[0])\n            else:  ## javascript\n                r = self.visit(node.args[0])\n                mode = 'call'\n                fname = self.visit(node.args[0].func)\n                args = [self.visit(a) for a in node.args[0].args]\n                if fname == 'new':\n                    mode = 'new'\n                    fname = self.visit(node.args[0].args[0].func)\n                    args = [self.visit(a) for a in node.args[0].args[0].args]\n                if node.keywords:\n                    if not node.keywords[0].arg=='cpu':\n                        raise SyntaxError('invalid keyword argument to the builtin `spawn`')\n                    cpuid = self.visit(node.keywords[0].value)\n                    return '\u2ca2\u2c91\u2c91\u2c92.spawn({%s:\n%s\n, args:[%s]}, {cpu:%s})' %(mode,fname, ','.join(args), cpuid)\n                else:\n                    return '\u2ca2\u2c91\u2c91\u2c92.spawn({%s:\n%s\n, args:[%s]})' %(mode,fname, ','.join(args))\n\n        elif name == '__go_make__':\n            if len(node.args)==2:\n                return 'make(%s, %s)' %(self.visit(node.args[0]), self.visit(node.args[1]))\n            elif len(node.args)==3:\n                return 'make(%s, %s, %s)' %(self.visit(node.args[0]), self.visit(node.args[1]), self.visit(node.args[1]))\n            else:\n                raise SyntaxError('go make requires 2 or 3 arguments')\n        elif name == '__go_make_chan__':\n            ## channel constructors\n            if self._cpp:\n                ## cpp-channel API supports input/output\n                T = self.visit(node.args[0])\n                if self.is_prim_type(T):\n                    return 'cpp::channel\n%s\n{}'%T\n                else:\n                    return 'cpp::channel\n%s*\n{}'%T\n            elif self._rust:\n                ## rust returns a tuple input/output that needs to be destructured by the caller\n                return 'channel::\n%s\n()' %self.visit(node.args[0])\n            else:  ## Go\n                return 'make(chan %s)' %self.visit(node.args[0])\n\n        elif name == '__go__array__':\n            if isinstance(node.args[0], ast.BinOp):# and node.args[0].op == '\n':  ## todo assert right is `typedef`\n                a = self.visit(node.args[0].left)\n                T = self.visit(node.args[0])\n                if type(T) is tuple:\n                    assert T[1]=='typedef'\n                    T = T[0]\n\n                if self._cpp:\n                    if self._memory[-1]=='STACK':\n                        return 'std::vector\n%s\n' %T\n                    else:\n                        return 'std::shared_ptr\nstd::vector\n%s\n' %T\n                else:\n                    if a in go_types:\n                        if self._go:\n                            return '*[]%s' %a\n                        elif self._rust:\n                            return '\nmut Vec\n%s\n' %a  ## TODO test this\n                        else:\n                            raise RuntimeError('todo')\n                    else:\n                        return '*[]*%s' %a  ## todo - self._catch_assignment_array_of_obs = true\n\n            else:\n                a = self.visit(node.args[0])\n                if a in go_types:\n                    return '[]%s{}' %a\n                else:\n                    return '[]*%s{}' %a\n        elif name == '__go__addr__':\n            return '\n%s' %self.visit(node.args[0])\n        else:\n            raise SyntaxError(name)", 
            "title": "MultiBackendBaseClass"
        }, 
        {
            "location": "/generatorbase/#transpiler-base-class", 
            "text": "shared methods used by most backends are here.\nTODO move  __init__  from jstranslator.md to here.", 
            "title": "Transpiler Base Class"
        }, 
        {
            "location": "/generatorbase/#imports", 
            "text": "@import clikelang.md   \nclass GeneratorBase( CLikeLanguage ):\n\n    def visit_IfExp(self, node):\n        ## ternary operator ##\n        test    = self.visit(node.test)\n        iftrue  = self.visit(node.body)\n        iffalse = self.visit(node.orelse)\n        return '(%s ? %s : %s)' %(test, iftrue, iffalse)\n\n\n    def visit_Expr(self, node):\n        ## note: the javascript backend overloads this ##\n        s = self.visit(node.value)\n        if s is None:\n            raise RuntimeError('GeneratorBase ExpressionError: %s' %node.value)\n        if s.strip() and not s.endswith(';'):\n            s += ';'\n        if s==';': return ''\n        else: return s\n\n    def function_has_getter_or_setter(self, node):\n        options = {'getter':False, 'setter':False}\n        for d in node.decorator_list:\n            self._visit_decorator(d, options=options)\n        return options['getter'] or options['setter']\n\n\n    def visit_Tuple(self, node, force_make_tuple=False):\n        if self._rust:\n            return 'vec!(%s)' % ', '.join(map(self.visit, node.elts))\n        elif self._cpp:\n            if len(self._stack)  = 2 and isinstance(self._stack[-2], ast.Call) or force_make_tuple:\n                if isinstance(self._stack[-2].func, ast.Name) and self._stack[-2].func.id=='__array__':  ## special case\n                    return '{%s}' %','.join(map(self.visit, node.elts))\n                else:\n                    tupletype, tupleinit = self.make_tuple(node.elts)\n                    if self._memory[-1]=='STACK':\n                        return 'std::make_tuple(%s)' %','.join(tupleinit)\n                    else:\n                        #declargs = ['decltype(%s)'%self.visit(da) for da in node.elts]\n                        return 'std::make_shared std::tuple %s (std::make_tuple(%s))' %(','.join(tupletype), ','.join(tupleinit))\n            else:\n                return '{%s}' %','.join(map(self.visit, node.elts))\n        else:\n            return '[%s]' % ', '.join(map(self.visit, node.elts))\n\n    def visit_List(self, node):\n        a = []\n        for elt in node.elts:\n            b = self.visit(elt)\n            if b is None: raise SyntaxError( self.format_error(elt) )\n            a.append( b )\n        return '[%s]' % ', '.join(a)\n\n    def visit_Subscript(self, node):\n        if isinstance(node.slice, ast.Ellipsis):\n            return self._visit_subscript_ellipsis( node )\n        else:\n            return '%s[%s]' % (self.visit(node.value), self.visit(node.slice))\n\n    def visit_Index(self, node):\n        return self.visit(node.value)\n\n    def _visit_call_helper_instanceof(self, node):\n        args = map(self.visit, node.args)\n        if len(args) == 2:\n            return '%s instanceof %s' %tuple(args)\n        else:\n            raise SyntaxError( args )\n\n    def _visit_call_helper_new(self, node):\n        args = map(self.visit, node.args)\n        if len(args) == 1:\n            return ' new %s' %args[0]\n        else:\n            raise SyntaxError( args )\n\n    def _visit_call_special( self, node ):\n        raise NotImplementedError('special call')", 
            "title": "Imports"
        }, 
        {
            "location": "/generatorbase/#call-functionmethod", 
            "text": "The backends subclass _visit_call_helper, which gets called here after doing some bookeeping like\ntracking what function names have been called, so backends can check  self._called_funtions  and\ndo extra things like inline extra helper code for things like  hasattr , etc.  \n    def visit_Call(self, node):\n        name = self.visit(node.func)\n        if name not in self._called_functions:\n            self._called_functions[name] = 0\n        self._called_functions[name] += 1\n\n        if name in typedpython.GO_SPECIAL_CALLS.values():\n            return self._visit_call_helper_go( node )\n\n        elif name in self.catch_call:\n            return self._visit_call_special( node )\n\n        elif name == 'instanceof':  ## it is safer to use the builtin `isinstance`\n            return self._visit_call_helper_instanceof( node )\n\n        elif name == 'new':\n            return self._visit_call_helper_new( node )\n\n        elif name == '__ternary_operator__':\n            args = map(self.visit, node.args)\n            if len(args) == 2:\n                return '((%s) ? %s : %s)' %(args[0], args[0], args[1])\n            elif len(args) == 3:\n                return '((%s) ? %s : %s)' %(args[0], args[1], args[2])\n            else:\n                raise SyntaxError( args )\n\n        elif name == 'numpy.array':\n            return self._visit_call_helper_numpy_array(node)\n\n        elif name == 'JSObject':\n            return self._visit_call_helper_JSObject( node )\n\n        elif name == 'var':\n            return self._visit_call_helper_var( node )\n\n        elif name == 'JSArray':\n            return self._visit_call_helper_JSArray( node )\n\n        elif name == 'inline' or name == 'JS':\n            assert len(node.args)==1 and isinstance(node.args[0], ast.Str)\n            return self._inline_code_helper( node.args[0].s )\n\n        elif name == 'list':\n            return self._visit_call_helper_list( node )\n\n        elif name == '__get__' and len(node.args)==2 and isinstance(node.args[1], ast.Str) and node.args[1].s=='__call__':\n            raise SyntaxError('deprecated')\n            return self._visit_call_helper_get_call_special( node )\n\n        elif name.split('.')[-1] == '__go__receive__':\n            raise SyntaxError('this should not happen __go__receive__')\n\n        else:\n            return self._visit_call_helper(node)", 
            "title": "Call Function/Method"
        }, 
        {
            "location": "/generatorbase/#import-import-x-and-from-x-import-y", 
            "text": "def _importfrom_helper(self, node):\n        return ''\n\n    def visit_ImportFrom(self, node):\n        # print node.module\n        # print node.names[0].name\n        # print node.level\n        if self._rust:\n            crate = self._crates[node.module]\n            for alias in node.names:\n                crate.add( alias.name )\n        if node.module=='runtime':\n            self._insert_runtime = True\n        else:\n            return self._importfrom_helper(node)\n\n        return ''\n\n    def visit_Import(self, node):\n        r = [alias.name.replace('__SLASH__', '/') for alias in node.names]\n        res = []\n        if r:\n            for name in r:\n                if self._rust:  ## TODO move this to rusttranslator.md\n                    if name not in self._crates:\n                        self._crates[name] = set()\n                else:\n                    raise SyntaxError('import not yet support for this backend')\n\n        if res:\n            return '\\n'.join(res)\n        else:\n            return ''", 
            "title": "Import import x and from x import y"
        }, 
        {
            "location": "/generatorbase/#is_prim_type", 
            "text": "the typed backends like: go, rust and c++ need to know if a variable type is a builtin primitive,\nor something that needs to be wrapped by a pointer/shared-reference.  \n    def is_prim_type(self, T):\n        prims = 'auto void bool unsigned int float double long string str char byte u32 u64 i32 i64 f32 f64 float32 float64 std::string cstring'.split()\n        if hasattr(self, '_typedefs'):\n            prims.extend( self._typedefs.keys() )\n\n        if self._go:\n            prims.append( 'interface{}' )\n        if T in prims:\n            return True\n        elif T.endswith(']'):  ## c-style array\n            return True\n        else:\n            return False\n\n    def indent(self): return '\\t' * self._indent\n    def push(self): self._indent += 1\n    def pull(self):\n        if self._indent   0: self._indent -= 1", 
            "title": "is_prim_type"
        }, 
        {
            "location": "/generatorbase/#function-decorators", 
            "text": "_visit_decorator  is called by the other backends, the shared decorator logic is here.  \n    def _visit_decorator(self, decor, node=None, options=None, args_typedefs=None, chan_args_typedefs=None, generics=None, args_generics=None, func_pointers=None, arrays=None, args_super_classes=None ):\n        assert node\n        if options is None: options = dict()\n        if args_typedefs is None: args_typedefs = dict()\n        if chan_args_typedefs is None: chan_args_typedefs = dict()\n        if generics is None: generics = set()\n        if args_generics is None: args_generics = dict()\n        if func_pointers is None: func_pointers = set()\n        if arrays is None: arrays = dict()\n        if args_super_classes is None: args_super_classes = dict()\n\n        if isinstance(decor, ast.Name) and decor.id == 'classmethod':\n            options['classmethod'] = True\n\n        elif isinstance(decor, ast.Name) and decor.id == 'property':\n            ## a function is marked as a getter with `@property`\n            options['getter'] = True\n        elif isinstance(decor, ast.Attribute) and isinstance(decor.value, ast.Name) and decor.attr == 'setter':\n            ## a function is marked as a setter with `@name.setter`\n            options['setter'] = True\n\n        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef__':\n            if len(decor.args) == 3:\n                vname = self.visit(decor.args[0])\n                if isinstance(decor.args[1], ast.Str):\n                    vtype = decor.args[1].s\n                else:\n                    vtype = self.visit(decor.args[1])\n                vptr = decor.args[2].s\n\n                ## note: the space is required because it could be `mut` rust-keyword, or `struct` C type.\n                args_typedefs[ vname ] = '%s %s' %(vptr, vtype)\n\n            else:\n                args_user_classes = {}\n                for key in decor.keywords:\n                    args_user_classes[key.arg] = None\n\n                    if isinstance( key.value, ast.Str):\n                        args_typedefs[ key.arg ] = key.value.s\n                        if key.value.s in self._classes:  ## TODO check if endswith *\n                            args_user_classes[key.arg] = key.value.s\n                        elif key.value.s.startswith('['):\n                            n,T = key.value.s.split(']')\n                            n += ']'\n                            args_typedefs[key.arg]=T+n\n\n                    elif isinstance(key.value, ast.Name):\n                        T = key.value.id\n                        if T in self._classes:\n                            args_user_classes[key.arg] = T\n\n                        if self.is_prim_type(T) or self._memory[-1]=='STACK':\n                            args_typedefs[key.arg] = T\n                        elif self._cpp:\n                            if self.usertypes and 'shared' in self.usertypes:\n                                args_typedefs[ key.arg ] = self.usertypes['shared']['template'] %T\n                            elif not self._shared_pointers:\n                                args_typedefs[ key.arg ] = '%s*' %T\n                            elif self._unique_ptr:\n                                args_typedefs[ key.arg ] = 'std::unique_ptr %s ' %T\n                            else:\n                                assert self._memory[-1]=='HEAP'\n                                args_typedefs[ key.arg ] = 'std::shared_ptr %s ' %T\n\n                        else:  ## javascript runtime checked types\n                            args_typedefs[key.arg] = T\n\n                    else:\n                        if isinstance(key.value, ast.Call) and isinstance(key.value.func, ast.Name) and key.value.func.id=='__arg_array__':\n                            arrays[ key.arg ] = key.value.args[0].s\n                            dims = arrays[ key.arg ].count('[')\n                            arrtype = arrays[ key.arg ].split(']')[-1]\n\n                            if self._rust:\n                                if not self.is_prim_type(arrtype):\n                                    arrtype = 'Rc RefCell %s ' %arrtype\n\n                                args_typedefs[ key.arg ] = 'Rc RefCell Vec %s ' %arrtype\n\n                            elif self._cpp:\n                                ## non primitive types (objects and arrays) can be None, `[]MyClass( None, None)`\n                                ## use a pointer or smart pointer. \n                                if not self.is_prim_type(arrtype) and self._memory[-1]=='HEAP':\n                                    if not self._shared_pointers:\n                                        arrtype += '*'\n                                    elif self.usertypes and 'shared' in self.usertypes:\n                                        arrtype = self.usertypes['shared']['template'] % arrtype\n                                    elif self._unique_ptr:\n                                        arrtype = 'std::unique_ptr %s ' %arrtype\n                                    else:\n                                        arrtype = 'std::shared_ptr %s ' %arrtype\n\n\n                                T = []\n\n                                for i in range(dims):\n                                    if not self._shared_pointers or self._memory[-1]=='STACK':\n                                        T.append('std::vector ')\n                                    elif self.usertypes and 'vector' in self.usertypes:\n                                        sptr = self.usertypes['shared']['type']\n                                        vptr = self.usertypes['vector']['template'].split( %s )[0]\n                                        T.append('%s%s' %(sptr, vptr))                                  \n                                    elif self._unique_ptr:\n                                        T.append('std::unique_ptr std::vector ')\n                                    else:\n                                        T.append('std::shared_ptr std::vector ')\n                                T.append( arrtype )\n\n                                if self._memory[-1]=='STACK':\n                                    for i in range(dims):\n                                        #if i: T.append('* ')\n                                        #else: T.append(' ')\n                                        T.append(' ')\n                                    T.append('*')\n\n                                elif self._shared_pointers or 'vector' in self.usertypes:\n                                    for i in range(dims):\n                                        T.append(' ')\n                                else:\n                                    for i in range(dims):\n                                        if i: T.append('* ')\n                                        else: T.append(' ')\n                                    T.append('*')\n\n                                args_typedefs[ key.arg ] = ''.join(T)\n\n                            else:  ## javascript backend\n                                args_typedefs[ key.arg ] = key.value.args[0].s\n\n                        else:\n                            args_typedefs[ key.arg ] = self.visit(key.value)\n\n                    if args_typedefs[key.arg].startswith('func(') or args_typedefs[key.arg].startswith('lambda('):\n                        is_lambda_style = args_typedefs[key.arg].startswith('lambda(')\n                        func_pointers.add( key.arg )\n                        funcdef = args_typedefs[key.arg]\n                        ## TODO - better parser\n                        hack = funcdef.replace(')', '(').split('(')\n                        lambda_args = []\n                        TODO_REPLACE_PIPE_HACK = '|'  ## note new syntax is space separated\n                        for larg in hack[1].strip().split(TODO_REPLACE_PIPE_HACK):\n                            if self.is_prim_type(larg):\n                                lambda_args.append(larg)\n                            elif not larg:\n                                lambda_args.append('void')\n                            else:\n                                lambda_args.append('std::shared_ptr %s '%larg)\n\n                        lambda_args = ','.join(lambda_args)\n                        lambda_return = hack[3].strip()\n                        if not lambda_return: lambda_return = 'void'\n                        if not self.is_prim_type(lambda_return):\n                            lambda_return = 'std::shared_ptr %s '%lambda_return\n\n                        if self._cpp:\n                            if is_lambda_style:\n                                if lambda_return:  ## c++11\n                                    args_typedefs[ key.arg ] = 'std::function %s(%s)   %s' %(lambda_return, lambda_args, key.arg)\n                                else:\n                                    args_typedefs[ key.arg ] = 'std::function void(%s)   %s' %(lambda_args, key.arg)\n\n                            else:  ## old C style function pointers\n                                if lambda_return:\n                                    args_typedefs[ key.arg ] = '%s(*%s)(%s)' %(lambda_return, key.arg, lambda_args)\n                                else:\n                                    args_typedefs[ key.arg ] = 'void(*%s)(%s)' %(key.arg, lambda_args)\n\n                        elif self._rust:\n                            if lambda_return:\n                                args_typedefs[ key.arg ] = '|%s|- %s' %(lambda_args, lambda_return)\n                            else:\n                                args_typedefs[ key.arg ] = '|%s|' %lambda_args\n\n                        elif self._dart:\n                            args_typedefs[ key.arg ] = 'var'\n\n                    ## check for super classes - generics ##\n                    ## this was originally for the Go backend, still used in the c++ or rust backends?\n                    #if (self._go or self._cpp or self._rust) and args_typedefs[ key.arg ] in self._classes:\n                    if (self._go or self._cpp or self._rust) and args_user_classes[ key.arg ]:\n                        classname = args_user_classes[ key.arg ]\n                        options['generic_base_class'] = classname\n\n                        if self._cpp:\n                            #if self._memory[-1]=='STACK':\n                            #   #args_typedefs[key.arg] = 'const %s' %classname\n                            #   pass\n                            #elif not self._shared_pointers:\n                            #   args_typedefs[ key.arg ] = '%s*' %classname\n                            #elif self.usertypes and 'shared' in self.usertypes:\n                            #   args_typedefs[ key.arg ] = self.usertypes['shared']['template'] % classname\n                            #elif self._unique_ptr:\n                            #   args_typedefs[ key.arg ] = 'std::unique_ptr %s ' %classname\n                            #else:\n                            #   args_typedefs[ key.arg ] = 'std::shared_ptr %s ' %classname\n                            #args_generics[ key.arg ] = classname\n\n                            #for subclass in self._classes[classname]._subclasses:\n                            #   generics.add( subclass )\n\n                            cnode = self._classes[classname]\n                            if cnode._parents:\n                                args_super_classes[key.arg] = []\n                                for base in cnode._parents:\n                                    args_super_classes[key.arg].append(base)\n\n                        elif self._rust:\n                            args_typedefs[ key.arg ] = 'Rc RefCell %s ' %classname\n\n                        elif self._go:  ## TODO test if this is still working in the Go backend\n                            if node.name=='__init__':\n                                ## generics type switch is not possible in __init__ because\n                                ## it is used to generate the type struct, where types are static.\n                                ## as a workaround generics passed to init always become `interface{}`\n                                args_typedefs[ key.arg ] = 'interface{}'\n                                #self._class_stack[-1]._struct_def[ key.arg ] = 'interface{}'\n                            else:\n                                generics.add( classname ) # switch v.(type) for each\n                                generics = generics.union( self._classes[classname]._subclasses )  ## TODO\n                                args_typedefs[ key.arg ] = 'interface{}'\n                                args_generics[ key.arg ] = classname\n\n        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef_chan__':\n            for key in decor.keywords:\n                if isinstance(key.value, ast.Str):\n                    chan_args_typedefs[ key.arg ] = key.value.s.strip()\n                else:\n                    chan_args_typedefs[ key.arg ] = self.visit(key.value)\n        elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'returns':\n            if decor.keywords:\n                raise SyntaxError('invalid go return type')\n            elif isinstance(decor.args[0], ast.Name):\n                options['returns'] = decor.args[0].id\n            else:\n                options['returns'] = decor.args[0].s\n\n            if options['returns'].startswith('[]'):\n                options['returns_array'] = True\n                options['returns_array_dim'] = options['returns'].count('[]')\n\n                vectype = options['returns'].split(']')[-1]\n                if self._cpp and vectype.startswith('tuple(') and vectype.endswith(')'):\n                    tupletypes = vectype[ len('tuple(') : -1 ].split(',')\n                    vectype = 'std::tuple %s ' %','.join(tupletypes)\n                    if self._memory[-1]=='HEAP':\n                        vectype = 'std::shared_ptr %s ' %vectype\n                options['returns_array_type'] = vectype\n\n                if self._cpp:\n                    if options['returns_array_type']=='string':\n                        options['returns_array_type'] = 'std::string'\n\n                    T = []\n                    for i in range(options['returns_array_dim']):\n                        if not self._shared_pointers or self._memory[-1]=='STACK':\n                            T.append('std::vector ')\n                        elif self._unique_ptr:\n                            T.append('std::unique_ptr std::vector ')\n                        else:\n                            T.append('std::shared_ptr std::vector ')\n\n                    T.append(options['returns_array_type'])\n\n                    if self._memory[-1]=='STACK':\n                        for i in range(options['returns_array_dim']):\n                            T.append(' ')\n                        #T.append('*')  ## return copy\n                    elif self._shared_pointers and self._memory[-1]=='HEAP':\n                        for i in range(options['returns_array_dim']):\n                            T.append(' ')\n                    else:\n                        for i in range(options['returns_array_dim']):\n                            if i: T.append('* ')\n                            else: T.append(' ')\n                        T.append('*')\n                    options['returns'] = ''.join(T)\n                elif self._rust:\n                    raise SyntaxError('TODO return 2d array rust backend')\n                else:\n                    raise SyntaxError('TODO return 2d array some backend')\n\n            if options['returns'] == 'self' and len(self._class_stack):\n                options['returns_self'] = True\n                self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n\n                if self._go:\n                    options['returns'] = '*' + self._class_stack[-1].name  ## go hacked generics", 
            "title": "Function Decorators"
        }, 
        {
            "location": "/generatorbase/#function", 
            "text": "calls  _visit_function  which is subclassed by other backends.  \n    def visit_FunctionDef(self, node):\n        self._function_stack.append( node )\n        node._local_vars = set()\n        buffer = self._visit_function( node )\n\n        if node == self._function_stack[0]:  ## global function\n            self._global_functions[ node.name ] = node\n\n        self._function_stack.pop()\n        return buffer", 
            "title": "Function"
        }, 
        {
            "location": "/generatorbase/#with", 
            "text": "Special syntax that triggers different things depending on the backend.\nAlso implements extra syntax like  switch  and  select .  \n    def visit_With(self, node):\n        r = []\n        is_select = False\n        is_switch = False\n        is_switch_type = False\n        is_match  = False\n        is_case   = False\n        is_extern = False\n        has_default = False\n        withvalue = self.visit(node.context_expr)\n        if withvalue.startswith('return_'):\n            ## STACK MODE ##\n            ## all variables must be on or moved onto stack for these operations.\n            ## see also: \n            ##      `repeat(...):`\n            ##      `return foo() and then(capture=[], ...):`\n\n            self._memory.append('STACK')\n            has_then = False\n            if 'then(' in withvalue:\n                has_then = withvalue.split('.then(')[-1].split(')')[0]\n\n            rcall = withvalue.split('return_')[-1].split('(')[0].split()[0]\n            rargs = withvalue.split('(')[1].split(')')[0].split(',')\n            if rcall=='do_with':\n                cargs = ','.join('auto  %s'%ra.strip() for ra in rargs)\n                rargs = ','.join('std::move(%s)'%ra.strip() for ra in rargs)\n                body = ['return do_with(%s, [] (%s) {' %(rargs, cargs)]\n            else:\n                rargs = ','.join(' '+ra.strip() for ra in rargs)\n                body = ['return %s([%s] {' %(rcall, rargs)]\n\n            self.push()\n            for b in node.body:\n                body.append(self.indent()+self.visit(b))\n            self.pull()\n\n            if has_then:\n                #if rcall=='repeat':\n                #   raise RuntimeError(withvalue+':'+rargs+':'+has_then)\n                body.append(self.indent()+'}).then(%s);' %has_then)\n            else:\n                body.append(self.indent()+'});')\n\n            self._memory.pop()\n            return '\\n'.join(body)\n\n        elif isinstance(node.context_expr, ast.Name) and node.context_expr.id in ('oo', 'operator_overloading'):\n            self._with_oo = True\n            body = []\n            for b in node.body: body.append(self.visit(b))\n            self._with_oo = False\n            return '\\n'.join(body)\n\n        elif isinstance( node.context_expr, ast.Name ) and node.context_expr.id == '__default__':\n            has_default = True\n            if self._rust and not self._cpp:\n                r.append(self.indent()+'}, _ =  {')\n            else:\n                r.append(self.indent()+'default:')\n\n        elif isinstance( node.context_expr, ast.Name ) and node.context_expr.id == '__select__':\n            is_select = True\n            self._match_stack.append( list() )\n            self._in_select_hack = True\n            self._with_type.append('SELECT')\n\n            if self._rust:\n                r.append(self.indent()+'select! (')\n            elif self._cpp:\n                r.append(self.indent()+'cpp::select _select_;')  ## TODO nested, _select_N\n            elif self._go:\n                r.append(self.indent()+'select {')\n            else:  ## javascript\n                r.append('while (true) {        /* select loop */')\n\n\n        elif isinstance( node.context_expr, ast.Call ):\n            if not isinstance(node.context_expr.func, ast.Name):\n                raise SyntaxError( self.visit(node.context_expr))\n\n            #if len(node.context_expr.args):  ## what was this used for?\n            #   a = self.visit(node.context_expr.args[0])\n            #else:\n            #   assert len(node.context_expr.keywords)\n            #   ## need to catch if this is a new variable ##\n            #   name = node.context_expr.keywords[0].arg\n            #   if name not in self._known_vars:\n            #       a = 'let %s = %s' %(name, self.visit(node.context_expr.keywords[0].value))\n            #   else:\n            #       a = '%s = %s' %(name, self.visit(node.context_expr.keywords[0].value))\n\n            if node.context_expr.func.id == 'chain_then':\n                self._lambda_stack[-1].chain_then.append(node)\n                #self.chain_then.append(node)\n                return ''\n            elif node.context_expr.func.id == '__case__':\n                is_case = True\n                case_match = None\n                select_hack = None\n                if not len(node.context_expr.args):\n                    assert len(node.context_expr.keywords)==1\n                    kw = node.context_expr.keywords[0]\n                    if self._go:\n                        case_match = '%s := %s' %(kw.arg, self.visit(kw.value))\n                    elif hasattr(self, '_in_select_hack') and self._in_select_hack:\n                        select_hack = True\n                        if self._cpp:\n                            case_match = '_select_.recv(%s, %s);' %(self.visit(kw.value), kw.arg)                       \n\n                        else:  ## javascript backend ##\n                            #self.visit(kw.value) ## TODO allow worker returned from some call\n                            cid = kw.value.right.id\n                            case_match = 'if (\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8c\ud835\udc86\ud835\udc93\ud835\udc77\ud835\udc90\ud835\udc90\ud835\udc8d.select(%s).length) {var %s = \ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8c\ud835\udc86\ud835\udc93\ud835\udc77\ud835\udc90\ud835\udc90\ud835\udc8d.select(%s).pop();' %(cid, kw.arg, cid)\n                    elif is_switch_type:\n                        raise SyntaxError('invalid switch type')\n                    else:\n                        case_match = '%s = %s' %(kw.arg, self.visit(kw.value))\n                else:\n                    if isinstance(node.context_expr.args[0], ast.Compare):\n                        raise SyntaxError(' case x==n:  is not allowed in a case statement, use  case n:  instead.')\n                    case_match = self.visit(node.context_expr.args[0])\n\n                if select_hack:\n                    r.append(self.indent()+case_match)\n                elif self._rust and not self._cpp:\n                    if len(self._match_stack[-1])==0:\n                        r.append(self.indent()+'%s =  {' %case_match)\n                    else:\n                        r.append(self.indent()+'}, %s =  { ' %case_match )\n                else:\n                    if self._with_type[-1]=='SWITCH_TYPE':\n                        T = case_match\n                        o = self._switch_on_type_object[-1]\n                        classid = self._classes.keys().index(T)\n                        r.append(self.indent()+'case %s: {' %classid) ## extra scope\n                        r.append(self.indent()+'    auto _cast_%s = std::static_pointer_cast %s (%s);' %(o, T, o))\n                        case_match = ' %s ' %case_match\n                    else:\n                        r.append(self.indent()+'case %s: {' %case_match) ## extra scope\n\n                if not len(self._match_stack):\n                    raise SyntaxError('case statement used outside of a select or switch block')\n\n                self._match_stack[-1].append(case_match)\n\n\n            elif node.context_expr.func.id == '__switch__':\n                is_switch = True\n                self._match_stack.append( list() )\n\n                if self._rust and not self._cpp:\n                    r.append(self.indent()+'match (%s) {' %self.visit(node.context_expr.args[0]))\n                    is_match = True\n                else:\n                    switch_value = self.visit(node.context_expr.args[0])\n                    if switch_value.startswith('type(') and switch_value.endswith(')'):\n                        is_switch_type = True\n                        switch_object = switch_value[ len('type(') : -1 ].strip()\n                        self._rename_hacks[switch_object] = '_cast_' + switch_object\n                        self._switch_on_type_object.append(switch_object)\n                        switch_value = switch_object + '- __classid__'\n                    r.append(self.indent()+'switch (%s) {' %switch_value)\n\n                if is_switch_type:\n                    self._with_type.append('SWITCH_TYPE')\n                elif is_match:\n                    self._with_type.append('SWITCH_MATCH')\n                else:\n                    self._with_type.append('SWITCH')\n\n\n            elif node.context_expr.func.id == 'extern':\n                is_extern = True\n                link = None\n                for kw in node.context_expr.keywords:\n                    if kw.arg=='link':\n                        link = kw.value.s\n                if self._cpp:\n                    r.append('extern  C  {')  ## TODO other abis\n                elif self._rust:\n                    assert link\n                    r.append('#[link(name =  %s )]' %link)\n                    r.append('extern {')\n\n                else:\n                    raise SyntaxError('with extern: not supported yet for backend')\n\n                ## strip the bodies from function defs, that should be just defined as `def f(args):pass`\n                for b in node.body:\n                    if isinstance(b, ast.FunctionDef):\n                        if b.body and len(b.body)  = 2 and isinstance(b.body[-1], ast.Pass):\n                            b.body = []\n                            b.declare_only = True\n\n            elif node.context_expr.func.id == 'syntax':\n                assert len(node.context_expr.args)==1\n                keys = []\n                if isinstance(node.context_expr.args[0], ast.Dict):\n                    #self.usertypes = {'string':None}  ## force plain strings\n                    cfg = eval(self.visit(node.context_expr.args[0]))\n                    keys.extend( cfg.keys() )\n                    self.usertypes.update( cfg )\n                else:\n                    assert isinstance(node.context_expr.args[0], ast.Str)\n                    jsonfile = node.context_expr.args[0].s\n                    if jsonfile in self.cached_json_files:\n                        jdata = self.cached_json_files[jsonfile]\n                        cfg   = json.loads( jdata )\n                        keys.extend( cfg.keys() )\n                        self.usertypes.update( cfg )\n                    elif os.path.isfile(jsonfile):\n                        cfg   = json.load(jsonfile)\n                        keys.extend( cfg.keys() )\n                        self.usertypes.update( cfg )\n                    else:\n                        raise RuntimeError('can not load custom types json: %s' %jsonfile)\n\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n\n                #self.usertypes = None  ## restore default types\n                for k in keys:\n                    if k in self.usertypes:\n                        self.usertypes.pop(k)\n\n                return '\\n'.join(r)\n\n            elif node.context_expr.func.id == 'timeout':\n                assert len(node.context_expr.args)==1\n                self._timeout = self.visit(node.context_expr.args[0])\n\n                r = [\n                    'var __clk__ = (new Date()).getTime();',\n                    'while (true) {     /* timeout: %s */' %self._timeout,\n                ]\n                self._in_timeout = True\n                for b in node.body:\n                    a = self.visit(b)\n                    if a:\n                        r.append(self.indent()+a)\n                        if b is node.body[-1]:\n                            break\n                        if '(' in a and ')' in a:\n                            r.append(\n                                self.indent()+'if ( (new Date()).getTime() - __clk__  = %s )  { break;}' % self._timeout\n                            )\n                r.append('break; }')\n                self._in_timeout = False\n                return '\\n'.join(r)\n\n            elif node.context_expr.func.id == 'macro':\n                assert len(node.context_expr.args)==1\n                cppmacro = node.context_expr.args[0].s\n                r = [cppmacro + '{']\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                r.append(self.indent()+'}')\n                return '\\n'.join(r)\n\n            else:\n                raise SyntaxError( 'invalid use of with: %s' %node.context_expr)\n\n        elif isinstance(node.context_expr, ast.Str):\n            if self._cpp:\n                body = ['namespace %s {' %node.context_expr.s]\n                self.push()\n                for b in node.body:\n                    body.append(self.visit(b))\n                self.pull()\n                body.append('}')\n                return  '\\n'.join(body)\n\n            else:\n                raise RuntimeError('TODO namespace for some backend')\n\n        elif isinstance(node.context_expr, ast.Name) and node.optional_vars:\n            assert isinstance(node.optional_vars, ast.Subscript)\n            assert isinstance(node.optional_vars.slice, ast.Index)\n            assert node.optional_vars.slice.value.id == 'MACRO'\n            assert isinstance(node.optional_vars.value, ast.Str)\n            if self._cpp:\n                macro_string = self.visit_Str(node.optional_vars.value, wrap=False)\n            else:\n                macro_string = self.visit(node.optional_vars.value)[1:-1]\n\n            macro_string = macro_string.replace('\\\\ ', ' ')\n\n            if macro_string.startswith(' '):\n                raise SyntaxError('bad macro: ' + macro_string)\n\n            macro_name   = self.visit(node.context_expr)\n            self.macros[ macro_name ] = macro_string  ## set macro\n            r = []\n            for b in node.body:\n                a = self.visit(b)\n                if a:\n                    if len(r): r.append(self.indent()+a)\n                    else: r.append(a)\n\n            self.macros.pop( macro_name )  ## remove macro\n            return '\\n'.join(r)\n\n        elif isinstance(node.context_expr, ast.Name):\n            if node.context_expr.id == 'typedef':\n                r = []\n                for b in node.body:\n                    assert isinstance(b, ast.Assign)\n                    tdef  = self.visit(b.value)\n                    tname = self.visit(b.targets[0])\n                    self._typedefs[tname] = tdef\n                    if isinstance(tdef, tuple):\n                        self._typedefs[tname] = tdef[0]\n                        if tdef[0]=='std::vector tuple ':\n                            if self._memory[-1]=='STACK':\n                                tdef = 'std::vector std::tuple %s ' %','.join(tdef[1])\n                            else:\n                                tdef = 'std::shared_ptr  std::vector std::shared_ptr std::tuple %s   ' %','.join(tdef[1])\n                        else:\n                            ## ignore constructor part `foo = []bar()` ##\n                            if self._memory[-1]=='STACK':\n                                tdef = tdef[0]\n                            else:\n                                tdef = 'std::shared_ptr %s ' %tdef[0]\n                    elif tdef.startswith('tuple('):\n                        if self._memory[-1]=='STACK':\n                            tdef = 'std::tuple %s ' %','.join([self.visit(t) for t in b.value.args])\n                        else:\n                            tdef = 'std::shared_ptr std::tuple %s ' %','.join([self.visit(t) for t in b.value.args])\n\n                    r.append('typedef %s %s;' %(tdef, tname))\n                return '\\n'.join(r)\n\n            elif node.context_expr.id == 'constant':\n                self._in_constant = True\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a:\n                        if isinstance(b, ast.Assign) and '=' in a:\n                            a = 'const ' + a\n                        r.append(self.indent()+a)\n                self._in_constant = False\n                return '\\n'.join(r)\n\n            elif node.context_expr.id in ('atomic', 'relaxed', 'transaction'):\n                self._has_gnu_stm = True\n                r = []\n                if node.context_expr.id=='atomic':\n                    r.append('__transaction_atomic {')\n                else:\n                    r.append('__transaction_relaxed {')  ## slightly slower\n\n                self.push()\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self.pull()\n                r.append(self.indent()+'}')\n                return '\\n'.join(r)\n\n            elif node.context_expr.id == 'stack':\n                self._memory.append('STACK')\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._memory.pop()\n                return '\\n'.join(r)\n            elif node.context_expr.id == 'heap':\n                self._memory.append('HEAP')\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._memory.pop()\n                return '\\n'.join(r)\n\n            elif node.context_expr.id == 'unique_ptr':\n                self._unique_ptr = True\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._unique_ptr = False\n                return '\\n'.join(r)\n            elif node.context_expr.id == 'pointers':\n                self._shared_pointers = False\n                r = []\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                self._shared_pointers = True\n                return '\\n'.join(r)\n            elif node.context_expr.id == 'gil':\n                r = ['auto __gstate__ = PyGILState_Ensure();']\n                for b in node.body:\n                    a = self.visit(b)\n                    if a: r.append(self.indent()+a)\n                r.append('PyGILState_Release(__gstate__);')\n                return '\\n'.join(r)\n\n            else:\n                raise RuntimeError('TODO with syntax:%s'%node.context_expr.id)\n\n        elif isinstance(node.context_expr, ast.List) and node.optional_vars and self.visit(node.optional_vars)=='future':\n            assert self._memory[-1]=='STACK'\n            self._lambda_stack.append( node )\n            node.chain_then = []\n\n            r = []\n            fut = self.visit(node.context_expr.elts[0])\n            #then_cap = self.visit(node.context_expr.elts[1].keywords[0])[ 1 ]  ## TODO more `and then(..)` chains\n            then_cap = ''\n            then_fut = ''\n            then_callback = None\n\n            if len(node.context_expr.elts[1].keywords):\n                if node.context_expr.elts[1].keywords[0].arg == 'callback':\n                    then_callback = self.visit(node.context_expr.elts[1].keywords[0].value)\n                elif node.context_expr.elts[1].keywords[0].arg == 'capture':\n\n                    then_cap = node.context_expr.elts[1].keywords[0].value\n                    then_cap = [' '+self.visit(a) for a in then_cap.elts ]\n\n\n                    assert node.context_expr.elts[1].keywords[1].arg == 'future'\n                    then_fut = node.context_expr.elts[1].keywords[1].value\n                    then_fut = ['auto '+self.visit(a) for a in then_fut.elts ]\n                else:\n                    raise SyntaxError('invalid use of then() keyword option')\n\n\n            if fut.startswith('return_'):\n                fut = fut[len('return_'):]\n\n                if then_callback or fut.startswith('repeat('):\n                    r.append(\n                        'return %s([ ] {' %fut.split('(')[0]\n                    )\n                else:\n                    r.append(\n                        'return %s.then([%s] (%s){' % (fut, ','.join(then_cap), ','.join(then_fut) )\n                    )\n            else:\n                #raise RuntimeError('TODO `continue foo() and then:`')\n\n                if then_callback or fut.startswith('repeat('):\n                    r.append(\n                        '%s([ ] {' %fut.split('(')[0]\n                    )\n                else:\n                    r.append(\n                        '%s.then([%s] (%s){' % (fut, ','.join(then_cap), ','.join(then_fut) )\n                    )\n\n\n            self.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: r.append(self.indent()+a)\n            self.pull()\n\n            if then_callback:\n                r.append(self.indent()+'}).then(%s)' %then_callback)\n            else:\n                r.append(self.indent()+'})')  ## note closes: lambda{, then(, return;\n\n            if len(self._lambda_stack):\n                chain_then = self._lambda_stack[-1].chain_then\n                if chain_then:\n                    chain_then.reverse()\n                    while chain_then:\n                        n = chain_then.pop()\n                        r[-1] += '.then([]() {'\n                        self.push()\n                        for b in n.body:\n                            a = self.visit(b)\n                            if a: r.append(self.indent()+a)\n                        self.pull()\n                        r.append(self.indent()+'})')\n\n            r[-1] += ';'\n            self._lambda_stack.pop()\n\n            return '\\n'.join(r)\n\n        elif isinstance(node.context_expr, ast.Tuple) or isinstance(node.context_expr, ast.List):\n            for elt in node.context_expr.elts:\n                if elt.id == 'pointers':\n                    self._shared_pointers = False\n                elif elt.id == 'noexcept':\n                    self._noexcept = True\n                elif elt.id == 'unique_ptr':\n                    self._unique_ptr = True\n                elif elt.id == 'stack':\n                    self._memory.append('STACK')\n                elif elt.id == 'heap':\n                    self._memory.append('HEAP')\n\n            r = []\n            for b in node.body:\n                a = self.visit(b)\n                if a: r.append(self.indent()+a)\n\n            for elt in node.context_expr.elts:\n                if elt.id == 'pointers':\n                    self._shared_pointers = True\n                elif elt.id == 'noexcept':\n                    self._noexcept = False\n                elif elt.id == 'unique_ptr':\n                    self._unique_ptr = False\n                elif elt.id == 'stack':\n                    self._memory.pop()\n                elif elt.id == 'heap':\n                    self._memory.pop()\n\n            return '\\n'.join(r)\n\n        else:\n            raise SyntaxError( 'invalid use of with', node.context_expr)\n\n\n        for b in node.body:\n            a = self.visit(b)\n            if a: r.append(self.indent()+a)\n\n        if is_case and not self._rust:  ## always break after each case - do not fallthru to default: block\n            if select_hack or self._go:\n                r.append(self.indent()+' break;}')\n            else:\n                r.append(self.indent()+'} break;')  ## } extra scope\n        ###################################\n\n        if is_extern:\n            r.append(self.indent()+'}')\n\n        elif is_select:\n            if self._cpp:\n                r.append(self.indent()+'_select_.wait();')\n            elif self._rust:\n                r.append(self.indent()+'})')  ## rust needs extra closing brace for the match-block\n            elif self._go:\n                r.append(self.indent()+'}')\n            else:\n                r.append(self.indent()+'break; }')\n\n            self._with_type.pop()\n\n        elif is_switch:\n            if self._rust and not self._cpp:\n                r.append(self.indent()+'}}')  ## rust needs extra closing brace for the match-block\n            else:\n                r.append(self.indent()+'}')\n\n            self._with_type.pop()\n            self._rename_hacks.clear()   ## TODO properly clear\n\n        return '\\n'.join(r)", 
            "title": "With"
        }, 
        {
            "location": "/generatorbase/#go-hacks", 
            "text": "TODO clean up.  \n    def parse_go_style_arg( self, s ):\n        if isinstance(s, ast.Str): s = s.s\n        return s.split(']')[-1]\n\n    def _visit_call_helper_go(self, node):\n        go_types = 'bool string int float64'.split()\n\n        name = self.visit(node.func)\n        if name == '__go__':\n            if self._cpp:\n                ## simple auto threads\n                thread = '__thread%s__' %len(self._threads)\n                self._threads.append(thread)\n                ## do not capture all variables by reference ` `,\n                ## because threads spawned in a for loop will all share\n                ## references to loop variants.\n                #closure_wrapper = '[ ]{%s;}'%self.visit(node.args[0])\n                ## TODO: capture by reference list of arrays and objects,\n                ## unknown variables default to copy into thread.\n                closure_wrapper = '[=]{%s;}'%self.visit(node.args[0])\n\n                return 'std::thread %s( %s );' %(thread, closure_wrapper)\n            elif self._rust:\n                return 'thread::spawn( move || {%s;} );' % self.visit(node.args[0])\n            elif self._go:\n                return 'go %s' %self.visit(node.args[0])\n            else:  ## javascript\n                r = self.visit(node.args[0])\n                mode = 'call'\n                fname = self.visit(node.args[0].func)\n                args = [self.visit(a) for a in node.args[0].args]\n                if fname == 'new':\n                    mode = 'new'\n                    fname = self.visit(node.args[0].args[0].func)\n                    args = [self.visit(a) for a in node.args[0].args[0].args]\n                if node.keywords:\n                    if not node.keywords[0].arg=='cpu':\n                        raise SyntaxError('invalid keyword argument to the builtin `spawn`')\n                    cpuid = self.visit(node.keywords[0].value)\n                    return '\u2ca2\u2c91\u2c91\u2c92.spawn({%s: %s , args:[%s]}, {cpu:%s})' %(mode,fname, ','.join(args), cpuid)\n                else:\n                    return '\u2ca2\u2c91\u2c91\u2c92.spawn({%s: %s , args:[%s]})' %(mode,fname, ','.join(args))\n\n        elif name == '__go_make__':\n            if len(node.args)==2:\n                return 'make(%s, %s)' %(self.visit(node.args[0]), self.visit(node.args[1]))\n            elif len(node.args)==3:\n                return 'make(%s, %s, %s)' %(self.visit(node.args[0]), self.visit(node.args[1]), self.visit(node.args[1]))\n            else:\n                raise SyntaxError('go make requires 2 or 3 arguments')\n        elif name == '__go_make_chan__':\n            ## channel constructors\n            if self._cpp:\n                ## cpp-channel API supports input/output\n                T = self.visit(node.args[0])\n                if self.is_prim_type(T):\n                    return 'cpp::channel %s {}'%T\n                else:\n                    return 'cpp::channel %s* {}'%T\n            elif self._rust:\n                ## rust returns a tuple input/output that needs to be destructured by the caller\n                return 'channel:: %s ()' %self.visit(node.args[0])\n            else:  ## Go\n                return 'make(chan %s)' %self.visit(node.args[0])\n\n        elif name == '__go__array__':\n            if isinstance(node.args[0], ast.BinOp):# and node.args[0].op == ' ':  ## todo assert right is `typedef`\n                a = self.visit(node.args[0].left)\n                T = self.visit(node.args[0])\n                if type(T) is tuple:\n                    assert T[1]=='typedef'\n                    T = T[0]\n\n                if self._cpp:\n                    if self._memory[-1]=='STACK':\n                        return 'std::vector %s ' %T\n                    else:\n                        return 'std::shared_ptr std::vector %s ' %T\n                else:\n                    if a in go_types:\n                        if self._go:\n                            return '*[]%s' %a\n                        elif self._rust:\n                            return ' mut Vec %s ' %a  ## TODO test this\n                        else:\n                            raise RuntimeError('todo')\n                    else:\n                        return '*[]*%s' %a  ## todo - self._catch_assignment_array_of_obs = true\n\n            else:\n                a = self.visit(node.args[0])\n                if a in go_types:\n                    return '[]%s{}' %a\n                else:\n                    return '[]*%s{}' %a\n        elif name == '__go__addr__':\n            return ' %s' %self.visit(node.args[0])\n        else:\n            raise SyntaxError(name)", 
            "title": "Go hacks"
        }, 
        {
            "location": "/jstranslator/", 
            "text": "Javascript Translator\n\n\ntranslates intermediate form into final javascript.\nThis is also subclassed by these other backends:\n\n \ngotranslator.md\n\n\n \nrusttranslator.md\n\n* \ncpptranslator.md\n\n\nnotes:\n\n the implementation of \nspawn\n is in \ngeneratorbase.md\n\n\n the builtin webworker pool spawn manager is in \nbuiltins_core.py\n\n\n# PythonJS to JavaScript Translator\n# by Amirouche Boubekki and Brett Hartshorn - copyright 2013\n# License: \nNew BSD\n\n\n## note this should be cleared after a full round of translation,\n## first the runtime is regenerated, and that is the first to populate\n## the unicode name mapping.\nUNICODE_NAME_MAP = {}\n\nfrom types import GeneratorType\nfrom ast import Str\nfrom ast import Name\nfrom ast import Tuple\nfrom ast import Attribute\nfrom ast import NodeVisitor\n\nBLOCKIDS = False\n\nclass SwapLambda( RuntimeError ):\n    def __init__(self, node):\n        self.node = node\n        RuntimeError.__init__(self)\n\nclass JSGenerator(NodeVisitorBase, GeneratorBase):\n    def __init__(self, source, requirejs=True, insert_runtime=True, webworker=False, function_expressions=True, fast_javascript=False, fast_loops=False, runtime_checks=True, as_module=False):\n        if not source:\n            raise RuntimeError('empty source string')\n        NodeVisitorBase.__init__(self, source)\n\n        self._memory = ['HEAP']  ## used by c++ backend\n        self._with_type = []\n        self._classes = {}\n        self.method_returns_multiple_subclasses = {} # class name : set\n        self._class_stack = []\n\n        self._v8 = '--v8-natives' in sys.argv\n        self._ES6 = {\n            'imports' : True\n        }\n        self._as_module = as_module\n        self._in_locals = False\n        self._unicode_name_map = UNICODE_NAME_MAP\n\n        self._iter_id = 0  ## used by for loops\n        self._in_try = False\n        self._runtime_type_checking = runtime_checks\n        self.macros = {}\n        self._sleeps = 0\n        self._has_channels = False\n        self._func_recv = 0\n        self._with_oo = False\n        self._fast_js = fast_javascript\n        self._fast_loops = fast_loops\n        self._func_expressions = function_expressions\n        self._indent = 0\n        self._global_functions = {}\n        self._function_stack = []\n        self._requirejs = requirejs\n        self._insert_runtime = insert_runtime\n        self._insert_nodejs_runtime = False\n        self._insert_nodejs_tornado = False\n        self._webworker = webworker\n        self._exports = set()\n        self._inline_lambda = False\n        self.catch_call = set()  ## subclasses can use this to catch special calls\n\n        self.special_decorators = set(['__typedef__', '__pyfunction__', 'expression'])\n\n        self._typed_vars = dict()\n\n        self._lua  = False\n        self._dart = False\n        self._go   = False\n        self._rust = False\n        self._cpp = False\n        self._cheader = []\n        self._cppheader = []\n        self._cpp_class_impl = []\n        self._match_stack = []       ## dicts of cases\n        self._rename_hacks = {}      ## used by c++ backend, to support `if isinstance`\n        self._globals = {}           ## name : type\n        self._called_functions = {}  ## name : number of calls\n\n\n\n\nreset\n\n\nreset()\n needs to be called for multipass backends, that are dumb and run translation twice to gather info in two passes.\n\n\n\n    def reset(self):\n        self._cheader = []\n        self._cppheader = []\n        self._cpp_class_impl = []\n        self._match_stack = []\n\n\n\n\n\nClass\n\n\nclass is not implemented here for javascript, it gets translated ahead of time in \n\nintermediateform.md\n\n\n\n    def visit_ClassDef(self, node):\n        raise NotImplementedError(node)\n\n\n    def visit_Global(self, node):\n        return '/*globals: %s */' %','.join(node.names)\n\n    def visit_Assert(self, node):\n        return 'if (!(%s)) {throw new Error(\nassertion failed\n); }' %self.visit(node.test)\n\n\n    def visit_Expr(self, node):\n\n        s = self.visit(node.value)\n        if s is None:\n            raise RuntimeError('GeneratorBase ExpressionError: %s' %node.value)\n\n        if s.strip() and not s.endswith(';'):\n            s += ';'\n\n        if s==';' or not s:\n            return ''\n        else:\n            if self._in_try or not self._runtime_type_checking:\n                return s\n            elif not len(self._function_stack) or s.startswith('var '):\n                return s\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='inline':\n                if typedpython.needs_escape(s):raise RuntimeError(s)\n                return s\n\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='sleep':\n                assert self._stack[-1] is node\n                if len(self._stack) \n 3:\n                    raise SyntaxError('the builtin `sleep` can not be used at the global level outside of a function.')\n                elif isinstance(self._stack[-2], ast.If):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not under an `if` block.')\n                elif isinstance(self._stack[-2], ast.For):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not inside a `for` loop.')\n                elif isinstance(self._stack[-2], ast.While):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not inside a `for` or `while` loop.')\n                elif not isinstance(self._stack[-2], ast.FunctionDef):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not nested under any blocks.')\n                return s\n            else:\n                ## note `debugger` is a special statement in javascript that sets a break point if the js console debugger is open ##\n                do_try = True\n                caller = self._function_stack[-1].name\n                called = None\n                if isinstance(node.value, ast.Call):\n                    called = self.visit(node.value.func)\n                    if isinstance(node.value.func, ast.Name) and node.value.func.id=='new':\n                        do_try = False\n                elif isinstance(node.value, ast.Attribute):\n                    do_try = False\n\n                if not do_try:\n                    return s\n                else:\n                    a = '/***/ try {\\n'\n                    a += self.indent() + s + '\\n'\n                    if typedpython.unicode_vars:\n                        if called:\n                            a += self.indent() + '/***/ } catch (__err) { if (\ud835\uddd7\ud835\uddf2\ud835\uddef\ud835\ude02\ud835\uddf4\ud835\uddf4\ud835\uddf2\ud835\uddff.onerror(__err, %s, %s)==true){debugger;}else{throw __err;} };' %(caller, called)\n                        else:\n                            a += self.indent() + '/***/ } catch (__err) { if (\ud835\uddd7\ud835\uddf2\ud835\uddef\ud835\ude02\ud835\uddf4\ud835\uddf4\ud835\uddf2\ud835\uddff.onerror(__err, %s)==true){debugger;}else{throw __err;} };' %caller\n                    else:\n                        if called:\n                                a += self.indent() + '/***/ } catch (__err) { if (__debugger__.onerror(__err, %s, %s)==true){debugger;}else{throw __err;} };' %(caller, called)\n                        else:\n                            a += self.indent() + '/***/ } catch (__err) { if (__debugger__.onerror(__err, %s)==true){debugger;}else{throw __err;} };' %caller\n\n                    return a\n\n\n    def visit_Assign(self, node):\n        target = node.targets[0]\n        isname = isinstance(target, ast.Name)\n\n        if isinstance(target, Tuple):\n            raise NotImplementedError('target tuple assignment should have been transformed to flat assignment by python_to_pythonjs.py')\n        else:\n            value = self.visit(node.value)\n\n            if self._runtime_type_checking and isinstance(target, ast.Subscript):\n                tar = self.visit(target.value)\n                key = self.visit(target.slice)\n                a = [\n                    'if (%s.__setitem__) { %s.__setitem__(%s, %s) }' %(tar,tar,key,value),\n                    self.indent() + 'else { %s = %s }' %(self.visit(target), value)\n                ]\n                return '\\n'.join(a)\n\n            else:\n                target = self.visit(target)\n\n\n            if self._requirejs and target not in self._exports and self._indent == 0 and '.' not in target:\n                self._exports.add( target )\n\n\n\n            ########################################\n            if value.startswith('\u2ca2\u2c91\u2c91\u2c92.send('):\n                if target=='this':  ## should assert that this is on the webworker side\n                    target = 'this.__uid__'\n                    value = value.replace('\u2ca2\u2c91\u2c91\u2c92.send(', 'self.postMessage(')\n                code = value % target\n            elif value.startswith('\u2ca2\u2c91\u2c91\u2c92.recv') or value.startswith('\u2ca2\u2c91\u2c91\u2c92.get') or value.startswith('\u2ca2\u2c91\u2c91\u2c92.call'):\n                self._func_recv += 1\n                self.push()\n                code = value % target\n            else:\n                if isname and len(self._function_stack):\n                    if self._runtime_type_checking or hasattr(self._function_stack[-1],'has_locals') or self._in_locals: \n                        #target = '%s.locals.%s=%s' %(self._function_stack[-1].name, target, target)\n                        #target = 'arguments.callee.locals.%s=%s' %(target, target)  ## breaks with multiple sleeps\n                        target = '\u0192.locals.%s=%s' %(target, target)\n\n\n                code = '%s = %s;' % (target, value)\n\n            if self._v8 and isname and len(self._function_stack) and self._runtime_type_checking:\n                code += 'if ('+target+' \n typeof('+target+')==\nobject\n \n ! %HasFastProperties(' + target + ')) console.log(\nV8::WARN-SLOW-PROPS-\n%s\n);'%target\n\n            return code\n\n    def visit_AugAssign(self, node):\n        methodnames = {\n            '+': 'add',\n            '-': 'sub',\n            '*': 'mul',\n            '/': 'div',\n            '%': 'mod'\n        }\n\n\n        ## n++ and n-- are slightly faster than n+=1 and n-=1\n        target = self.visit(node.target)\n        op = self.visit(node.op)\n        value = self.visit(node.value)\n        if op=='+' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s ++;' %target\n        elif op=='-' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s --;' %target\n        elif op=='+' and isinstance(node.value, ast.Num):\n            a = '%s %s= %s;' %(target, op, value)  ## direct\n        elif op == '+' and not self._go:\n            if self._with_oo:\n                ## supports += syntax for arrays ##\n                if typedpython.unicode_vars:\n                    x = [\n                        'if (%s instanceof Array || \ud835\udc70\ud835\udc94\ud835\udc7b\ud835\udc9a\ud835\udc91\ud835\udc86\ud835\udc85\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s)) { %s.extend(%s); }' %(target,target,target, value),\n                        self.indent() + 'else if (%s.__iadd__) { %s.__iadd__(%s); }' %(target,target, value),\n                        self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n                    ]\n                else:\n                    x = [\n                        'if (%s instanceof Array || __is_typed_array(%s)) { %s.extend(%s); }' %(target,target,target, value),\n                        self.indent() + 'else if (%s.__iadd__) { %s.__iadd__(%s); }' %(target,target, value),\n                        self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n                    ]\n                a = '\\n'.join(x)\n            elif self._runtime_type_checking:\n                if typedpython.unicode_vars:\n                    x = [\n                        'if (%s instanceof Array || \ud835\udc70\ud835\udc94\ud835\udc7b\ud835\udc9a\ud835\udc91\ud835\udc86\ud835\udc85\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s)) { throw new RuntimeError(\nArray += Array is not allowed without operator overloading\n); }' %(target,target),\n                        self.indent() + '%s %s= %s;'%(target, op, value)\n                    ]\n                else:\n                    x = [\n                        'if (%s instanceof Array || __is_typed_array(%s)) { throw new RuntimeError(\nArray += Array is not allowed without operator overloading\n); }' %(target,target),\n                        self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n                    ]\n                a = '\\n'.join(x)\n            else:\n                a = '%s %s= %s;' %(target, op, value)  ## direct\n\n        elif op in methodnames.keys() and self._with_oo and not self._go:\n            m = methodnames[op]\n            x = [\n                'if (%s.__i%s__) { %s.__i%s__(%s) }' %(target,m, target,m, value),\n                self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n            ]\n            a = '\\n'.join(x)\n\n        else:\n            a = '%s %s= %s;' %(target, op, value)  ## direct\n\n\n        return a\n\n\n\n\n\nRequireJS\n\n\ngenerate a generic or requirejs module.\n\n\n    def _new_module(self, name='main.js'):\n        header = []\n        if self._requirejs and not self._webworker:\n            header.extend([\n                'define( function(){',\n                '__module__ = {}'\n            ])\n        elif self._ES6['imports'] and self._as_module:\n            header.append('module \n%s\n {' %name)\n\n\n        return {\n            'name'   : name,\n            'header' : header,\n            'lines'  : []\n        }\n\n\n\n\n\nModule\n\n\ntop level the module, this builds the output and returns the javascript string translation\n\n\n\n    def _check_for_unicode_decorator(self, node):\n        if isinstance(node, ast.FunctionDef):\n            for decor in node.decorator_list:\n                if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'unicode':\n                    assert len(decor.args)==1\n                    self._unicode_name_map[ node.name ] = decor.args[0].s\n\n\n    def _importfrom_helper(self, node):\n        if node.module=='nodejs':\n            self._insert_nodejs_runtime = True\n        elif node.module=='nodejs.tornado':\n            self._insert_nodejs_tornado = True\n        else:\n            inames = [ n.name for n in node.names ]\n            return 'import {%s} from \n%s\n;' %(','.join(inames), node.module)\n\n        return ''\n\n    def visit_Import(self, node):\n        rapydlibs = {\n            'math': '/lib/node_modules/rapydscript/src/lib/math.pyj',\n            'random': '/lib/node_modules/rapydscript/src/lib/random.pyj',\n            're': '/lib/node_modules/rapydscript/src/lib/re.pyj',\n            'operator': '/lib/node_modules/rapydscript/src/lib/operator.pyj',\n        }\n        res = []\n        for alias in node.names:\n            alias.name = alias.name.replace('__SLASH__', '/').replace('__DASH__', '-')\n            if alias.name in rapydlibs.keys():\n                pyj = rapydlibs[ alias.name ]\n                if not os.path.isfile(pyj):\n                    raise RuntimeError('can not find rapydscript stdlib source: %s' %pyj)\n\n                tmpjs = tempfile.gettempdir() + '/rapyd-output.js'\n                subprocess.check_call(['rapydscript', pyj, '--bare', '--prettify', '--output', tmpjs])\n                rapydata = open(tmpjs,'rb').read()\n                #raise RuntimeError(rapydata)\n                #res.append(rapydata)\n                in_mod = False\n                in_private = False\n                head  = []\n                body = []\n                tail = []\n                funcnames = set()\n                for line in rapydata.splitlines():\n                    if line.strip()=='var __name__ = \n__main__\n;':  ## hackish way to split head and module body\n                        in_mod = True\n                        body.append('var %s = {' %alias.name)\n                    elif in_mod:\n                        if line.startswith('_$'):\n                            in_private = True\n                        helpercall = False\n                        for fname in funcnames:\n                            if line.startswith(fname) and '(' in line and ')' in line and line.endswith(';'):\n                                helpercall = True\n                        #########################\n                        if helpercall:\n                            tail.append('%s.%s' %(alias.name, line))\n                        elif in_private:\n                            head.append(line)\n                            if line=='};':\n                                in_private = False\n                        else:\n                            if line.startswith('function '):\n                                fname = line.split()[1].split('(')[0]\n                                funcnames.add( fname )\n                                line = '%s : %s' %(fname,line)\n                            elif line == '}':  ## end of function\n                                line += ','\n                            elif line.strip() and line[0]!=' ' and line[-1]==';' and '=' in line:\n                                #vname = line.split('=')[0].strip()\n                                line = line.replace('=', ':').replace(';', ',')\n\n                            ## very hackish\n                            if line.startswith(' '):\n                                hacks = set()\n                                for word in line.split():\n                                    if '(' not in word:\n                                        continue\n                                    word = word.split('(')[0]\n                                    for fname in funcnames:\n                                        if word == fname:\n                                            hacks.add(fname)\n                                for fname in hacks:\n                                    line = line.replace(fname, '%s.%s'%(alias.name,fname))\n\n                            body.append(line)\n                    else:\n                        head.append(line)\n                body.append('};')  ## end of module\n                res.extend(head)\n                res.extend(body)\n                res.extend(tail)\n\n            elif alias.asname:\n                res.append(\n                    \nvar %s = require('%s');\n %(alias.asname, alias.name)\n                )\n            else:\n                res.append(\n                    \nvar %s = require('%s');\n %(alias.name, alias.name)\n                )\n\n        if res:\n            return '\\n'.join(res)\n        else:\n            return ''\n\n    def visit_Module(self, node):\n        modules = []\n\n        mod = self._new_module()\n        modules.append( mod )\n        lines = mod['lines']\n        header = mod['header']\n\n        if self._v8:\n            #header.append('console.log(\nV8::Version\n);')\n            #header.append('console.log(%GetV8Version());')\n            #header.append('console.log(\nV8::Heap\n);')\n            #header.append('console.log(%GetHeapUsage());')\n            header.append('var v8 = function v8(fn) {return %OptimizeFunctionOnNextCall(fn);};')\n            header.append('v8.gc = function v8_gc() {return %CollectGarbage(null);};')\n\n        ## first check for all the @unicode decorators,\n        ## also check for special imports like `from runtime import *`\n        for b in node.body:\n            if typedpython.unicode_vars:\n                self._check_for_unicode_decorator(b)\n\n            if isinstance(b, ast.ImportFrom):\n                line = self.visit(b)\n                if line:\n                    ## ES6 imports\n                    header.append(line)\n\n\n\n        for b in node.body:\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Call) and isinstance(b.value.func, ast.Name) and b.value.func.id == '__new_module__':\n                mod = self._new_module( '%s.js' %b.value.args[0].id )\n                modules.append( mod )\n                lines = mod['lines']\n                header = mod['header']\n\n            else:\n                line = self.visit(b)\n                if line: lines.append( line )\n\n\n        if self._insert_runtime:\n            ## always regenerate the runtime, in case the user wants to hack it ##\n            runtime = generate_js_runtime(\n                nodejs         = self._insert_nodejs_runtime,\n                nodejs_tornado = self._insert_nodejs_tornado,\n                webworker_manager = self._has_channels and not self._webworker,\n                debugger = self._runtime_type_checking\n            )\n            lines.insert( 0, runtime )\n        else:\n            lines.insert( 0, 'var __$UID$__=0;')\n\n\n        #if self._has_channels and not self._webworker:\n        #   #lines.insert( 0, 'var __workerpool__ = new __WorkerPool__(__workersrc__, __workerimports__);')\n        #   # moved to intermediateform.md\n        #   pass\n\n        ######################### modules ####################\n        if self._requirejs and not self._webworker:\n            for name in self._exports:\n                if name.startswith('__'): continue\n                lines.append( '__module__.%s = %s' %(name,name))\n            lines.append( 'return __module__')\n            lines.append('}) //end requirejs define')\n\n        elif self._ES6['imports'] and self._as_module:\n            lines.append('} // end ES6 module')\n\n\n        if len(modules) == 1:\n            lines = header + lines\n            ## fixed by Foxboron\n            return '\\n'.join(l if isinstance(l,str) else l.encode(\nutf-8\n) for l in lines)\n        else:\n            d = {}\n            for mod in modules:\n                lines = mod['header'] + mod['lines']\n                d[ mod['name'] ] = '\\n'.join(l if isinstance(l,str) else l.encode(\nutf-8\n) for l in lines)\n            return d\n\n\n\n\n\nIn\n\n\nnote a \nin\n test in javascript is very different from the way python normally works,\nfor example \n0 in [1,2,3]\n is true in javascript, while it is false in python,\nthis is because an \nin\n test on an array in javascript checks the indices, not the values,\nwhile in python it works by testing if the value is in the array.\nDepending on the options given in the first stage of translation \nintermediateform.md\n,\n\nin\n tests will be replaced with a function call to \n__contains__\n which implements the python style logic.\nHowever, in some cases an \nin\n test is still generated at here in the final stage of translation.\n\n\n\n    def visit_In(self, node):\n        return ' in '\n\n\n\n\n\nTry/Except and Raise\n\n\nTODO \nfinnally\n for the javascript backend \n\n\n\n    def visit_TryExcept(self, node):\n        self._in_try = True\n        out = []\n        out.append( self.indent() + 'try {' )\n        self.push()\n        out.extend(\n            list( map(self.visit, node.body) )\n        )\n        self.pull()\n        out.append( self.indent() + '} catch(__exception__) {' )\n        self.push()\n        out.extend(\n            list( map(self.visit, node.handlers) )\n        )\n        self.pull()\n        out.append( '}' )\n        self._in_try = False\n        return '\\n'.join( out )\n\n    def visit_Raise(self, node):\n        ## TODO - when re-raising an error, it fails because it is an Error object\n        ## TODO - inject some code here to check the type at runtime.\n        return 'throw new %s;' % self.visit(node.type)\n\n    def visit_ExceptHandler(self, node):\n        out = ''\n        if node.type:\n            out = 'if (__exception__ == %s || __exception__ instanceof %s) {\\n' % (self.visit(node.type), self.visit(node.type))\n        if node.name:\n            out += 'var %s = __exception__;\\n' % self.visit(node.name)\n        out += '\\n'.join(map(self.visit, node.body)) + '\\n'\n        if node.type:\n            out += '}\\n'\n        return out\n\n\n\n\n\nYield\n\n\nnote yield is new in javascript, and works slightly different from python, ie.\nyielding is not cooperative, calling \nsome_function_that_also_yields()\n inside\na function that is already using yield will not co-op yield.\n\n\n\n    def visit_Yield(self, node):\n        return 'yield %s' % self.visit(node.value)\n\n    def visit_Lambda(self, node):\n        args = [self.visit(a) for a in node.args.args]\n        if args and args[0]=='__INLINE_FUNCTION__':\n            self._inline_lambda = True\n            #return '\nLambdaError\n'   ## skip node, the next function contains the real def\n            raise SwapLambda( node )\n        else:\n            return '(function (%s) {return %s;})' %(','.join(args), self.visit(node.body))\n\n\n\n\n\n\nFunction/Methods\n\n\nnote: \nvisit_Function\n after doing some setup, calls \n_visit_function\n that subclasses overload.\n\n\n\n    def _visit_function(self, node):\n        if node.name == '__DOLLAR__':\n            node.name = '$'\n\n        if typedpython.unicode_vars and typedpython.needs_escape(node.name):\n            node.name = typedpython.escape_text(node.name)\n        if node.name=='__right_arrow__' and len(self._function_stack)==1:\n            node.name = '\u1405'\n\n        comments = []\n        body = []\n        is_main = node.name == 'main'\n        is_annon = node.name == ''\n        is_pyfunc    = False\n        is_prototype = False\n        is_debugger  = False\n        is_redef     = False\n        is_locals    = False\n        is_staticmeth= False\n        is_getter    = False\n        is_setter    = False\n        is_unicode   = False\n        is_v8        = False\n        bind_to      = None\n        bind_to_this = None\n        protoname    = None\n        func_expr    = False  ## function expressions `var a = function()` are not hoisted\n        func_expr_var = True  ## this should always be true, was this false before for hacking nodejs namespace?\n        returns = None\n\n        ## decorator specials ##\n        ## note: only args_typedefs is used for now in the js backend ##\n        options = {'getter':False, 'setter':False, 'returns':None, 'returns_self':False, 'generic_base_class':None, 'classmethod':False}\n        args_typedefs = {}\n        chan_args_typedefs = {}\n        generics = set()\n        args_generics = dict()\n        func_pointers = set()\n        arrays = dict()\n        has_timeout = None\n        timeout_seconds = None\n        ########################\n        decorators = []\n        for decor in node.decorator_list:\n\n            ##note: `_visit_decorator` is defined in generatorbase.md\n            self._visit_decorator(\n                decor,\n                node=node,\n                options=options,\n                args_typedefs=args_typedefs,\n                chan_args_typedefs=chan_args_typedefs,\n                generics=generics,\n                args_generics=args_generics,\n                func_pointers=func_pointers,\n                arrays = arrays,\n            )\n\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'expression':\n                assert len(decor.args)==1\n                func_expr = True\n                func_expr_var = isinstance(decor.args[0], ast.Name)\n                node.name = self.visit(decor.args[0])\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'timeout':\n                has_timeout = True\n                timeout_seconds = decor.args[0].n\n                if decor.keywords:\n                    raise RuntimeError(decor.keywords)\n                elif len(decor.args)\n1 and isinstance(decor.args[1], ast.Dict):\n                    if isinstance(decor.args[1].keys[0], ast.Name) and decor.args[1].keys[0].id=='loop':\n                        dval = self.visit(decor.args[1].values[0])\n                        if dval=='true' or dval == 'True' or dval == 1:\n                            has_timeout = 'INTERVAL'\n                    else:\n                        raise SyntaxError(self.format_error('invalid option to @timeout decorator'))\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'unicode':\n                if typedpython.unicode_vars:\n                    assert len(decor.args)==1\n                    is_unicode = True\n                    node.name = decor.args[0].s\n\n            elif isinstance(decor, ast.Name) and decor.id == 'v8':\n                is_v8 = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'getter':\n                is_getter = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'setter':\n                is_setter = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'staticmethod':\n                is_staticmeth = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'debugger':\n                is_debugger = True\n            elif isinstance(decor, ast.Name) and decor.id == 'redef':\n                is_redef = True\n                is_locals = True\n                node.has_locals = True\n                self._in_locals = True\n            elif isinstance(decor, ast.Name) and decor.id == 'locals':\n                is_locals = True\n                node.has_locals = True\n                self._in_locals = True\n\n            elif isinstance(decor, ast.Name) and decor.id == '__pyfunction__':\n                is_pyfunc = True\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef__':\n                pass\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__prototype__':\n                assert len(decor.args)==1\n                is_prototype = True\n                protoname = decor.args[0].id\n                if typedpython.needs_escape(protoname):\n                    protoname = typedpython.escape_text(protoname)\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'returns':\n                returns = decor.args[0].id\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'bind':\n                assert len(decor.args)\n=2\n                bind_to = self.visit(decor.args[0])\n                if len(decor.args)==2:\n                    bind_to_this = self.visit(decor.args[1])\n            else:\n                decorators.append( self.visit(decor)+'(' )\n\n        dechead = ''.join(decorators)\n        dectail = ')' * len(decorators)\n        if has_timeout:\n            if has_timeout=='INTERVAL':\n                dechead = '__set_interval('+dechead\n                dectail += ', %s)' %(timeout_seconds)\n            else:\n                dechead = '__set_timeout('+dechead\n                dectail += ', %s)' %(timeout_seconds)\n\n        args = self.visit(node.args)\n        funcname = node.name\n\n\n        #if len(self._function_stack) == 1:\n        #   self._iter_id = 0\n\n        if is_prototype:\n            funcname = '%s_%s' %(protoname, node.name)\n            if is_debugger:\n                raise SyntaxError('@debugger is not allowed on methods: %s.%s' %(protoname, node.name))\n            if bind_to:\n                raise SyntaxError('@bind is not allowed on methods: %s.%s' %(protoname, node.name))\n\n            if is_getter:\n                assert len(args)==0\n                funcname = '__getter__' + funcname\n                fdef = '%s function %s(%s)' % (dechead, funcname, ', '.join(args))\n            elif is_setter:\n                funcname = '__setter__' + funcname\n                fdef = '%s function %s(%s)' % (dechead, funcname, ', '.join(args))\n\n            elif is_staticmeth:\n                fdef = '%s.%s = %s function %s(%s)' % (protoname, node.name, dechead, funcname, ', '.join(args))\n            else:\n                fdef = '%s.prototype.%s = %s function %s(%s)' % (protoname, node.name, dechead, funcname, ', '.join(args))\n\n        elif len(self._function_stack) == 1:\n            ## note: var should always be used with function expressions.\n\n            if self._func_expressions or func_expr:\n                if is_debugger:\n                    ## first open devtools then wait two seconds and then run function  ##\n                    d = [\n                        'var %s = function debugger_entrypoint_%s() {' %(node.name, node.name),\n                        '   /***/ var __entryargs__ = arguments;',\n                        '   /***/ try {var __win = require(\nnw.gui\n).Window.get(); __win.showDevTools(); __win.focus(); __win.moveTo(10,0);} catch (__err) {};',\n                        '   setTimeout(function(){%s_wrapped(__entryargs__)}, 2000);' %node.name,\n                        '   var %s_wrapped = function %s_wrapped(%s)' % (node.name, node.name, ', '.join(args)),  ## scope lifted ok here\n                    ]\n                    fdef = '\\n'.join(d)\n                    self.push()\n                elif bind_to:\n                    if bind_to_this:\n                        fdef = '%s = %s (function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                    else:\n                        fdef = '%s = %s function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                else:\n                    fdef = 'var %s = %s function %s(%s)' % (node.name,dechead, node.name,  ', '.join(args))\n\n            else:  ## scope lifted functions are not safe ##\n                fdef = 'function %s(%s)' % (node.name, ', '.join(args))\n\n\n            if self._requirejs and node.name not in self._exports:\n                self._exports.add( node.name )\n\n        else:\n            if is_debugger:\n                raise SyntaxError('the decorator `@debugger` is only used on top level functions in the global namespace')\n\n            if self._func_expressions or func_expr:\n                if bind_to:\n                    if bind_to_this:\n                        fdef = '%s = %s (function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                    else:\n                        fdef = '%s = %s function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                else:\n                    fdef = 'var %s = %s function %s(%s)' % (node.name,dechead, node.name,  ', '.join(args))\n\n            else: ## scope lifted functions are not safe ##\n                fdef = 'function %s(%s)' % (node.name, ', '.join(args))\n\n        if BLOCKIDS:\n            if is_prototype or (bind_to and '.prototype.' in bind_to):\n                body.append( '/*BEGIN-METH:%s*/' %id(node))\n            else:\n                body.append( '/*BEGIN-FUNC:%s*/' %id(node))\n\n        body.append( self.indent() + fdef + '{' )\n        #body.append( self.indent() + '{' )\n\n        self.push()\n\n        if self._runtime_type_checking or is_redef:\n            ## doing the recompile and eval inside the function itself allows it to pick\n            ## up any variables from the outer scope if it is a nested function.\n            ## note: the user calls `myfunc.redefine(src)` and then on next call it is recompiled.\n            body.append('/***/var \u0192 = arguments.callee;')\n            body.append(\n                '/***/ if (%s.__recompile !== undefined) { eval(\n%s.__redef=\n+%s.__recompile); %s.__recompile=undefined; };' %(funcname, funcname, funcname, funcname)\n            )\n            body.append(\n                '/***/ if (%s.__redef !== undefined) { return %s.__redef.apply(this,arguments); };' %(funcname, funcname)\n            )\n\n        if self._v8 and is_v8:\n            body.append(\n                '/***/ if (!%s.optimized) { '%funcname + '%OptimizeFunctionOnNextCall(' + '%s);%s.optimized=true;};'%(funcname,funcname)\n            )\n\n        if node.args.vararg:\n            body.append('var %s = Array.prototype.splice.call(arguments,%s, arguments.length);' %(node.args.vararg, len(node.args.args)) )\n\n        next = None  ## deprecated?\n\n        for i,child in enumerate(node.body):\n            if isinstance(child, Str) or hasattr(child, 'SKIP'):  ## TODO check where the SKIP hack is coming from\n                continue\n            elif isinstance(child, ast.Expr) and isinstance(child.value, ast.Str):\n                comments.append('/* %s */' %child.value.s.strip() )\n                continue\n\n\n            v = self.try_and_catch_swap_lambda(child, node.body)\n\n            if v is None:\n                msg = 'error in function: %s'%node.name\n                msg += '\\n%s' %child\n                raise SyntaxError(msg)\n            elif v.strip():\n                body.append( self.indent()+v)\n\n        ## todo fix when sleep comes before channel async _func_recv, should be a stack of ['}', '});']\n        if self._sleeps:\n            body.append( '}/*end-sleep*/' * self._sleeps)\n            #body.append( '__sleep__%s.locals={};' % self._sleeps)  ## breaks on multiple sleeps\n            self._sleeps = 0\n\n        if self._func_recv:\n            while self._func_recv:  ## closes nested generated callbacks\n                self.pull()\n                body.append( self.indent() + '});/*end-async*/' )\n                self._func_recv -= 1\n\n        ## end of function ##\n        self.pull()\n        body.append( self.indent() + '}/*end-\n  `%s`    */' %node.name)\n\n        if bind_to_this:\n            body.append( self.indent() + ').bind(%s);' %bind_to_this)\n\n        if BLOCKIDS:\n            if is_prototype or (bind_to and '.prototype.' in bind_to):\n                body.append( '/*END-METH:%s*/' %id(node))\n            else:\n                body.append( '/*END-FUNC:%s*/' %id(node))\n\n        if is_debugger:\n            body.append( self.indent()+ '%s_wrapped.locals={}; /*wrapped entry point*/' %node.name )\n            self.pull()\n            body.append( '} /*debugger*/' )\n\n        if dectail:\n            body.append(dectail + ';/*end-decorators*/')\n\n        if is_getter:\n            #gtemplate = 'Object.defineProperty(%s.prototype, \n%s\n, {get:%s, enumerable:false, writable:false, configurable:false});'\n            gtemplate = 'Object.defineProperty(%s.prototype, \n%s\n, {get:%s, configurable:true});'\n            body.append( gtemplate%(protoname,node.name, funcname))\n        elif is_setter:\n            ## assume that there is a getter\n            getterfunc = funcname.replace('__setter__', '__getter__')\n            #stemplate = 'Object.defineProperty(%s.prototype, \n%s\n, {get:%s, set:%s, enumerable:false, writable:false, configurable:true});'\n            stemplate = 'Object.defineProperty(%s.prototype, \n%s\n, {get:%s, set:%s, configurable:true});'\n            body.append( stemplate%(protoname,node.name, getterfunc, funcname))\n\n        if self._runtime_type_checking or is_locals or self._in_locals:\n            if is_prototype:\n                body.append(\n                    '%s.prototype.%s.locals = {};' % (protoname, node.name)\n                )\n            else:\n                body.append('%s.locals={};'%node.name)\n                if len(self._function_stack)\n1:\n                    body.append('arguments.callee.locals.%s=%s'%(node.name, node.name))\n\n        ## below is used for runtime type checking ##\n        if returns:\n            if is_prototype:\n                body.append(\n                    '%s.prototype.%s.returns = \n%s\n;' % (protoname, node.name, returns)\n                )\n            else:\n                body.append( node.name + '.returns = \n%s\n;' %returns )\n\n        _func_typed_args = []\n        for arg in node.args.args:\n            if arg.id in args_typedefs:\n                argtype = args_typedefs[arg.id]\n                if argtype.startswith('__arg_map__'):\n                    argtype = argtype.split('\n')[1]\n                _func_typed_args.append( argtype )\n\n        if _func_typed_args:\n            targs = ','.join( ['\n%s\n'%t for t in _func_typed_args] )\n            if is_prototype:\n                body.append(\n                    '%s.prototype.%s.args = [%s];' % (protoname, node.name, targs)\n                )\n            else:\n                body.append( node.name + '.args = [%s];' %targs )\n\n        if is_locals:\n            self._in_locals = False\n\n        buffer = '\\n'.join( comments + body )\n        buffer += '\\n'\n        return self.indent() + buffer\n\n    def try_and_catch_swap_lambda(self, child, body):\n        try:\n            return self.visit(child)\n        except SwapLambda as e:\n\n            next = None\n            for i in range( body.index(child), len(body) ):\n                n = body[ i ]\n                if isinstance(n, ast.FunctionDef):\n                    if hasattr(n, 'SKIP'):\n                        continue\n                    else:\n                        next = n\n                        break\n            assert next\n            next.SKIP = True\n            e.node.__class__ = ast.FunctionDef\n            e.node.__dict__ = next.__dict__\n            e.node.name = ''\n            return self.try_and_catch_swap_lambda( child, body )\n\n\n    def _visit_subscript_ellipsis(self, node):\n        name = self.visit(node.value)\n        raise SyntaxError('ellipsis slice is deprecated in the javascript backend')\n        return '%s[\n$wrapped\n]' %name\n\n\n    def visit_Slice(self, node):\n        raise SyntaxError('list slice')  ## slicing not allowed here at js level\n\n    def visit_arguments(self, node):\n        out = []\n        for name in [self.visit(arg) for arg in node.args]:\n            out.append(name)\n        return out\n\n    def visit_Name(self, node):\n        escape_hack_start = '__x0s0x__'\n        escape_hack_end = '__x0e0x__'\n\n        if node.id == 'None':\n            return 'null'\n        elif node.id == 'True':\n            return 'true'\n        elif node.id == 'False':\n            return 'false'\n        elif node.id == 'null':\n            return 'null'\n        elif node.id == '__DOLLAR__':\n            return '$'\n        elif node.id == 'debugger':  ## keyword in javascript\n            if typedpython.unicode_vars:\n                return '\ud835\uddd7\ud835\uddf2\ud835\uddef\ud835\ude02\ud835\uddf4\ud835\uddf4\ud835\uddf2\ud835\uddff'\n            else:\n                return '__debugger__'\n\n        elif node.id in self._unicode_name_map:  # from @unicode decorators\n            return self._unicode_name_map[node.id]\n\n        elif escape_hack_start in node.id:\n            #assert typedpython.unicode_vars\n            parts = []\n            for p in node.id.split(escape_hack_start):\n                if escape_hack_end in p:\n                    id = int(p.split(escape_hack_end)[0].strip())\n                    if id not in UnicodeEscapeMap.keys():\n                        raise RuntimeError('id not in UnicodeEscapeMap')\n                    uchar = UnicodeEscapeMap[ id ]\n                    parts.append(uchar)\n                else:\n                    parts.append(p)\n            res = ''.join(parts)\n            return res.encode('utf-8')\n        else:\n            return node.id\n\n    def visit_Attribute(self, node):\n        name = self.visit(node.value)\n        attr = node.attr\n\n        if typedpython.needs_escape(attr):\n            attr = typedpython.escape_text(attr)\n\n        return '%s.%s' % (name, attr)\n\n    def visit_Print(self, node):\n        args = [self.visit(e) for e in node.values]\n        if typedpython.unicode_vars:\n            s = '\ud835\udc77\ud835\udc93\ud835\udc8a\ud835\udc8f\ud835\udc95(%s);' % ', '.join(args)\n        else:\n            s = 'console.log(%s);' % ', '.join(args)\n        return s\n\n    def visit_keyword(self, node):\n        if isinstance(node.arg, basestring):\n            return node.arg, self.visit(node.value)\n        return self.visit(node.arg), self.visit(node.value)\n\n\n\n\n\nCall Helper\n\n\n\n    def _visit_call_helper(self, node):\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n\n        fname = self.visit(node.func)\n        if fname=='__DOLLAR__': fname = '$'\n\n        if fname in self.macros:\n            macro = self.macros[fname]\n            args = ','.join([self.visit(arg) for arg in node.args])\n            if '\n%s\n' in macro:\n                return macro % tuple([s.s for s in node.args])\n            elif '%s' in macro:\n                if macro.count('%s')==1:\n                    return macro % args\n                else:\n                    return macro % tuple([self.visit(s) for s in node.args])\n            else:\n                return '%s(%s)' %(macro,args)\n        elif fname == 'sleep':\n            self._sleeps += 1\n            return 'setTimeout(__sleep__%s.bind(this), %s*1000); function __sleep__%s(){' % (self._sleeps, args[0], self._sleeps)\n        elif fname=='v8.__right_arrow__':\n            jitFN = args.split('(')[0]\n            return '%s; v8(%s)' %(args, jitFN)\n        elif fname.endswith('.__right_arrow__'):\n            ob = fname.replace('.__right_arrow__', '')\n            #return '__right_arrow__(%s, %s)' %(ob, args)\n            #return '\u1405(%s, %s)' %(ob, args)\n            if args:\n                return '\u1405(%s, %s)' %(ob, args)\n            else:\n                return '\u1405(%s)' %ob\n\n        else:\n            return '%s(%s)' % (fname, args)\n\n    def inline_helper_remap_names(self, remap):\n        return \nvar %s;\n %','.join(remap.values())\n\n    def inline_helper_return_id(self, return_id):  ## what was this for?\n        return \nvar __returns__%s = null;\n%return_id\n\n    def _visit_call_helper_numpy_array(self, node):\n        return self.visit(node.args[0])\n\n    def _visit_call_helper_list(self, node):\n        name = self.visit(node.func)\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n        return '%s(%s)' % (name, args)\n\n    def _visit_call_helper_get_call_special(self, node):\n        name = self.visit(node.func)\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n        return '%s(%s)' % (name, args)\n\n\n    def _visit_call_helper_JSArray(self, node):\n        if node.args:\n            args = map(self.visit, node.args)\n            out = ', '.join(args)\n            #return '__create_array__(%s)' % out\n            return '[%s]' % out\n\n        else:\n            return '[]'\n\n\n    def _visit_call_helper_JSObject(self, node):\n        if node.keywords:\n            kwargs = map(self.visit, node.keywords)\n            f = lambda x: '\n%s\n: %s' % (x[0], x[1])\n            out = ', '.join(map(f, kwargs))\n            return '{%s}' % out\n        else:\n            return '{}'\n\n    def _visit_call_helper_var(self, node):\n        args = [ self.visit(a) for a in node.args ]\n        if self._function_stack:\n            fnode = self._function_stack[-1]\n            rem = []\n            for arg in args:\n                if arg in fnode._local_vars:\n                    rem.append( arg )\n                else:\n                    fnode._local_vars.add( arg )\n            for arg in rem:\n                args.remove( arg )\n        if 'this' in args:\n            args.remove('this')\n        out = []\n        if args:\n            out.append( 'var ' + ','.join(args) )\n        if node.keywords:\n            out.append( 'var ' + ','.join([key.arg for key in node.keywords]) )\n            for key in node.keywords:\n                ## inside a webworker this is a type cast\n                if self._webworker:\n                    out.append('%s.__proto__ = %s.prototype' %(key.arg, self.visit(key.value)))\n\n                ## outside of a webworker this is a type assertion\n                elif self._runtime_type_checking:\n                    funcname = self._function_stack[-1].name\n\n                    if isinstance(key.value, ast.Call):\n                        if key.value.func.id == '__arg_array__':\n                            s = key.value.args[0].s\n                            dims = '[0]' * s.count('[')\n                            t = s.split(']')[-1]\n                            out.append('/***/ if (!(isinstance(%s,Array))) {throw new TypeError(\ninvalid type - not an array\n)}' %key.arg)\n                            out.append('/***/ if (%s.length \n 0 \n !( isinstance(%s%s, %s) )) {throw new TypeError(\ninvalid array type\n)}' %(key.arg, key.arg, dims, t))\n                        else:  ## typed hash map\n                            keytype   = key.value.args[0].s.split(']')[0].split('[')[1].strip()\n                            valuetype = key.value.args[0].s.split(']')[1].strip()\n                            out.append('/***/ if (%s.__keytype__ != \n%s\n) {throw new TypeError(\ninvalid dict key type\n)}' %(key.arg, keytype))\n                            out.append('/***/ if (%s.__valuetype__ != \n%s\n) {throw new TypeError(\ninvalid dict value type\n)}' %(key.arg, valuetype))\n\n                    elif isinstance(key.value, ast.Str) and key.value.s.startswith('func('):\n\n                        out.append('/***/ if (!(%s instanceof Function)) {throw new TypeError(\n`%s` is not a callback function: instead got type-\n+typeof(%s))}' %(key.arg, key.arg, key.arg))\n                        targs = []\n                        head,tail = key.value.s.split(')(')\n                        head = head.split('func(')[-1]\n                        for j, targ in enumerate(head.split('|')):  ## NOTE TODO replace `|` with space\n                            out.append(\n                                '/***/ if (!(%s.args[%s]==\n%s\n)) {throw new TypeError(\ncallback `%s` requires argument `%s` as type `%s`\n)}' %(key.arg, j, targ,   key.value.s.replace('|',' '), j, targ)\n                            )\n\n                        returns = tail.replace(')','')\n                        if returns:\n                            out.append(\n                                '/***/ if (!(%s.returns==\n%s\n)) {throw new TypeError(\ncallback `%s` requires a return type of `%s`, instead got-\n + typeof(%s.returns))}' %(key.arg, returns, key.arg, returns, key.arg)\n                            )\n\n                    else:\n                        val = self.visit(key.value)\n                        out.append('/***/ if ( !(isinstance(%s, %s))) {throw new TypeError(\nin function `%s`, argument `%s` must of type `%s`, instead got-\n+typeof(%s))}' %(key.arg, val, funcname, key.arg,val, key.arg))\n\n        return ';\\n'.join(out)\n\n\n\n\n\nInline Code Helper\n\n\ncalled from user: \ninline(str)\n\nold javascript backend also used \nJS(str)\n\n\n\n    def _inline_code_helper(self, s):\n        ## TODO, should newline be changed here?\n        s = s.replace('\\n', '\\\\n').replace('\\0', '\\\\0')  ## AttributeError: 'BinOp' object has no attribute 's' - this is caused by bad quotes\n\n        ## DEPRECATED\n        #if s.strip().startswith('#'): s = '/*%s*/'%s\n        #if '\n' in s or \n'\n in s:  ## can not trust direct-replace hacks\n        #   pass\n        #else:\n        #   if ' or ' in s:\n        #       s = s.replace(' or ', ' || ')\n        #   if ' not ' in s:\n        #       s = s.replace(' not ', ' ! ')\n        #   if ' and ' in s:\n        #       s = s.replace(' and ', ' \n ')\n\n        if typedpython.needs_escape(s):\n            s = typedpython.escape_text(s)\n\n        return s\n\n    def visit_While(self, node):\n        body = [ 'while (%s)' %self.visit(node.test), self.indent()+'{']\n        self.push()\n        if hasattr(self, '_in_timeout') and self._in_timeout:\n            body.append(\n                self.indent() +  'if ( (new Date()).getTime() - __clk__ \n= %s )  { break;}' % self._timeout\n            )\n\n        for line in list( map(self.visit, node.body) ):\n            body.append( self.indent()+line )\n        self.pull()\n        body.append( self.indent() + '}' )\n        return '\\n'.join( body )\n\n    def visit_Str(self, node):\n        s = node.s.replace(\n\\\\\n, \n\\\\\\\\\n).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\n', '\\\\\n')\n        if typedpython.needs_escape(s):\n            s = typedpython.escape_text(s)\n        return '\n%s\n' % s\n\n    def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n        right = self.visit(node.right)\n        go_hacks = ('__go__array__', '__go__arrayfixed__', '__go__map__', '__go__func__', '__go__receive__', '__go__send__')\n\n        if op == '\n' and left == '__new__':\n            ## this can happen because python_to_pythonjs.py will catch when a new class instance is created\n            ## (when it knows that class name) and replace it with `new(MyClass())`; but this can cause a problem\n            ## if later the user changes that part of their code into a module, and loads it as a javascript module,\n            ## they may update their code to call `new MyClass`, and then later go back to the python library.\n            ## the following hack prevents `new new`\n            if isinstance(node.right, ast.Call) and isinstance(node.right.func, ast.Name) and node.right.func.id=='new':\n                right = self.visit(node.right.args[0])\n            return ' new %s' %right\n\n\n        elif op == '\n':\n\n            if left == '__go__receive__':\n                self._has_channels = True\n                r = []\n                if isinstance(node.right, ast.Name):\n                    r.append('\u2ca2\u2c91\u2c91\u2c92.recv( %s,'%right)\n                elif isinstance(node.right, ast.Attribute):\n                    wid = node.right.value.id\n                    attr = node.right.attr\n                    r.append('\u2ca2\u2c91\u2c91\u2c92.get( %s, \n%s\n, '%(wid, attr))\n                elif isinstance(node.right, ast.Call):\n                    if isinstance(node.right.func, ast.Name):\n                        fname = node.right.func.id\n                        args  = [self.visit(a) for a in node.right.args]\n                        r.append('\u2ca2\u2c91\u2c91\u2c92.call( \n%s\n, [%s], ' % (fname, ','.join(args)))\n\n                    else:\n                        wid = node.right.func.value.id\n                        attr = node.right.func.attr\n                        args  = [self.visit(a) for a in node.right.args]\n                        r.append('\u2ca2\u2c91\u2c91\u2c92.callmeth( %s, \n%s\n, [%s], '%(wid, attr, ','.join(args)))\n                else:\n                    raise RuntimeError(node.right)\n\n                r.append(' function (%s) {')  ## gets filled in later\n                return ''.join(r)\n\n            elif left == '__go__send__':\n                self._has_channels = True\n                r = [\n                    '\u2ca2\u2c91\u2c91\u2c92.send({message:%s,'%right,\n                    'id:%s})'\n                ]\n                return ''.join(r)\n\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id in go_hacks:\n                if node.left.func.id == '__go__func__':\n                    raise SyntaxError('TODO - go.func')\n\n                elif node.left.func.id == '__go__map__':  ## typed hash maps for javascript\n                    key_type = node.left.args[0].id\n                    value_type = node.left.args[1].id\n                    if key_type == 'string':\n                        ## right will take the form: `\ud835\udc6b\ud835\udc8a\ud835\udc84\ud835\udc95({  }, { copy:false })`\n                        ## here was simply clip off the end and inject the type options\n                        clipped = right[:-2]\n                        if 'keytype:' not in clipped:\n                            clipped += ',keytype:\n%s\n'  % key_type \n                        clipped += ',valuetype:\n%s\n })' % value_type\n                        return clipped\n                    else:\n                        assert isinstance(node.right, ast.Call)\n                        dictnode = node.right.args[0]\n                        dlist = []\n                        for i in range( len(dictnode.keys) ):\n                            k = self.visit( dictnode.keys[ i ] )\n                            v = self.visit( dictnode.values[i] )\n                            dlist.append( '[%s, %s]' %(k,v) )\n                        return 'dict([%s], {copy:false, keytype:\n%s\n, valuetype:\n%s\n})' %(','.join(dlist), key_type, value_type)\n\n\n                else:\n                    if isinstance(node.right, ast.Name):\n                        raise SyntaxError(node.right.id)\n\n                    right = []\n                    for elt in node.right.elts:\n                        right.append( self.visit(elt) )\n\n                    if node.left.func.id == '__go__array__':\n                        T = self.visit(node.left.args[0])\n                        ## TODO redefine `.append` on this instance to do runtime type checking\n                        return '[%s] /*array of: %s*/' %(','.join(right), T)\n\n                    elif node.left.func.id == '__go__arrayfixed__':\n                        asize = self.visit(node.left.args[0])\n                        atype = self.visit(node.left.args[1])\n\n                        if atype in ('ubyte', 'uint8', 'ui8'):\n                            r = ' new Uint8Array(%s)' %asize\n                        elif atype in ('byte' ,'int8', 'i8'):\n                            r = ' new Int8Array(%s)' %asize\n                        elif atype in ('short', 'int16', 'i16'):\n                            r = ' new Int16Array(%s)' %asize\n                        elif atype in ('ushort', 'uint16', 'ui16'):\n                            r = ' new Uint16Array(%s)' %asize\n                        elif atype in ('int', 'int32', 'i32'):\n                            r = ' new Int32Array(%s)' %asize\n                        elif atype in ('uint', 'uint32', 'ui32'):\n                            r = ' new Uint32Array(%s)' %asize\n                        elif atype in ('float', 'float32', 'f32'):\n                            r = ' new Float32Array(%s)' %asize\n                        elif atype in ('float64', 'f64', 'double'):\n                            r = ' new Float64Array(%s)' %asize\n                        else:\n                            raise SyntaxError(self.format_error('invalid type for fixed-size typed arrays: '+atype))\n\n                        if len(right):\n                            return '__array_fill__(%s, [%s])' %(r, ','.join(right))\n                        else:\n                            return r\n\n        if self._with_oo:\n            methodnames = {\n                '+': 'add',\n                '-': 'sub',\n                '*': 'mul',\n                '/': 'div',\n                '%': 'mod'\n            }\n            return '(%s.__%s__(%s))' % (left, methodnames[op], right)\n        elif op=='*' and isinstance(node.left, ast.Str):\n            return '(%s.__mul__(%s))' % (left, right)\n        else:\n            return '(%s %s %s)' % (left, op, right)\n\n\n    def visit_Return(self, node):\n        if isinstance(node.value, Tuple):\n            return 'return [%s];' % ', '.join(map(self.visit, node.value.elts))\n        if node.value:\n            return 'return %s;' % self.visit(node.value)\n        return 'return null;'\n\n    def visit_Pass(self, node):\n        return '/*pass*/'\n\n    def visit_Is(self, node):\n        return '==='\n\n    def visit_IsNot(self, node):\n        return '!=='\n\n\n    def visit_Compare(self, node):\n        #if isinstance(node.ops[0], ast.Eq):\n        #   left = self.visit(node.left)\n        #   right = self.visit(node.comparators[0])\n        #   if self._lua:\n        #       return '%s == %s' %(left, right)\n        #   elif self._fast_js:\n        #       return '(%s===%s)' %(left, right)\n        #   else:\n        #       return '(%s instanceof Array ? JSON.stringify(%s)==JSON.stringify(%s) : %s===%s)' %(left, left, right, left, right)\n        #elif isinstance(node.ops[0], ast.NotEq):\n        #   left = self.visit(node.left)\n        #   right = self.visit(node.comparators[0])\n        #   if self._lua:\n        #       return '%s ~= %s' %(left, right)\n        #   elif self._fast_js:\n        #       return '(%s!==%s)' %(left, right)\n        #   else:\n        #       return '(!(%s instanceof Array ? JSON.stringify(%s)==JSON.stringify(%s) : %s===%s))' %(left, left, right, left, right)\n        #       \n        #else:\n        comp = []\n        if isinstance( node.left, ast.BinOp ):\n            comp.append( '('+self.visit(node.left)+')' )\n        else:\n            comp.append( self.visit(node.left) )\n\n        for i in range( len(node.ops) ):\n            op = None\n            if isinstance(node.ops[i], ast.Eq):\n                op = '==='\n            elif isinstance(node.ops[i], ast.NotEq):\n                op = '!=='\n            else:\n                op = self.visit(node.ops[i])\n\n            comp.append( op )\n            right = node.comparators[i]\n\n            if op in ('===', '!==') and isinstance(right, ast.Name) and right.id=='undefined':\n                ## this fixes `if x is not undefined:`\n                ## the users expects above to work because this works: `if x.y is not undefined:`\n                comp[0] = 'typeof(%s)' %comp[0]\n                comp.append('\nundefined\n')\n\n            elif isinstance(node.comparators[i], ast.BinOp):\n                comp.append('(')\n                comp.append( self.visit(node.comparators[i]) )\n                comp.append(')')\n            else:\n                comp.append( self.visit(node.comparators[i]) )\n\n        return ' '.join( comp )\n\n\n    def visit_UnaryOp(self, node):\n        #return self.visit(node.op) + self.visit(node.operand)\n        return '%s (%s)' %(self.visit(node.op),self.visit(node.operand))\n\n\n    def visit_BoolOp(self, node):\n        op = self.visit(node.op)\n        return '('+ op.join( [self.visit(v) for v in node.values] ) +')'\n\n\n\n\n\nIf Test\n\n\n\n    def visit_If(self, node):\n        out = []\n        test = self.visit(node.test)\n        if self._runtime_type_checking and not isinstance(node.test, ast.Compare):\n            ## note in old-style-js `typeof(null)=='object'`,\n            ## so we need to check first that the test is not null.\n            ## this still works for functions, because `typeof(F)` is 'function'\n            #errmsg = 'if test not allowed directly on arrays, dicts, or objects. The correct syntax is: `if len(array)` or `if len(dict.keys())` or `if myob is not None`'\n            #out.append( 'if (%s!=null \n typeof(%s)==\nobject\n) {throw new RuntimeError(\n%s\n)}' %(test, test, errmsg))\n\n            errmsg = 'if test not allowed directly on arrays. The correct syntax is: `if len(array)` or `if array.length`'\n            out.append( 'if (%s instanceof Array) {throw new RuntimeError(\n%s\n)}' %(test, errmsg))\n\n            out.append( self.indent() + 'if (%s) {' %test )\n        else:\n            out.append( 'if (%s) {' %test )\n\n        self.push()\n\n        for line in list(map(self.visit, node.body)):\n            if line is None: continue\n            out.append( self.indent() + line )\n\n        orelse = []\n        for line in list(map(self.visit, node.orelse)):\n            orelse.append( self.indent() + line )\n\n        self.pull()\n\n        if orelse:\n            out.append( self.indent() + '} else {')\n            out.extend( orelse )\n\n        out.append( self.indent() + '}' )\n\n        return '\\n'.join( out )\n\n\n    def visit_Dict(self, node):\n        a = []\n        for i in range( len(node.keys) ):\n            k = self.visit( node.keys[ i ] )\n            v = self.visit( node.values[i] )\n            a.append( '%s:%s'%(k,v) )\n        b = ', '.join( a )\n        return '{ %s }' %b\n\n\n\n\n\nFor Loop\n\n\nwhen fast_loops is off much of python \nfor in something\n style of looping is lost.\n\n\n\n    def _visit_for_prep_iter_helper(self, node, out, iter_name, wrapped):\n        if not self._fast_loops or wrapped:\n            if typedpython.unicode_vars:\n                s = 'if (! (%s instanceof Array || typeof %s == \nstring\n || \ud835\udc70\ud835\udc94\ud835\udc7b\ud835\udc9a\ud835\udc91\ud835\udc86\ud835\udc85\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s) || \ud835\udc70\ud835\udc94\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s) )) { %s = __object_keys__(%s) }' %(iter_name, iter_name, iter_name, iter_name, iter_name, iter_name)\n            else:\n                s = 'if (! (%s instanceof Array || typeof %s == \nstring\n || __is_typed_array(%s) || __is_some_array(%s) )) { %s = __object_keys__(%s) }' %(iter_name, iter_name, iter_name, iter_name, iter_name, iter_name)\n\n            if len(out):\n                out.append( self.indent() + s )\n            else:\n                out.append( s )\n\n    def remap_to_subscript(self, number):  ## NOT USED FOR NOW\n        ## converts a regular number into a subscript number\n        ## too bad these subscripts are not in the valid unicode range.\n        s = str(number)\n        assert '.' not in s\n        remap = {\n            '0' : '\u2080',\n            '1' : '\u2081',\n            '2' : '\u2082',\n            '3' : '\u2083',\n            '4' : '\u2084',\n            '5' : '\u2085',\n            '6' : '\u2086',\n            '7' : '\u2087',\n            '8' : '\u2088',\n            '9' : '\u2089',\n        }\n\n        r = ''\n        for char in s:\n            r += remap[ char ]\n        return r\n\n\n    def visit_For(self, node):\n        self._fast_loops = False  ## if true breaks builtins that for loop on special `arguments`\n        ## TESTING fast loops always true, string iteration now requires `iter(s)` wrapped\n\n\n        target = node.target.id\n        iter = self.visit(node.iter) # iter is the python iterator\n        is_iter_wrapped = False\n        if iter.startswith('iter('):\n            is_iter_wrapped = True\n            iter = iter[5:-1]\n\n        out = []\n        body = []\n\n        if not typedpython.unicode_vars:\n            index = '__n%s' % self._iter_id\n        elif self._iter_id == 0:\n            index = '\ud835\udcf7'\n        else:\n            index = '\ud835\udcf7%s' % self._iter_id\n\n\n        ##if not self._fast_loops and not isinstance(node.iter, ast.Name):\n        ## note: above will fail with `for key in somedict:`, it can not\n        ## be simply assumed that if its a name, to use that name as the\n        ## iterator, because _visit_for_prep_iter_helper might break it,\n        ## by reassigning the original dict, to its keys (an array),\n        ## later code in the block will then fail when it expects a dict.\n        if not self._fast_loops or is_iter_wrapped:\n            if not typedpython.unicode_vars:\n                iname = '__iter%s' %self._iter_id\n            elif isinstance(node.iter, ast.Name):\n                iname = '\ud835\udd5a\ud835\udd65\ud835\udd56\ud835\udd63%s' %iter\n            elif self._iter_id:\n                iname = '\ud835\udd5a\ud835\udd65\ud835\udd56\ud835\udd63%s' %self._iter_id\n            else:\n                iname = '\ud835\udd5a\ud835\udd65\ud835\udd56\ud835\udd63'\n\n            out.append( 'var %s = %s;' % (iname, iter) )\n        else:\n            iname = iter\n\n        self._iter_id += 1\n\n        ## note this type of looping can break with _fast_loops on a dict,\n        ## because it reassigns the dict when looping over it\n        ## like this `for key in somedict:`, the only safe way\n        ## to loop with _fast_loops is `for key in somedict.keys():`\n        if iter.startswith('\ud835\udc72\ud835\udc86\ud835\udc9a\ud835\udc94'):\n            ## in theory we can optimize away using _visit_for_prep_iter_helper,\n            ## because we know almost for sure that the result of \ud835\udc72\ud835\udc86\ud835\udc9a\ud835\udc94\n            ## is going to be an array of keys; however, it could still be\n            ## a user defined class that is returning an object of something\n            ## other than an array.\n            ## the only safe way to omit _visit_for_prep_iter_helper is to check\n            ## if the user had statically typed the iterator variable as a dict.\n            pass\n\n        ## TESTING ##\n        self._visit_for_prep_iter_helper(node, out, iname, is_iter_wrapped)\n\n        if BLOCKIDS: out.append('/*BEGIN-FOR:%s*/' %iter)\n\n        if self._fast_loops and not is_iter_wrapped:\n\n            ## iteration over strings not allowed in javascript backend without wrapping with `iter(mystr)` in the loop,\n            ## example: `for char in iter(mystr)`\n            if self._runtime_type_checking:\n                out.append( self.indent() + 'if (typeof(%s)==\nstring\n) {throw new RuntimeError(\nstring iteration error:\\\\n  wrap the string with `iter()`:\\\\n  example `for c in iter(mystr)`.\\\\n\n);}' %iname )\n                #breaks:DOM and typedarrys##out.append( self.indent() + 'if (!(__is_some_array(%s)){throw new RuntimeError(\nArray iteration error:\\\\n  wrap the object with `iter()`:\\\\n  example `for ob in iter(iterable)`.\\\\n\n);}' %iname )\n                out.append( self.indent() + 'if (!(%s instanceof Array)){throw new RuntimeError(\nArray iteration error:\\\\n  wrap the object with `iter()`:\\\\n  example `for ob in iter(iterable)`.\\\\n\n);}' %iname )\n\n            out.append( self.indent() + 'var %s = %s.length-1;' %(index, iname) )\n            out.append( self.indent() + '%s.reverse();' %iname )            \n            out.append( self.indent() + 'while (%s.length \n %s+1) {' %(iname, index) )\n\n        else:\n            out.append( self.indent() + 'for (var %s = 0; %s \n %s.length; %s++) {' % (index, index, iname, index) )\n\n        self.push()\n\n        if hasattr(self, '_in_timeout') and self._in_timeout:\n            body.append(\n                self.indent() + 'if ( (new Date()).getTime() - __clk__ \n= %s )  { break; }' % self._timeout\n            )\n\n\n        body.append( self.indent() + 'var %s = %s[ %s ];' %(target, iname, index) )\n\n\n        for line in list(map(self.visit, node.body)):\n            body.append( self.indent() + line )\n\n        if self._fast_loops and not is_iter_wrapped:\n            body.append( self.indent() + '%s--;' %index)\n\n        self.pull()\n        out.extend( body )\n        if self._fast_loops and not is_iter_wrapped:\n            out.append( self.indent() + '} %s.reverse();' %iname )          \n        else:\n            out.append( self.indent() + '}' )\n\n\n        if BLOCKIDS: out.append( self.indent() + '/*END-FOR:%s*/' %self._fast_loops)\n\n        self._iter_id -= 1\n\n        return '\\n'.join( out )\n\n    def visit_Continue(self, node):\n        return 'continue'\n\n    def visit_Break(self, node):\n        return 'break;'\n\n\n\n\n\nRegenerate JS Runtime\n\n\nTODO: update and test generate new js runtimes\n\n\n\ndef generate_js_runtime( nodejs=False, nodejs_tornado=False, webworker_manager=False, debugger=False ):\n    ## note: RUSTHON_LIB_ROOT gets defined in the entry of rusthon.py\n    r = [\n        open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/pythonpythonjs.py'), 'rb').read(),\n        python_to_pythonjs(\n            open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_core.py'), 'rb').read(),\n            fast_javascript = True,\n            pure_javascript = False\n        )\n\n    ]\n\n    if debugger:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_debugger.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n\n    if nodejs:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_nodejs.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n    if nodejs_tornado:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/nodejs_tornado.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n    if webworker_manager:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_webworker.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n\n    builtins = translate_to_javascript(\n        '\\n'.join(r),\n        requirejs = False,\n        insert_runtime = False,\n        fast_javascript = True,\n        fast_loops = True,\n        runtime_checks = False\n    )\n    builtins += '\\n/*end-builtins*/\\n'\n    return builtins\n\n\n\n\n\nTranslate to Javascript\n\n\nhtml files can also be translated, it is parsed and checked for \nscript type=\"text/python\"\n\n\n\ndef translate_to_javascript(source, requirejs=True, insert_runtime=True, webworker=False, function_expressions=True, fast_javascript=False, fast_loops=False, runtime_checks=True, as_module=False):\n    if '--debug-inter' in sys.argv:\n        raise RuntimeError(source)\n    head = []\n    tail = []\n    script = False\n    osource = source\n    if source.strip().startswith('\nhtml'):\n        lines = source.splitlines()\n        for line in lines:\n            if line.strip().startswith('\nscript') and 'type=\ntext/python\n' in line:\n                head.append( '\nscript type=\ntext/javascript\n')\n                script = list()\n            elif line.strip() == '\n/script\n':\n                if type(script) is list:\n                    source = '\\n'.join(script)\n                    script = True\n                    tail.append( '\n/script\n')\n                elif script is True:\n                    tail.append( '\n/script\n')\n                else:\n                    head.append( '\n/script\n')\n\n            elif isinstance( script, list ):\n                script.append( line )\n\n            elif script is True:\n                tail.append( line )\n\n            else:\n                head.append( line )\n\n    try:\n        tree = ast.parse( source )\n        #raise SyntaxError(source)\n    except SyntaxError:\n        import traceback\n        err = traceback.format_exc()\n        sys.stderr.write( err )\n        sys.stderr.write( '\\n--------------error in second stage translation--------------\\n' )\n\n        lineno = 0\n        for line in err.splitlines():\n            if \nunknown\n in line:\n                lineno = int(line.split()[-1])\n\n\n        lines = source.splitlines()\n        if lineno \n 10:\n            for i in range(lineno-5, lineno+5):\n                sys.stderr.write( 'line %s-\n'%i )\n                sys.stderr.write( lines[i] )\n                if i==lineno-1:\n                    sys.stderr.write('  \nSyntaxError\n')\n                sys.stderr.write( '\\n' )\n\n        else:\n            sys.stderr.write( lines[lineno] )\n            sys.stderr.write( '\\n' )\n\n        if '--debug' in sys.argv:\n            sys.stderr.write( osource )\n            sys.stderr.write( '\\n' )\n\n        sys.exit(1)\n\n    gen = JSGenerator(\n        source = source,\n        requirejs=requirejs, \n        insert_runtime=insert_runtime, \n        webworker=webworker, \n        function_expressions=function_expressions,\n        fast_javascript = fast_javascript,\n        fast_loops      = fast_loops,\n        runtime_checks  = runtime_checks,\n        as_module = as_module\n    )\n    output = gen.visit(tree)\n\n    if head and not isinstance(output, dict):\n        head.append( output )\n        head.extend( tail )\n        output = '\\n'.join( head )\n\n    return output", 
            "title": "JavascriptTranslator"
        }, 
        {
            "location": "/jstranslator/#javascript-translator", 
            "text": "translates intermediate form into final javascript.\nThis is also subclassed by these other backends:   gotranslator.md    rusttranslator.md \n*  cpptranslator.md  notes:  the implementation of  spawn  is in  generatorbase.md   the builtin webworker pool spawn manager is in  builtins_core.py  # PythonJS to JavaScript Translator\n# by Amirouche Boubekki and Brett Hartshorn - copyright 2013\n# License:  New BSD \n\n## note this should be cleared after a full round of translation,\n## first the runtime is regenerated, and that is the first to populate\n## the unicode name mapping.\nUNICODE_NAME_MAP = {}\n\nfrom types import GeneratorType\nfrom ast import Str\nfrom ast import Name\nfrom ast import Tuple\nfrom ast import Attribute\nfrom ast import NodeVisitor\n\nBLOCKIDS = False\n\nclass SwapLambda( RuntimeError ):\n    def __init__(self, node):\n        self.node = node\n        RuntimeError.__init__(self)\n\nclass JSGenerator(NodeVisitorBase, GeneratorBase):\n    def __init__(self, source, requirejs=True, insert_runtime=True, webworker=False, function_expressions=True, fast_javascript=False, fast_loops=False, runtime_checks=True, as_module=False):\n        if not source:\n            raise RuntimeError('empty source string')\n        NodeVisitorBase.__init__(self, source)\n\n        self._memory = ['HEAP']  ## used by c++ backend\n        self._with_type = []\n        self._classes = {}\n        self.method_returns_multiple_subclasses = {} # class name : set\n        self._class_stack = []\n\n        self._v8 = '--v8-natives' in sys.argv\n        self._ES6 = {\n            'imports' : True\n        }\n        self._as_module = as_module\n        self._in_locals = False\n        self._unicode_name_map = UNICODE_NAME_MAP\n\n        self._iter_id = 0  ## used by for loops\n        self._in_try = False\n        self._runtime_type_checking = runtime_checks\n        self.macros = {}\n        self._sleeps = 0\n        self._has_channels = False\n        self._func_recv = 0\n        self._with_oo = False\n        self._fast_js = fast_javascript\n        self._fast_loops = fast_loops\n        self._func_expressions = function_expressions\n        self._indent = 0\n        self._global_functions = {}\n        self._function_stack = []\n        self._requirejs = requirejs\n        self._insert_runtime = insert_runtime\n        self._insert_nodejs_runtime = False\n        self._insert_nodejs_tornado = False\n        self._webworker = webworker\n        self._exports = set()\n        self._inline_lambda = False\n        self.catch_call = set()  ## subclasses can use this to catch special calls\n\n        self.special_decorators = set(['__typedef__', '__pyfunction__', 'expression'])\n\n        self._typed_vars = dict()\n\n        self._lua  = False\n        self._dart = False\n        self._go   = False\n        self._rust = False\n        self._cpp = False\n        self._cheader = []\n        self._cppheader = []\n        self._cpp_class_impl = []\n        self._match_stack = []       ## dicts of cases\n        self._rename_hacks = {}      ## used by c++ backend, to support `if isinstance`\n        self._globals = {}           ## name : type\n        self._called_functions = {}  ## name : number of calls", 
            "title": "Javascript Translator"
        }, 
        {
            "location": "/jstranslator/#reset", 
            "text": "reset()  needs to be called for multipass backends, that are dumb and run translation twice to gather info in two passes.  \n    def reset(self):\n        self._cheader = []\n        self._cppheader = []\n        self._cpp_class_impl = []\n        self._match_stack = []", 
            "title": "reset"
        }, 
        {
            "location": "/jstranslator/#class", 
            "text": "class is not implemented here for javascript, it gets translated ahead of time in  intermediateform.md  \n    def visit_ClassDef(self, node):\n        raise NotImplementedError(node)\n\n\n    def visit_Global(self, node):\n        return '/*globals: %s */' %','.join(node.names)\n\n    def visit_Assert(self, node):\n        return 'if (!(%s)) {throw new Error( assertion failed ); }' %self.visit(node.test)\n\n\n    def visit_Expr(self, node):\n\n        s = self.visit(node.value)\n        if s is None:\n            raise RuntimeError('GeneratorBase ExpressionError: %s' %node.value)\n\n        if s.strip() and not s.endswith(';'):\n            s += ';'\n\n        if s==';' or not s:\n            return ''\n        else:\n            if self._in_try or not self._runtime_type_checking:\n                return s\n            elif not len(self._function_stack) or s.startswith('var '):\n                return s\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='inline':\n                if typedpython.needs_escape(s):raise RuntimeError(s)\n                return s\n\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='sleep':\n                assert self._stack[-1] is node\n                if len(self._stack)   3:\n                    raise SyntaxError('the builtin `sleep` can not be used at the global level outside of a function.')\n                elif isinstance(self._stack[-2], ast.If):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not under an `if` block.')\n                elif isinstance(self._stack[-2], ast.For):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not inside a `for` loop.')\n                elif isinstance(self._stack[-2], ast.While):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not inside a `for` or `while` loop.')\n                elif not isinstance(self._stack[-2], ast.FunctionDef):\n                    raise SyntaxError('the builtin `sleep` can only be used in the function body, and not nested under any blocks.')\n                return s\n            else:\n                ## note `debugger` is a special statement in javascript that sets a break point if the js console debugger is open ##\n                do_try = True\n                caller = self._function_stack[-1].name\n                called = None\n                if isinstance(node.value, ast.Call):\n                    called = self.visit(node.value.func)\n                    if isinstance(node.value.func, ast.Name) and node.value.func.id=='new':\n                        do_try = False\n                elif isinstance(node.value, ast.Attribute):\n                    do_try = False\n\n                if not do_try:\n                    return s\n                else:\n                    a = '/***/ try {\\n'\n                    a += self.indent() + s + '\\n'\n                    if typedpython.unicode_vars:\n                        if called:\n                            a += self.indent() + '/***/ } catch (__err) { if (\ud835\uddd7\ud835\uddf2\ud835\uddef\ud835\ude02\ud835\uddf4\ud835\uddf4\ud835\uddf2\ud835\uddff.onerror(__err, %s, %s)==true){debugger;}else{throw __err;} };' %(caller, called)\n                        else:\n                            a += self.indent() + '/***/ } catch (__err) { if (\ud835\uddd7\ud835\uddf2\ud835\uddef\ud835\ude02\ud835\uddf4\ud835\uddf4\ud835\uddf2\ud835\uddff.onerror(__err, %s)==true){debugger;}else{throw __err;} };' %caller\n                    else:\n                        if called:\n                                a += self.indent() + '/***/ } catch (__err) { if (__debugger__.onerror(__err, %s, %s)==true){debugger;}else{throw __err;} };' %(caller, called)\n                        else:\n                            a += self.indent() + '/***/ } catch (__err) { if (__debugger__.onerror(__err, %s)==true){debugger;}else{throw __err;} };' %caller\n\n                    return a\n\n\n    def visit_Assign(self, node):\n        target = node.targets[0]\n        isname = isinstance(target, ast.Name)\n\n        if isinstance(target, Tuple):\n            raise NotImplementedError('target tuple assignment should have been transformed to flat assignment by python_to_pythonjs.py')\n        else:\n            value = self.visit(node.value)\n\n            if self._runtime_type_checking and isinstance(target, ast.Subscript):\n                tar = self.visit(target.value)\n                key = self.visit(target.slice)\n                a = [\n                    'if (%s.__setitem__) { %s.__setitem__(%s, %s) }' %(tar,tar,key,value),\n                    self.indent() + 'else { %s = %s }' %(self.visit(target), value)\n                ]\n                return '\\n'.join(a)\n\n            else:\n                target = self.visit(target)\n\n\n            if self._requirejs and target not in self._exports and self._indent == 0 and '.' not in target:\n                self._exports.add( target )\n\n\n\n            ########################################\n            if value.startswith('\u2ca2\u2c91\u2c91\u2c92.send('):\n                if target=='this':  ## should assert that this is on the webworker side\n                    target = 'this.__uid__'\n                    value = value.replace('\u2ca2\u2c91\u2c91\u2c92.send(', 'self.postMessage(')\n                code = value % target\n            elif value.startswith('\u2ca2\u2c91\u2c91\u2c92.recv') or value.startswith('\u2ca2\u2c91\u2c91\u2c92.get') or value.startswith('\u2ca2\u2c91\u2c91\u2c92.call'):\n                self._func_recv += 1\n                self.push()\n                code = value % target\n            else:\n                if isname and len(self._function_stack):\n                    if self._runtime_type_checking or hasattr(self._function_stack[-1],'has_locals') or self._in_locals: \n                        #target = '%s.locals.%s=%s' %(self._function_stack[-1].name, target, target)\n                        #target = 'arguments.callee.locals.%s=%s' %(target, target)  ## breaks with multiple sleeps\n                        target = '\u0192.locals.%s=%s' %(target, target)\n\n\n                code = '%s = %s;' % (target, value)\n\n            if self._v8 and isname and len(self._function_stack) and self._runtime_type_checking:\n                code += 'if ('+target+'   typeof('+target+')== object    ! %HasFastProperties(' + target + ')) console.log( V8::WARN-SLOW-PROPS- %s );'%target\n\n            return code\n\n    def visit_AugAssign(self, node):\n        methodnames = {\n            '+': 'add',\n            '-': 'sub',\n            '*': 'mul',\n            '/': 'div',\n            '%': 'mod'\n        }\n\n\n        ## n++ and n-- are slightly faster than n+=1 and n-=1\n        target = self.visit(node.target)\n        op = self.visit(node.op)\n        value = self.visit(node.value)\n        if op=='+' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s ++;' %target\n        elif op=='-' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s --;' %target\n        elif op=='+' and isinstance(node.value, ast.Num):\n            a = '%s %s= %s;' %(target, op, value)  ## direct\n        elif op == '+' and not self._go:\n            if self._with_oo:\n                ## supports += syntax for arrays ##\n                if typedpython.unicode_vars:\n                    x = [\n                        'if (%s instanceof Array || \ud835\udc70\ud835\udc94\ud835\udc7b\ud835\udc9a\ud835\udc91\ud835\udc86\ud835\udc85\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s)) { %s.extend(%s); }' %(target,target,target, value),\n                        self.indent() + 'else if (%s.__iadd__) { %s.__iadd__(%s); }' %(target,target, value),\n                        self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n                    ]\n                else:\n                    x = [\n                        'if (%s instanceof Array || __is_typed_array(%s)) { %s.extend(%s); }' %(target,target,target, value),\n                        self.indent() + 'else if (%s.__iadd__) { %s.__iadd__(%s); }' %(target,target, value),\n                        self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n                    ]\n                a = '\\n'.join(x)\n            elif self._runtime_type_checking:\n                if typedpython.unicode_vars:\n                    x = [\n                        'if (%s instanceof Array || \ud835\udc70\ud835\udc94\ud835\udc7b\ud835\udc9a\ud835\udc91\ud835\udc86\ud835\udc85\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s)) { throw new RuntimeError( Array += Array is not allowed without operator overloading ); }' %(target,target),\n                        self.indent() + '%s %s= %s;'%(target, op, value)\n                    ]\n                else:\n                    x = [\n                        'if (%s instanceof Array || __is_typed_array(%s)) { throw new RuntimeError( Array += Array is not allowed without operator overloading ); }' %(target,target),\n                        self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n                    ]\n                a = '\\n'.join(x)\n            else:\n                a = '%s %s= %s;' %(target, op, value)  ## direct\n\n        elif op in methodnames.keys() and self._with_oo and not self._go:\n            m = methodnames[op]\n            x = [\n                'if (%s.__i%s__) { %s.__i%s__(%s) }' %(target,m, target,m, value),\n                self.indent() + 'else { %s %s= %s; }'%(target, op, value)\n            ]\n            a = '\\n'.join(x)\n\n        else:\n            a = '%s %s= %s;' %(target, op, value)  ## direct\n\n\n        return a", 
            "title": "Class"
        }, 
        {
            "location": "/jstranslator/#requirejs", 
            "text": "generate a generic or requirejs module.      def _new_module(self, name='main.js'):\n        header = []\n        if self._requirejs and not self._webworker:\n            header.extend([\n                'define( function(){',\n                '__module__ = {}'\n            ])\n        elif self._ES6['imports'] and self._as_module:\n            header.append('module  %s  {' %name)\n\n\n        return {\n            'name'   : name,\n            'header' : header,\n            'lines'  : []\n        }", 
            "title": "RequireJS"
        }, 
        {
            "location": "/jstranslator/#module", 
            "text": "top level the module, this builds the output and returns the javascript string translation  \n    def _check_for_unicode_decorator(self, node):\n        if isinstance(node, ast.FunctionDef):\n            for decor in node.decorator_list:\n                if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'unicode':\n                    assert len(decor.args)==1\n                    self._unicode_name_map[ node.name ] = decor.args[0].s\n\n\n    def _importfrom_helper(self, node):\n        if node.module=='nodejs':\n            self._insert_nodejs_runtime = True\n        elif node.module=='nodejs.tornado':\n            self._insert_nodejs_tornado = True\n        else:\n            inames = [ n.name for n in node.names ]\n            return 'import {%s} from  %s ;' %(','.join(inames), node.module)\n\n        return ''\n\n    def visit_Import(self, node):\n        rapydlibs = {\n            'math': '/lib/node_modules/rapydscript/src/lib/math.pyj',\n            'random': '/lib/node_modules/rapydscript/src/lib/random.pyj',\n            're': '/lib/node_modules/rapydscript/src/lib/re.pyj',\n            'operator': '/lib/node_modules/rapydscript/src/lib/operator.pyj',\n        }\n        res = []\n        for alias in node.names:\n            alias.name = alias.name.replace('__SLASH__', '/').replace('__DASH__', '-')\n            if alias.name in rapydlibs.keys():\n                pyj = rapydlibs[ alias.name ]\n                if not os.path.isfile(pyj):\n                    raise RuntimeError('can not find rapydscript stdlib source: %s' %pyj)\n\n                tmpjs = tempfile.gettempdir() + '/rapyd-output.js'\n                subprocess.check_call(['rapydscript', pyj, '--bare', '--prettify', '--output', tmpjs])\n                rapydata = open(tmpjs,'rb').read()\n                #raise RuntimeError(rapydata)\n                #res.append(rapydata)\n                in_mod = False\n                in_private = False\n                head  = []\n                body = []\n                tail = []\n                funcnames = set()\n                for line in rapydata.splitlines():\n                    if line.strip()=='var __name__ =  __main__ ;':  ## hackish way to split head and module body\n                        in_mod = True\n                        body.append('var %s = {' %alias.name)\n                    elif in_mod:\n                        if line.startswith('_$'):\n                            in_private = True\n                        helpercall = False\n                        for fname in funcnames:\n                            if line.startswith(fname) and '(' in line and ')' in line and line.endswith(';'):\n                                helpercall = True\n                        #########################\n                        if helpercall:\n                            tail.append('%s.%s' %(alias.name, line))\n                        elif in_private:\n                            head.append(line)\n                            if line=='};':\n                                in_private = False\n                        else:\n                            if line.startswith('function '):\n                                fname = line.split()[1].split('(')[0]\n                                funcnames.add( fname )\n                                line = '%s : %s' %(fname,line)\n                            elif line == '}':  ## end of function\n                                line += ','\n                            elif line.strip() and line[0]!=' ' and line[-1]==';' and '=' in line:\n                                #vname = line.split('=')[0].strip()\n                                line = line.replace('=', ':').replace(';', ',')\n\n                            ## very hackish\n                            if line.startswith(' '):\n                                hacks = set()\n                                for word in line.split():\n                                    if '(' not in word:\n                                        continue\n                                    word = word.split('(')[0]\n                                    for fname in funcnames:\n                                        if word == fname:\n                                            hacks.add(fname)\n                                for fname in hacks:\n                                    line = line.replace(fname, '%s.%s'%(alias.name,fname))\n\n                            body.append(line)\n                    else:\n                        head.append(line)\n                body.append('};')  ## end of module\n                res.extend(head)\n                res.extend(body)\n                res.extend(tail)\n\n            elif alias.asname:\n                res.append(\n                     var %s = require('%s');  %(alias.asname, alias.name)\n                )\n            else:\n                res.append(\n                     var %s = require('%s');  %(alias.name, alias.name)\n                )\n\n        if res:\n            return '\\n'.join(res)\n        else:\n            return ''\n\n    def visit_Module(self, node):\n        modules = []\n\n        mod = self._new_module()\n        modules.append( mod )\n        lines = mod['lines']\n        header = mod['header']\n\n        if self._v8:\n            #header.append('console.log( V8::Version );')\n            #header.append('console.log(%GetV8Version());')\n            #header.append('console.log( V8::Heap );')\n            #header.append('console.log(%GetHeapUsage());')\n            header.append('var v8 = function v8(fn) {return %OptimizeFunctionOnNextCall(fn);};')\n            header.append('v8.gc = function v8_gc() {return %CollectGarbage(null);};')\n\n        ## first check for all the @unicode decorators,\n        ## also check for special imports like `from runtime import *`\n        for b in node.body:\n            if typedpython.unicode_vars:\n                self._check_for_unicode_decorator(b)\n\n            if isinstance(b, ast.ImportFrom):\n                line = self.visit(b)\n                if line:\n                    ## ES6 imports\n                    header.append(line)\n\n\n\n        for b in node.body:\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Call) and isinstance(b.value.func, ast.Name) and b.value.func.id == '__new_module__':\n                mod = self._new_module( '%s.js' %b.value.args[0].id )\n                modules.append( mod )\n                lines = mod['lines']\n                header = mod['header']\n\n            else:\n                line = self.visit(b)\n                if line: lines.append( line )\n\n\n        if self._insert_runtime:\n            ## always regenerate the runtime, in case the user wants to hack it ##\n            runtime = generate_js_runtime(\n                nodejs         = self._insert_nodejs_runtime,\n                nodejs_tornado = self._insert_nodejs_tornado,\n                webworker_manager = self._has_channels and not self._webworker,\n                debugger = self._runtime_type_checking\n            )\n            lines.insert( 0, runtime )\n        else:\n            lines.insert( 0, 'var __$UID$__=0;')\n\n\n        #if self._has_channels and not self._webworker:\n        #   #lines.insert( 0, 'var __workerpool__ = new __WorkerPool__(__workersrc__, __workerimports__);')\n        #   # moved to intermediateform.md\n        #   pass\n\n        ######################### modules ####################\n        if self._requirejs and not self._webworker:\n            for name in self._exports:\n                if name.startswith('__'): continue\n                lines.append( '__module__.%s = %s' %(name,name))\n            lines.append( 'return __module__')\n            lines.append('}) //end requirejs define')\n\n        elif self._ES6['imports'] and self._as_module:\n            lines.append('} // end ES6 module')\n\n\n        if len(modules) == 1:\n            lines = header + lines\n            ## fixed by Foxboron\n            return '\\n'.join(l if isinstance(l,str) else l.encode( utf-8 ) for l in lines)\n        else:\n            d = {}\n            for mod in modules:\n                lines = mod['header'] + mod['lines']\n                d[ mod['name'] ] = '\\n'.join(l if isinstance(l,str) else l.encode( utf-8 ) for l in lines)\n            return d", 
            "title": "Module"
        }, 
        {
            "location": "/jstranslator/#in", 
            "text": "note a  in  test in javascript is very different from the way python normally works,\nfor example  0 in [1,2,3]  is true in javascript, while it is false in python,\nthis is because an  in  test on an array in javascript checks the indices, not the values,\nwhile in python it works by testing if the value is in the array.\nDepending on the options given in the first stage of translation  intermediateform.md , in  tests will be replaced with a function call to  __contains__  which implements the python style logic.\nHowever, in some cases an  in  test is still generated at here in the final stage of translation.  \n    def visit_In(self, node):\n        return ' in '", 
            "title": "In"
        }, 
        {
            "location": "/jstranslator/#tryexcept-and-raise", 
            "text": "TODO  finnally  for the javascript backend   \n    def visit_TryExcept(self, node):\n        self._in_try = True\n        out = []\n        out.append( self.indent() + 'try {' )\n        self.push()\n        out.extend(\n            list( map(self.visit, node.body) )\n        )\n        self.pull()\n        out.append( self.indent() + '} catch(__exception__) {' )\n        self.push()\n        out.extend(\n            list( map(self.visit, node.handlers) )\n        )\n        self.pull()\n        out.append( '}' )\n        self._in_try = False\n        return '\\n'.join( out )\n\n    def visit_Raise(self, node):\n        ## TODO - when re-raising an error, it fails because it is an Error object\n        ## TODO - inject some code here to check the type at runtime.\n        return 'throw new %s;' % self.visit(node.type)\n\n    def visit_ExceptHandler(self, node):\n        out = ''\n        if node.type:\n            out = 'if (__exception__ == %s || __exception__ instanceof %s) {\\n' % (self.visit(node.type), self.visit(node.type))\n        if node.name:\n            out += 'var %s = __exception__;\\n' % self.visit(node.name)\n        out += '\\n'.join(map(self.visit, node.body)) + '\\n'\n        if node.type:\n            out += '}\\n'\n        return out", 
            "title": "Try/Except and Raise"
        }, 
        {
            "location": "/jstranslator/#yield", 
            "text": "note yield is new in javascript, and works slightly different from python, ie.\nyielding is not cooperative, calling  some_function_that_also_yields()  inside\na function that is already using yield will not co-op yield.  \n    def visit_Yield(self, node):\n        return 'yield %s' % self.visit(node.value)\n\n    def visit_Lambda(self, node):\n        args = [self.visit(a) for a in node.args.args]\n        if args and args[0]=='__INLINE_FUNCTION__':\n            self._inline_lambda = True\n            #return ' LambdaError '   ## skip node, the next function contains the real def\n            raise SwapLambda( node )\n        else:\n            return '(function (%s) {return %s;})' %(','.join(args), self.visit(node.body))", 
            "title": "Yield"
        }, 
        {
            "location": "/jstranslator/#functionmethods", 
            "text": "note:  visit_Function  after doing some setup, calls  _visit_function  that subclasses overload.  \n    def _visit_function(self, node):\n        if node.name == '__DOLLAR__':\n            node.name = '$'\n\n        if typedpython.unicode_vars and typedpython.needs_escape(node.name):\n            node.name = typedpython.escape_text(node.name)\n        if node.name=='__right_arrow__' and len(self._function_stack)==1:\n            node.name = '\u1405'\n\n        comments = []\n        body = []\n        is_main = node.name == 'main'\n        is_annon = node.name == ''\n        is_pyfunc    = False\n        is_prototype = False\n        is_debugger  = False\n        is_redef     = False\n        is_locals    = False\n        is_staticmeth= False\n        is_getter    = False\n        is_setter    = False\n        is_unicode   = False\n        is_v8        = False\n        bind_to      = None\n        bind_to_this = None\n        protoname    = None\n        func_expr    = False  ## function expressions `var a = function()` are not hoisted\n        func_expr_var = True  ## this should always be true, was this false before for hacking nodejs namespace?\n        returns = None\n\n        ## decorator specials ##\n        ## note: only args_typedefs is used for now in the js backend ##\n        options = {'getter':False, 'setter':False, 'returns':None, 'returns_self':False, 'generic_base_class':None, 'classmethod':False}\n        args_typedefs = {}\n        chan_args_typedefs = {}\n        generics = set()\n        args_generics = dict()\n        func_pointers = set()\n        arrays = dict()\n        has_timeout = None\n        timeout_seconds = None\n        ########################\n        decorators = []\n        for decor in node.decorator_list:\n\n            ##note: `_visit_decorator` is defined in generatorbase.md\n            self._visit_decorator(\n                decor,\n                node=node,\n                options=options,\n                args_typedefs=args_typedefs,\n                chan_args_typedefs=chan_args_typedefs,\n                generics=generics,\n                args_generics=args_generics,\n                func_pointers=func_pointers,\n                arrays = arrays,\n            )\n\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'expression':\n                assert len(decor.args)==1\n                func_expr = True\n                func_expr_var = isinstance(decor.args[0], ast.Name)\n                node.name = self.visit(decor.args[0])\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'timeout':\n                has_timeout = True\n                timeout_seconds = decor.args[0].n\n                if decor.keywords:\n                    raise RuntimeError(decor.keywords)\n                elif len(decor.args) 1 and isinstance(decor.args[1], ast.Dict):\n                    if isinstance(decor.args[1].keys[0], ast.Name) and decor.args[1].keys[0].id=='loop':\n                        dval = self.visit(decor.args[1].values[0])\n                        if dval=='true' or dval == 'True' or dval == 1:\n                            has_timeout = 'INTERVAL'\n                    else:\n                        raise SyntaxError(self.format_error('invalid option to @timeout decorator'))\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'unicode':\n                if typedpython.unicode_vars:\n                    assert len(decor.args)==1\n                    is_unicode = True\n                    node.name = decor.args[0].s\n\n            elif isinstance(decor, ast.Name) and decor.id == 'v8':\n                is_v8 = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'getter':\n                is_getter = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'setter':\n                is_setter = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'staticmethod':\n                is_staticmeth = True\n\n            elif isinstance(decor, ast.Name) and decor.id == 'debugger':\n                is_debugger = True\n            elif isinstance(decor, ast.Name) and decor.id == 'redef':\n                is_redef = True\n                is_locals = True\n                node.has_locals = True\n                self._in_locals = True\n            elif isinstance(decor, ast.Name) and decor.id == 'locals':\n                is_locals = True\n                node.has_locals = True\n                self._in_locals = True\n\n            elif isinstance(decor, ast.Name) and decor.id == '__pyfunction__':\n                is_pyfunc = True\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef__':\n                pass\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__prototype__':\n                assert len(decor.args)==1\n                is_prototype = True\n                protoname = decor.args[0].id\n                if typedpython.needs_escape(protoname):\n                    protoname = typedpython.escape_text(protoname)\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'returns':\n                returns = decor.args[0].id\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'bind':\n                assert len(decor.args) =2\n                bind_to = self.visit(decor.args[0])\n                if len(decor.args)==2:\n                    bind_to_this = self.visit(decor.args[1])\n            else:\n                decorators.append( self.visit(decor)+'(' )\n\n        dechead = ''.join(decorators)\n        dectail = ')' * len(decorators)\n        if has_timeout:\n            if has_timeout=='INTERVAL':\n                dechead = '__set_interval('+dechead\n                dectail += ', %s)' %(timeout_seconds)\n            else:\n                dechead = '__set_timeout('+dechead\n                dectail += ', %s)' %(timeout_seconds)\n\n        args = self.visit(node.args)\n        funcname = node.name\n\n\n        #if len(self._function_stack) == 1:\n        #   self._iter_id = 0\n\n        if is_prototype:\n            funcname = '%s_%s' %(protoname, node.name)\n            if is_debugger:\n                raise SyntaxError('@debugger is not allowed on methods: %s.%s' %(protoname, node.name))\n            if bind_to:\n                raise SyntaxError('@bind is not allowed on methods: %s.%s' %(protoname, node.name))\n\n            if is_getter:\n                assert len(args)==0\n                funcname = '__getter__' + funcname\n                fdef = '%s function %s(%s)' % (dechead, funcname, ', '.join(args))\n            elif is_setter:\n                funcname = '__setter__' + funcname\n                fdef = '%s function %s(%s)' % (dechead, funcname, ', '.join(args))\n\n            elif is_staticmeth:\n                fdef = '%s.%s = %s function %s(%s)' % (protoname, node.name, dechead, funcname, ', '.join(args))\n            else:\n                fdef = '%s.prototype.%s = %s function %s(%s)' % (protoname, node.name, dechead, funcname, ', '.join(args))\n\n        elif len(self._function_stack) == 1:\n            ## note: var should always be used with function expressions.\n\n            if self._func_expressions or func_expr:\n                if is_debugger:\n                    ## first open devtools then wait two seconds and then run function  ##\n                    d = [\n                        'var %s = function debugger_entrypoint_%s() {' %(node.name, node.name),\n                        '   /***/ var __entryargs__ = arguments;',\n                        '   /***/ try {var __win = require( nw.gui ).Window.get(); __win.showDevTools(); __win.focus(); __win.moveTo(10,0);} catch (__err) {};',\n                        '   setTimeout(function(){%s_wrapped(__entryargs__)}, 2000);' %node.name,\n                        '   var %s_wrapped = function %s_wrapped(%s)' % (node.name, node.name, ', '.join(args)),  ## scope lifted ok here\n                    ]\n                    fdef = '\\n'.join(d)\n                    self.push()\n                elif bind_to:\n                    if bind_to_this:\n                        fdef = '%s = %s (function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                    else:\n                        fdef = '%s = %s function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                else:\n                    fdef = 'var %s = %s function %s(%s)' % (node.name,dechead, node.name,  ', '.join(args))\n\n            else:  ## scope lifted functions are not safe ##\n                fdef = 'function %s(%s)' % (node.name, ', '.join(args))\n\n\n            if self._requirejs and node.name not in self._exports:\n                self._exports.add( node.name )\n\n        else:\n            if is_debugger:\n                raise SyntaxError('the decorator `@debugger` is only used on top level functions in the global namespace')\n\n            if self._func_expressions or func_expr:\n                if bind_to:\n                    if bind_to_this:\n                        fdef = '%s = %s (function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                    else:\n                        fdef = '%s = %s function %s(%s)' % (bind_to,dechead, node.name,  ', '.join(args))\n                else:\n                    fdef = 'var %s = %s function %s(%s)' % (node.name,dechead, node.name,  ', '.join(args))\n\n            else: ## scope lifted functions are not safe ##\n                fdef = 'function %s(%s)' % (node.name, ', '.join(args))\n\n        if BLOCKIDS:\n            if is_prototype or (bind_to and '.prototype.' in bind_to):\n                body.append( '/*BEGIN-METH:%s*/' %id(node))\n            else:\n                body.append( '/*BEGIN-FUNC:%s*/' %id(node))\n\n        body.append( self.indent() + fdef + '{' )\n        #body.append( self.indent() + '{' )\n\n        self.push()\n\n        if self._runtime_type_checking or is_redef:\n            ## doing the recompile and eval inside the function itself allows it to pick\n            ## up any variables from the outer scope if it is a nested function.\n            ## note: the user calls `myfunc.redefine(src)` and then on next call it is recompiled.\n            body.append('/***/var \u0192 = arguments.callee;')\n            body.append(\n                '/***/ if (%s.__recompile !== undefined) { eval( %s.__redef= +%s.__recompile); %s.__recompile=undefined; };' %(funcname, funcname, funcname, funcname)\n            )\n            body.append(\n                '/***/ if (%s.__redef !== undefined) { return %s.__redef.apply(this,arguments); };' %(funcname, funcname)\n            )\n\n        if self._v8 and is_v8:\n            body.append(\n                '/***/ if (!%s.optimized) { '%funcname + '%OptimizeFunctionOnNextCall(' + '%s);%s.optimized=true;};'%(funcname,funcname)\n            )\n\n        if node.args.vararg:\n            body.append('var %s = Array.prototype.splice.call(arguments,%s, arguments.length);' %(node.args.vararg, len(node.args.args)) )\n\n        next = None  ## deprecated?\n\n        for i,child in enumerate(node.body):\n            if isinstance(child, Str) or hasattr(child, 'SKIP'):  ## TODO check where the SKIP hack is coming from\n                continue\n            elif isinstance(child, ast.Expr) and isinstance(child.value, ast.Str):\n                comments.append('/* %s */' %child.value.s.strip() )\n                continue\n\n\n            v = self.try_and_catch_swap_lambda(child, node.body)\n\n            if v is None:\n                msg = 'error in function: %s'%node.name\n                msg += '\\n%s' %child\n                raise SyntaxError(msg)\n            elif v.strip():\n                body.append( self.indent()+v)\n\n        ## todo fix when sleep comes before channel async _func_recv, should be a stack of ['}', '});']\n        if self._sleeps:\n            body.append( '}/*end-sleep*/' * self._sleeps)\n            #body.append( '__sleep__%s.locals={};' % self._sleeps)  ## breaks on multiple sleeps\n            self._sleeps = 0\n\n        if self._func_recv:\n            while self._func_recv:  ## closes nested generated callbacks\n                self.pull()\n                body.append( self.indent() + '});/*end-async*/' )\n                self._func_recv -= 1\n\n        ## end of function ##\n        self.pull()\n        body.append( self.indent() + '}/*end-   `%s`    */' %node.name)\n\n        if bind_to_this:\n            body.append( self.indent() + ').bind(%s);' %bind_to_this)\n\n        if BLOCKIDS:\n            if is_prototype or (bind_to and '.prototype.' in bind_to):\n                body.append( '/*END-METH:%s*/' %id(node))\n            else:\n                body.append( '/*END-FUNC:%s*/' %id(node))\n\n        if is_debugger:\n            body.append( self.indent()+ '%s_wrapped.locals={}; /*wrapped entry point*/' %node.name )\n            self.pull()\n            body.append( '} /*debugger*/' )\n\n        if dectail:\n            body.append(dectail + ';/*end-decorators*/')\n\n        if is_getter:\n            #gtemplate = 'Object.defineProperty(%s.prototype,  %s , {get:%s, enumerable:false, writable:false, configurable:false});'\n            gtemplate = 'Object.defineProperty(%s.prototype,  %s , {get:%s, configurable:true});'\n            body.append( gtemplate%(protoname,node.name, funcname))\n        elif is_setter:\n            ## assume that there is a getter\n            getterfunc = funcname.replace('__setter__', '__getter__')\n            #stemplate = 'Object.defineProperty(%s.prototype,  %s , {get:%s, set:%s, enumerable:false, writable:false, configurable:true});'\n            stemplate = 'Object.defineProperty(%s.prototype,  %s , {get:%s, set:%s, configurable:true});'\n            body.append( stemplate%(protoname,node.name, getterfunc, funcname))\n\n        if self._runtime_type_checking or is_locals or self._in_locals:\n            if is_prototype:\n                body.append(\n                    '%s.prototype.%s.locals = {};' % (protoname, node.name)\n                )\n            else:\n                body.append('%s.locals={};'%node.name)\n                if len(self._function_stack) 1:\n                    body.append('arguments.callee.locals.%s=%s'%(node.name, node.name))\n\n        ## below is used for runtime type checking ##\n        if returns:\n            if is_prototype:\n                body.append(\n                    '%s.prototype.%s.returns =  %s ;' % (protoname, node.name, returns)\n                )\n            else:\n                body.append( node.name + '.returns =  %s ;' %returns )\n\n        _func_typed_args = []\n        for arg in node.args.args:\n            if arg.id in args_typedefs:\n                argtype = args_typedefs[arg.id]\n                if argtype.startswith('__arg_map__'):\n                    argtype = argtype.split(' ')[1]\n                _func_typed_args.append( argtype )\n\n        if _func_typed_args:\n            targs = ','.join( [' %s '%t for t in _func_typed_args] )\n            if is_prototype:\n                body.append(\n                    '%s.prototype.%s.args = [%s];' % (protoname, node.name, targs)\n                )\n            else:\n                body.append( node.name + '.args = [%s];' %targs )\n\n        if is_locals:\n            self._in_locals = False\n\n        buffer = '\\n'.join( comments + body )\n        buffer += '\\n'\n        return self.indent() + buffer\n\n    def try_and_catch_swap_lambda(self, child, body):\n        try:\n            return self.visit(child)\n        except SwapLambda as e:\n\n            next = None\n            for i in range( body.index(child), len(body) ):\n                n = body[ i ]\n                if isinstance(n, ast.FunctionDef):\n                    if hasattr(n, 'SKIP'):\n                        continue\n                    else:\n                        next = n\n                        break\n            assert next\n            next.SKIP = True\n            e.node.__class__ = ast.FunctionDef\n            e.node.__dict__ = next.__dict__\n            e.node.name = ''\n            return self.try_and_catch_swap_lambda( child, body )\n\n\n    def _visit_subscript_ellipsis(self, node):\n        name = self.visit(node.value)\n        raise SyntaxError('ellipsis slice is deprecated in the javascript backend')\n        return '%s[ $wrapped ]' %name\n\n\n    def visit_Slice(self, node):\n        raise SyntaxError('list slice')  ## slicing not allowed here at js level\n\n    def visit_arguments(self, node):\n        out = []\n        for name in [self.visit(arg) for arg in node.args]:\n            out.append(name)\n        return out\n\n    def visit_Name(self, node):\n        escape_hack_start = '__x0s0x__'\n        escape_hack_end = '__x0e0x__'\n\n        if node.id == 'None':\n            return 'null'\n        elif node.id == 'True':\n            return 'true'\n        elif node.id == 'False':\n            return 'false'\n        elif node.id == 'null':\n            return 'null'\n        elif node.id == '__DOLLAR__':\n            return '$'\n        elif node.id == 'debugger':  ## keyword in javascript\n            if typedpython.unicode_vars:\n                return '\ud835\uddd7\ud835\uddf2\ud835\uddef\ud835\ude02\ud835\uddf4\ud835\uddf4\ud835\uddf2\ud835\uddff'\n            else:\n                return '__debugger__'\n\n        elif node.id in self._unicode_name_map:  # from @unicode decorators\n            return self._unicode_name_map[node.id]\n\n        elif escape_hack_start in node.id:\n            #assert typedpython.unicode_vars\n            parts = []\n            for p in node.id.split(escape_hack_start):\n                if escape_hack_end in p:\n                    id = int(p.split(escape_hack_end)[0].strip())\n                    if id not in UnicodeEscapeMap.keys():\n                        raise RuntimeError('id not in UnicodeEscapeMap')\n                    uchar = UnicodeEscapeMap[ id ]\n                    parts.append(uchar)\n                else:\n                    parts.append(p)\n            res = ''.join(parts)\n            return res.encode('utf-8')\n        else:\n            return node.id\n\n    def visit_Attribute(self, node):\n        name = self.visit(node.value)\n        attr = node.attr\n\n        if typedpython.needs_escape(attr):\n            attr = typedpython.escape_text(attr)\n\n        return '%s.%s' % (name, attr)\n\n    def visit_Print(self, node):\n        args = [self.visit(e) for e in node.values]\n        if typedpython.unicode_vars:\n            s = '\ud835\udc77\ud835\udc93\ud835\udc8a\ud835\udc8f\ud835\udc95(%s);' % ', '.join(args)\n        else:\n            s = 'console.log(%s);' % ', '.join(args)\n        return s\n\n    def visit_keyword(self, node):\n        if isinstance(node.arg, basestring):\n            return node.arg, self.visit(node.value)\n        return self.visit(node.arg), self.visit(node.value)", 
            "title": "Function/Methods"
        }, 
        {
            "location": "/jstranslator/#call-helper", 
            "text": "def _visit_call_helper(self, node):\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n\n        fname = self.visit(node.func)\n        if fname=='__DOLLAR__': fname = '$'\n\n        if fname in self.macros:\n            macro = self.macros[fname]\n            args = ','.join([self.visit(arg) for arg in node.args])\n            if ' %s ' in macro:\n                return macro % tuple([s.s for s in node.args])\n            elif '%s' in macro:\n                if macro.count('%s')==1:\n                    return macro % args\n                else:\n                    return macro % tuple([self.visit(s) for s in node.args])\n            else:\n                return '%s(%s)' %(macro,args)\n        elif fname == 'sleep':\n            self._sleeps += 1\n            return 'setTimeout(__sleep__%s.bind(this), %s*1000); function __sleep__%s(){' % (self._sleeps, args[0], self._sleeps)\n        elif fname=='v8.__right_arrow__':\n            jitFN = args.split('(')[0]\n            return '%s; v8(%s)' %(args, jitFN)\n        elif fname.endswith('.__right_arrow__'):\n            ob = fname.replace('.__right_arrow__', '')\n            #return '__right_arrow__(%s, %s)' %(ob, args)\n            #return '\u1405(%s, %s)' %(ob, args)\n            if args:\n                return '\u1405(%s, %s)' %(ob, args)\n            else:\n                return '\u1405(%s)' %ob\n\n        else:\n            return '%s(%s)' % (fname, args)\n\n    def inline_helper_remap_names(self, remap):\n        return  var %s;  %','.join(remap.values())\n\n    def inline_helper_return_id(self, return_id):  ## what was this for?\n        return  var __returns__%s = null; %return_id\n\n    def _visit_call_helper_numpy_array(self, node):\n        return self.visit(node.args[0])\n\n    def _visit_call_helper_list(self, node):\n        name = self.visit(node.func)\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n        return '%s(%s)' % (name, args)\n\n    def _visit_call_helper_get_call_special(self, node):\n        name = self.visit(node.func)\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n        return '%s(%s)' % (name, args)\n\n\n    def _visit_call_helper_JSArray(self, node):\n        if node.args:\n            args = map(self.visit, node.args)\n            out = ', '.join(args)\n            #return '__create_array__(%s)' % out\n            return '[%s]' % out\n\n        else:\n            return '[]'\n\n\n    def _visit_call_helper_JSObject(self, node):\n        if node.keywords:\n            kwargs = map(self.visit, node.keywords)\n            f = lambda x: ' %s : %s' % (x[0], x[1])\n            out = ', '.join(map(f, kwargs))\n            return '{%s}' % out\n        else:\n            return '{}'\n\n    def _visit_call_helper_var(self, node):\n        args = [ self.visit(a) for a in node.args ]\n        if self._function_stack:\n            fnode = self._function_stack[-1]\n            rem = []\n            for arg in args:\n                if arg in fnode._local_vars:\n                    rem.append( arg )\n                else:\n                    fnode._local_vars.add( arg )\n            for arg in rem:\n                args.remove( arg )\n        if 'this' in args:\n            args.remove('this')\n        out = []\n        if args:\n            out.append( 'var ' + ','.join(args) )\n        if node.keywords:\n            out.append( 'var ' + ','.join([key.arg for key in node.keywords]) )\n            for key in node.keywords:\n                ## inside a webworker this is a type cast\n                if self._webworker:\n                    out.append('%s.__proto__ = %s.prototype' %(key.arg, self.visit(key.value)))\n\n                ## outside of a webworker this is a type assertion\n                elif self._runtime_type_checking:\n                    funcname = self._function_stack[-1].name\n\n                    if isinstance(key.value, ast.Call):\n                        if key.value.func.id == '__arg_array__':\n                            s = key.value.args[0].s\n                            dims = '[0]' * s.count('[')\n                            t = s.split(']')[-1]\n                            out.append('/***/ if (!(isinstance(%s,Array))) {throw new TypeError( invalid type - not an array )}' %key.arg)\n                            out.append('/***/ if (%s.length   0   !( isinstance(%s%s, %s) )) {throw new TypeError( invalid array type )}' %(key.arg, key.arg, dims, t))\n                        else:  ## typed hash map\n                            keytype   = key.value.args[0].s.split(']')[0].split('[')[1].strip()\n                            valuetype = key.value.args[0].s.split(']')[1].strip()\n                            out.append('/***/ if (%s.__keytype__ !=  %s ) {throw new TypeError( invalid dict key type )}' %(key.arg, keytype))\n                            out.append('/***/ if (%s.__valuetype__ !=  %s ) {throw new TypeError( invalid dict value type )}' %(key.arg, valuetype))\n\n                    elif isinstance(key.value, ast.Str) and key.value.s.startswith('func('):\n\n                        out.append('/***/ if (!(%s instanceof Function)) {throw new TypeError( `%s` is not a callback function: instead got type- +typeof(%s))}' %(key.arg, key.arg, key.arg))\n                        targs = []\n                        head,tail = key.value.s.split(')(')\n                        head = head.split('func(')[-1]\n                        for j, targ in enumerate(head.split('|')):  ## NOTE TODO replace `|` with space\n                            out.append(\n                                '/***/ if (!(%s.args[%s]== %s )) {throw new TypeError( callback `%s` requires argument `%s` as type `%s` )}' %(key.arg, j, targ,   key.value.s.replace('|',' '), j, targ)\n                            )\n\n                        returns = tail.replace(')','')\n                        if returns:\n                            out.append(\n                                '/***/ if (!(%s.returns== %s )) {throw new TypeError( callback `%s` requires a return type of `%s`, instead got-  + typeof(%s.returns))}' %(key.arg, returns, key.arg, returns, key.arg)\n                            )\n\n                    else:\n                        val = self.visit(key.value)\n                        out.append('/***/ if ( !(isinstance(%s, %s))) {throw new TypeError( in function `%s`, argument `%s` must of type `%s`, instead got- +typeof(%s))}' %(key.arg, val, funcname, key.arg,val, key.arg))\n\n        return ';\\n'.join(out)", 
            "title": "Call Helper"
        }, 
        {
            "location": "/jstranslator/#inline-code-helper", 
            "text": "called from user:  inline(str) \nold javascript backend also used  JS(str)  \n    def _inline_code_helper(self, s):\n        ## TODO, should newline be changed here?\n        s = s.replace('\\n', '\\\\n').replace('\\0', '\\\\0')  ## AttributeError: 'BinOp' object has no attribute 's' - this is caused by bad quotes\n\n        ## DEPRECATED\n        #if s.strip().startswith('#'): s = '/*%s*/'%s\n        #if ' ' in s or  '  in s:  ## can not trust direct-replace hacks\n        #   pass\n        #else:\n        #   if ' or ' in s:\n        #       s = s.replace(' or ', ' || ')\n        #   if ' not ' in s:\n        #       s = s.replace(' not ', ' ! ')\n        #   if ' and ' in s:\n        #       s = s.replace(' and ', '   ')\n\n        if typedpython.needs_escape(s):\n            s = typedpython.escape_text(s)\n\n        return s\n\n    def visit_While(self, node):\n        body = [ 'while (%s)' %self.visit(node.test), self.indent()+'{']\n        self.push()\n        if hasattr(self, '_in_timeout') and self._in_timeout:\n            body.append(\n                self.indent() +  'if ( (new Date()).getTime() - __clk__  = %s )  { break;}' % self._timeout\n            )\n\n        for line in list( map(self.visit, node.body) ):\n            body.append( self.indent()+line )\n        self.pull()\n        body.append( self.indent() + '}' )\n        return '\\n'.join( body )\n\n    def visit_Str(self, node):\n        s = node.s.replace( \\\\ ,  \\\\\\\\ ).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace(' ', '\\\\ ')\n        if typedpython.needs_escape(s):\n            s = typedpython.escape_text(s)\n        return ' %s ' % s\n\n    def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n        right = self.visit(node.right)\n        go_hacks = ('__go__array__', '__go__arrayfixed__', '__go__map__', '__go__func__', '__go__receive__', '__go__send__')\n\n        if op == ' ' and left == '__new__':\n            ## this can happen because python_to_pythonjs.py will catch when a new class instance is created\n            ## (when it knows that class name) and replace it with `new(MyClass())`; but this can cause a problem\n            ## if later the user changes that part of their code into a module, and loads it as a javascript module,\n            ## they may update their code to call `new MyClass`, and then later go back to the python library.\n            ## the following hack prevents `new new`\n            if isinstance(node.right, ast.Call) and isinstance(node.right.func, ast.Name) and node.right.func.id=='new':\n                right = self.visit(node.right.args[0])\n            return ' new %s' %right\n\n\n        elif op == ' ':\n\n            if left == '__go__receive__':\n                self._has_channels = True\n                r = []\n                if isinstance(node.right, ast.Name):\n                    r.append('\u2ca2\u2c91\u2c91\u2c92.recv( %s,'%right)\n                elif isinstance(node.right, ast.Attribute):\n                    wid = node.right.value.id\n                    attr = node.right.attr\n                    r.append('\u2ca2\u2c91\u2c91\u2c92.get( %s,  %s , '%(wid, attr))\n                elif isinstance(node.right, ast.Call):\n                    if isinstance(node.right.func, ast.Name):\n                        fname = node.right.func.id\n                        args  = [self.visit(a) for a in node.right.args]\n                        r.append('\u2ca2\u2c91\u2c91\u2c92.call(  %s , [%s], ' % (fname, ','.join(args)))\n\n                    else:\n                        wid = node.right.func.value.id\n                        attr = node.right.func.attr\n                        args  = [self.visit(a) for a in node.right.args]\n                        r.append('\u2ca2\u2c91\u2c91\u2c92.callmeth( %s,  %s , [%s], '%(wid, attr, ','.join(args)))\n                else:\n                    raise RuntimeError(node.right)\n\n                r.append(' function (%s) {')  ## gets filled in later\n                return ''.join(r)\n\n            elif left == '__go__send__':\n                self._has_channels = True\n                r = [\n                    '\u2ca2\u2c91\u2c91\u2c92.send({message:%s,'%right,\n                    'id:%s})'\n                ]\n                return ''.join(r)\n\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id in go_hacks:\n                if node.left.func.id == '__go__func__':\n                    raise SyntaxError('TODO - go.func')\n\n                elif node.left.func.id == '__go__map__':  ## typed hash maps for javascript\n                    key_type = node.left.args[0].id\n                    value_type = node.left.args[1].id\n                    if key_type == 'string':\n                        ## right will take the form: `\ud835\udc6b\ud835\udc8a\ud835\udc84\ud835\udc95({  }, { copy:false })`\n                        ## here was simply clip off the end and inject the type options\n                        clipped = right[:-2]\n                        if 'keytype:' not in clipped:\n                            clipped += ',keytype: %s '  % key_type \n                        clipped += ',valuetype: %s  })' % value_type\n                        return clipped\n                    else:\n                        assert isinstance(node.right, ast.Call)\n                        dictnode = node.right.args[0]\n                        dlist = []\n                        for i in range( len(dictnode.keys) ):\n                            k = self.visit( dictnode.keys[ i ] )\n                            v = self.visit( dictnode.values[i] )\n                            dlist.append( '[%s, %s]' %(k,v) )\n                        return 'dict([%s], {copy:false, keytype: %s , valuetype: %s })' %(','.join(dlist), key_type, value_type)\n\n\n                else:\n                    if isinstance(node.right, ast.Name):\n                        raise SyntaxError(node.right.id)\n\n                    right = []\n                    for elt in node.right.elts:\n                        right.append( self.visit(elt) )\n\n                    if node.left.func.id == '__go__array__':\n                        T = self.visit(node.left.args[0])\n                        ## TODO redefine `.append` on this instance to do runtime type checking\n                        return '[%s] /*array of: %s*/' %(','.join(right), T)\n\n                    elif node.left.func.id == '__go__arrayfixed__':\n                        asize = self.visit(node.left.args[0])\n                        atype = self.visit(node.left.args[1])\n\n                        if atype in ('ubyte', 'uint8', 'ui8'):\n                            r = ' new Uint8Array(%s)' %asize\n                        elif atype in ('byte' ,'int8', 'i8'):\n                            r = ' new Int8Array(%s)' %asize\n                        elif atype in ('short', 'int16', 'i16'):\n                            r = ' new Int16Array(%s)' %asize\n                        elif atype in ('ushort', 'uint16', 'ui16'):\n                            r = ' new Uint16Array(%s)' %asize\n                        elif atype in ('int', 'int32', 'i32'):\n                            r = ' new Int32Array(%s)' %asize\n                        elif atype in ('uint', 'uint32', 'ui32'):\n                            r = ' new Uint32Array(%s)' %asize\n                        elif atype in ('float', 'float32', 'f32'):\n                            r = ' new Float32Array(%s)' %asize\n                        elif atype in ('float64', 'f64', 'double'):\n                            r = ' new Float64Array(%s)' %asize\n                        else:\n                            raise SyntaxError(self.format_error('invalid type for fixed-size typed arrays: '+atype))\n\n                        if len(right):\n                            return '__array_fill__(%s, [%s])' %(r, ','.join(right))\n                        else:\n                            return r\n\n        if self._with_oo:\n            methodnames = {\n                '+': 'add',\n                '-': 'sub',\n                '*': 'mul',\n                '/': 'div',\n                '%': 'mod'\n            }\n            return '(%s.__%s__(%s))' % (left, methodnames[op], right)\n        elif op=='*' and isinstance(node.left, ast.Str):\n            return '(%s.__mul__(%s))' % (left, right)\n        else:\n            return '(%s %s %s)' % (left, op, right)\n\n\n    def visit_Return(self, node):\n        if isinstance(node.value, Tuple):\n            return 'return [%s];' % ', '.join(map(self.visit, node.value.elts))\n        if node.value:\n            return 'return %s;' % self.visit(node.value)\n        return 'return null;'\n\n    def visit_Pass(self, node):\n        return '/*pass*/'\n\n    def visit_Is(self, node):\n        return '==='\n\n    def visit_IsNot(self, node):\n        return '!=='\n\n\n    def visit_Compare(self, node):\n        #if isinstance(node.ops[0], ast.Eq):\n        #   left = self.visit(node.left)\n        #   right = self.visit(node.comparators[0])\n        #   if self._lua:\n        #       return '%s == %s' %(left, right)\n        #   elif self._fast_js:\n        #       return '(%s===%s)' %(left, right)\n        #   else:\n        #       return '(%s instanceof Array ? JSON.stringify(%s)==JSON.stringify(%s) : %s===%s)' %(left, left, right, left, right)\n        #elif isinstance(node.ops[0], ast.NotEq):\n        #   left = self.visit(node.left)\n        #   right = self.visit(node.comparators[0])\n        #   if self._lua:\n        #       return '%s ~= %s' %(left, right)\n        #   elif self._fast_js:\n        #       return '(%s!==%s)' %(left, right)\n        #   else:\n        #       return '(!(%s instanceof Array ? JSON.stringify(%s)==JSON.stringify(%s) : %s===%s))' %(left, left, right, left, right)\n        #       \n        #else:\n        comp = []\n        if isinstance( node.left, ast.BinOp ):\n            comp.append( '('+self.visit(node.left)+')' )\n        else:\n            comp.append( self.visit(node.left) )\n\n        for i in range( len(node.ops) ):\n            op = None\n            if isinstance(node.ops[i], ast.Eq):\n                op = '==='\n            elif isinstance(node.ops[i], ast.NotEq):\n                op = '!=='\n            else:\n                op = self.visit(node.ops[i])\n\n            comp.append( op )\n            right = node.comparators[i]\n\n            if op in ('===', '!==') and isinstance(right, ast.Name) and right.id=='undefined':\n                ## this fixes `if x is not undefined:`\n                ## the users expects above to work because this works: `if x.y is not undefined:`\n                comp[0] = 'typeof(%s)' %comp[0]\n                comp.append(' undefined ')\n\n            elif isinstance(node.comparators[i], ast.BinOp):\n                comp.append('(')\n                comp.append( self.visit(node.comparators[i]) )\n                comp.append(')')\n            else:\n                comp.append( self.visit(node.comparators[i]) )\n\n        return ' '.join( comp )\n\n\n    def visit_UnaryOp(self, node):\n        #return self.visit(node.op) + self.visit(node.operand)\n        return '%s (%s)' %(self.visit(node.op),self.visit(node.operand))\n\n\n    def visit_BoolOp(self, node):\n        op = self.visit(node.op)\n        return '('+ op.join( [self.visit(v) for v in node.values] ) +')'", 
            "title": "Inline Code Helper"
        }, 
        {
            "location": "/jstranslator/#if-test", 
            "text": "def visit_If(self, node):\n        out = []\n        test = self.visit(node.test)\n        if self._runtime_type_checking and not isinstance(node.test, ast.Compare):\n            ## note in old-style-js `typeof(null)=='object'`,\n            ## so we need to check first that the test is not null.\n            ## this still works for functions, because `typeof(F)` is 'function'\n            #errmsg = 'if test not allowed directly on arrays, dicts, or objects. The correct syntax is: `if len(array)` or `if len(dict.keys())` or `if myob is not None`'\n            #out.append( 'if (%s!=null   typeof(%s)== object ) {throw new RuntimeError( %s )}' %(test, test, errmsg))\n\n            errmsg = 'if test not allowed directly on arrays. The correct syntax is: `if len(array)` or `if array.length`'\n            out.append( 'if (%s instanceof Array) {throw new RuntimeError( %s )}' %(test, errmsg))\n\n            out.append( self.indent() + 'if (%s) {' %test )\n        else:\n            out.append( 'if (%s) {' %test )\n\n        self.push()\n\n        for line in list(map(self.visit, node.body)):\n            if line is None: continue\n            out.append( self.indent() + line )\n\n        orelse = []\n        for line in list(map(self.visit, node.orelse)):\n            orelse.append( self.indent() + line )\n\n        self.pull()\n\n        if orelse:\n            out.append( self.indent() + '} else {')\n            out.extend( orelse )\n\n        out.append( self.indent() + '}' )\n\n        return '\\n'.join( out )\n\n\n    def visit_Dict(self, node):\n        a = []\n        for i in range( len(node.keys) ):\n            k = self.visit( node.keys[ i ] )\n            v = self.visit( node.values[i] )\n            a.append( '%s:%s'%(k,v) )\n        b = ', '.join( a )\n        return '{ %s }' %b", 
            "title": "If Test"
        }, 
        {
            "location": "/jstranslator/#for-loop", 
            "text": "when fast_loops is off much of python  for in something  style of looping is lost.  \n    def _visit_for_prep_iter_helper(self, node, out, iter_name, wrapped):\n        if not self._fast_loops or wrapped:\n            if typedpython.unicode_vars:\n                s = 'if (! (%s instanceof Array || typeof %s ==  string  || \ud835\udc70\ud835\udc94\ud835\udc7b\ud835\udc9a\ud835\udc91\ud835\udc86\ud835\udc85\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s) || \ud835\udc70\ud835\udc94\ud835\udc68\ud835\udc93\ud835\udc93\ud835\udc82\ud835\udc9a(%s) )) { %s = __object_keys__(%s) }' %(iter_name, iter_name, iter_name, iter_name, iter_name, iter_name)\n            else:\n                s = 'if (! (%s instanceof Array || typeof %s ==  string  || __is_typed_array(%s) || __is_some_array(%s) )) { %s = __object_keys__(%s) }' %(iter_name, iter_name, iter_name, iter_name, iter_name, iter_name)\n\n            if len(out):\n                out.append( self.indent() + s )\n            else:\n                out.append( s )\n\n    def remap_to_subscript(self, number):  ## NOT USED FOR NOW\n        ## converts a regular number into a subscript number\n        ## too bad these subscripts are not in the valid unicode range.\n        s = str(number)\n        assert '.' not in s\n        remap = {\n            '0' : '\u2080',\n            '1' : '\u2081',\n            '2' : '\u2082',\n            '3' : '\u2083',\n            '4' : '\u2084',\n            '5' : '\u2085',\n            '6' : '\u2086',\n            '7' : '\u2087',\n            '8' : '\u2088',\n            '9' : '\u2089',\n        }\n\n        r = ''\n        for char in s:\n            r += remap[ char ]\n        return r\n\n\n    def visit_For(self, node):\n        self._fast_loops = False  ## if true breaks builtins that for loop on special `arguments`\n        ## TESTING fast loops always true, string iteration now requires `iter(s)` wrapped\n\n\n        target = node.target.id\n        iter = self.visit(node.iter) # iter is the python iterator\n        is_iter_wrapped = False\n        if iter.startswith('iter('):\n            is_iter_wrapped = True\n            iter = iter[5:-1]\n\n        out = []\n        body = []\n\n        if not typedpython.unicode_vars:\n            index = '__n%s' % self._iter_id\n        elif self._iter_id == 0:\n            index = '\ud835\udcf7'\n        else:\n            index = '\ud835\udcf7%s' % self._iter_id\n\n\n        ##if not self._fast_loops and not isinstance(node.iter, ast.Name):\n        ## note: above will fail with `for key in somedict:`, it can not\n        ## be simply assumed that if its a name, to use that name as the\n        ## iterator, because _visit_for_prep_iter_helper might break it,\n        ## by reassigning the original dict, to its keys (an array),\n        ## later code in the block will then fail when it expects a dict.\n        if not self._fast_loops or is_iter_wrapped:\n            if not typedpython.unicode_vars:\n                iname = '__iter%s' %self._iter_id\n            elif isinstance(node.iter, ast.Name):\n                iname = '\ud835\udd5a\ud835\udd65\ud835\udd56\ud835\udd63%s' %iter\n            elif self._iter_id:\n                iname = '\ud835\udd5a\ud835\udd65\ud835\udd56\ud835\udd63%s' %self._iter_id\n            else:\n                iname = '\ud835\udd5a\ud835\udd65\ud835\udd56\ud835\udd63'\n\n            out.append( 'var %s = %s;' % (iname, iter) )\n        else:\n            iname = iter\n\n        self._iter_id += 1\n\n        ## note this type of looping can break with _fast_loops on a dict,\n        ## because it reassigns the dict when looping over it\n        ## like this `for key in somedict:`, the only safe way\n        ## to loop with _fast_loops is `for key in somedict.keys():`\n        if iter.startswith('\ud835\udc72\ud835\udc86\ud835\udc9a\ud835\udc94'):\n            ## in theory we can optimize away using _visit_for_prep_iter_helper,\n            ## because we know almost for sure that the result of \ud835\udc72\ud835\udc86\ud835\udc9a\ud835\udc94\n            ## is going to be an array of keys; however, it could still be\n            ## a user defined class that is returning an object of something\n            ## other than an array.\n            ## the only safe way to omit _visit_for_prep_iter_helper is to check\n            ## if the user had statically typed the iterator variable as a dict.\n            pass\n\n        ## TESTING ##\n        self._visit_for_prep_iter_helper(node, out, iname, is_iter_wrapped)\n\n        if BLOCKIDS: out.append('/*BEGIN-FOR:%s*/' %iter)\n\n        if self._fast_loops and not is_iter_wrapped:\n\n            ## iteration over strings not allowed in javascript backend without wrapping with `iter(mystr)` in the loop,\n            ## example: `for char in iter(mystr)`\n            if self._runtime_type_checking:\n                out.append( self.indent() + 'if (typeof(%s)== string ) {throw new RuntimeError( string iteration error:\\\\n  wrap the string with `iter()`:\\\\n  example `for c in iter(mystr)`.\\\\n );}' %iname )\n                #breaks:DOM and typedarrys##out.append( self.indent() + 'if (!(__is_some_array(%s)){throw new RuntimeError( Array iteration error:\\\\n  wrap the object with `iter()`:\\\\n  example `for ob in iter(iterable)`.\\\\n );}' %iname )\n                out.append( self.indent() + 'if (!(%s instanceof Array)){throw new RuntimeError( Array iteration error:\\\\n  wrap the object with `iter()`:\\\\n  example `for ob in iter(iterable)`.\\\\n );}' %iname )\n\n            out.append( self.indent() + 'var %s = %s.length-1;' %(index, iname) )\n            out.append( self.indent() + '%s.reverse();' %iname )            \n            out.append( self.indent() + 'while (%s.length   %s+1) {' %(iname, index) )\n\n        else:\n            out.append( self.indent() + 'for (var %s = 0; %s   %s.length; %s++) {' % (index, index, iname, index) )\n\n        self.push()\n\n        if hasattr(self, '_in_timeout') and self._in_timeout:\n            body.append(\n                self.indent() + 'if ( (new Date()).getTime() - __clk__  = %s )  { break; }' % self._timeout\n            )\n\n\n        body.append( self.indent() + 'var %s = %s[ %s ];' %(target, iname, index) )\n\n\n        for line in list(map(self.visit, node.body)):\n            body.append( self.indent() + line )\n\n        if self._fast_loops and not is_iter_wrapped:\n            body.append( self.indent() + '%s--;' %index)\n\n        self.pull()\n        out.extend( body )\n        if self._fast_loops and not is_iter_wrapped:\n            out.append( self.indent() + '} %s.reverse();' %iname )          \n        else:\n            out.append( self.indent() + '}' )\n\n\n        if BLOCKIDS: out.append( self.indent() + '/*END-FOR:%s*/' %self._fast_loops)\n\n        self._iter_id -= 1\n\n        return '\\n'.join( out )\n\n    def visit_Continue(self, node):\n        return 'continue'\n\n    def visit_Break(self, node):\n        return 'break;'", 
            "title": "For Loop"
        }, 
        {
            "location": "/jstranslator/#regenerate-js-runtime", 
            "text": "TODO: update and test generate new js runtimes  \ndef generate_js_runtime( nodejs=False, nodejs_tornado=False, webworker_manager=False, debugger=False ):\n    ## note: RUSTHON_LIB_ROOT gets defined in the entry of rusthon.py\n    r = [\n        open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/pythonpythonjs.py'), 'rb').read(),\n        python_to_pythonjs(\n            open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_core.py'), 'rb').read(),\n            fast_javascript = True,\n            pure_javascript = False\n        )\n\n    ]\n\n    if debugger:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_debugger.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n\n    if nodejs:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_nodejs.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n    if nodejs_tornado:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/nodejs_tornado.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n    if webworker_manager:\n        r.append(\n            python_to_pythonjs(\n                open(os.path.join(RUSTHON_LIB_ROOT,'src/runtime/builtins_webworker.py'), 'rb').read(),\n                fast_javascript = True,\n                pure_javascript = False\n            )\n        )\n\n\n    builtins = translate_to_javascript(\n        '\\n'.join(r),\n        requirejs = False,\n        insert_runtime = False,\n        fast_javascript = True,\n        fast_loops = True,\n        runtime_checks = False\n    )\n    builtins += '\\n/*end-builtins*/\\n'\n    return builtins", 
            "title": "Regenerate JS Runtime"
        }, 
        {
            "location": "/jstranslator/#translate-to-javascript", 
            "text": "html files can also be translated, it is parsed and checked for  script type=\"text/python\"  \ndef translate_to_javascript(source, requirejs=True, insert_runtime=True, webworker=False, function_expressions=True, fast_javascript=False, fast_loops=False, runtime_checks=True, as_module=False):\n    if '--debug-inter' in sys.argv:\n        raise RuntimeError(source)\n    head = []\n    tail = []\n    script = False\n    osource = source\n    if source.strip().startswith(' html'):\n        lines = source.splitlines()\n        for line in lines:\n            if line.strip().startswith(' script') and 'type= text/python ' in line:\n                head.append( ' script type= text/javascript ')\n                script = list()\n            elif line.strip() == ' /script ':\n                if type(script) is list:\n                    source = '\\n'.join(script)\n                    script = True\n                    tail.append( ' /script ')\n                elif script is True:\n                    tail.append( ' /script ')\n                else:\n                    head.append( ' /script ')\n\n            elif isinstance( script, list ):\n                script.append( line )\n\n            elif script is True:\n                tail.append( line )\n\n            else:\n                head.append( line )\n\n    try:\n        tree = ast.parse( source )\n        #raise SyntaxError(source)\n    except SyntaxError:\n        import traceback\n        err = traceback.format_exc()\n        sys.stderr.write( err )\n        sys.stderr.write( '\\n--------------error in second stage translation--------------\\n' )\n\n        lineno = 0\n        for line in err.splitlines():\n            if  unknown  in line:\n                lineno = int(line.split()[-1])\n\n\n        lines = source.splitlines()\n        if lineno   10:\n            for i in range(lineno-5, lineno+5):\n                sys.stderr.write( 'line %s- '%i )\n                sys.stderr.write( lines[i] )\n                if i==lineno-1:\n                    sys.stderr.write('   SyntaxError ')\n                sys.stderr.write( '\\n' )\n\n        else:\n            sys.stderr.write( lines[lineno] )\n            sys.stderr.write( '\\n' )\n\n        if '--debug' in sys.argv:\n            sys.stderr.write( osource )\n            sys.stderr.write( '\\n' )\n\n        sys.exit(1)\n\n    gen = JSGenerator(\n        source = source,\n        requirejs=requirejs, \n        insert_runtime=insert_runtime, \n        webworker=webworker, \n        function_expressions=function_expressions,\n        fast_javascript = fast_javascript,\n        fast_loops      = fast_loops,\n        runtime_checks  = runtime_checks,\n        as_module = as_module\n    )\n    output = gen.visit(tree)\n\n    if head and not isinstance(output, dict):\n        head.append( output )\n        head.extend( tail )\n        output = '\\n'.join( head )\n\n    return output", 
            "title": "Translate to Javascript"
        }, 
        {
            "location": "/gotranslator/", 
            "text": "Go Translator\n\n\nnote: The GoGenerator class subclasses from javascript generator.\n\n\n\ngo_types = 'bool string int float64'.split()\n\nclass GoGenerator( JSGenerator ):\n    def __init__(self, source=None, requirejs=False, insert_runtime=False):\n        assert source\n        JSGenerator.__init__(self, source=source, requirejs=False, insert_runtime=False)\n\n        self._go = True\n        self._dart = False\n        self._class_stack = list()\n        self._classes = dict()      ## name : node\n        #   node._parents = set()\n        #   node._struct_def = dict()\n        #   node._subclasses = set()  ## required for generics generator\n        #   ## subclasses must be a struct union so that Go can convert between struct types\n        #   node._subclasses_union = dict()\n        self.method_returns_multiple_subclasses = dict() # class name : method name that can return multiple subclass types\n        self._class_props = dict()\n\n        self._vars = set()\n        self._known_vars = set()\n        self._kwargs_type_ = dict()\n\n        self._imports = set()\n        self._ids = 0\n        self._known_instances = dict()\n        self._known_arrays    = dict()\n        self._known_maps      = dict()\n        self._scope_stack = list()\n\n        self.interfaces = dict()  ## for Go backend, TODO unify Go/Rust/C++ logic\n        self.uids = 0\n        self.unodes = dict()\n\n        self._slice_hack_id = 0\n\n    def uid(self):\n        self.uids += 1\n        return self.uids\n\n\n    def visit_Import(self, node):\n        r = [alias.name.replace('__SLASH__', '/') for alias in node.names]\n        res = []\n        if r:\n            for name in r:\n                self._imports.add('import(\n%s\n);' %name)\n\n        if res:\n            return '\\n'.join(res)\n        else:\n            return ''\n\n    def visit_Str(self, node):\n        s = node.s.replace(\n\\\\\n, \n\\\\\\\\\n).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\n', '\\\\\n')\n        return '\n%s\n' % s\n\n    def visit_Is(self, node):\n        return '=='\n    def visit_IsNot(self, node):\n        return '!='\n\n    def visit_If(self, node):\n        out = []\n        test = self.visit(node.test)\n        if test.startswith('(') and test.endswith(')'):\n            out.append( 'if %s {' %test )\n        else:\n            out.append( 'if (%s) {' %test )\n\n        self.push()\n\n        for line in list(map(self.visit, node.body)):\n            if line is None: continue\n            out.append( self.indent() + line )\n\n        orelse = []\n        for line in list(map(self.visit, node.orelse)):\n            orelse.append( self.indent() + line )\n\n        self.pull()\n\n        if orelse:\n            out.append( self.indent() + '} else {')\n            out.extend( orelse )\n\n        out.append( self.indent() + '}' )\n\n        return '\\n'.join( out )\n\n    def visit_Name(self, node):\n        if node.id == 'None':\n            return 'nil'\n        elif node.id == 'True':\n            return 'true'\n        elif node.id == 'False':\n            return 'false'\n        #elif node.id == 'null':\n        #   return 'nil'\n        return node.id\n\n    def get_subclasses( self, C ):\n        '''\n        returns all sibling subclasses, C can be a subclass or the base class\n        '''\n        subclasses = set()\n        self._collect_subclasses(C, subclasses)\n        return subclasses\n\n    def _collect_subclasses(self, C, subclasses):\n        node = self._classes[ C ]\n        if len(node._parents)==0:\n            for sub in node._subclasses:\n                subclasses.add( sub )\n        else:\n            for parent in node._parents:\n                self._collect_subclasses(parent, subclasses)\n\n\n    def visit_ClassDef(self, node):\n        self._class_stack.append( node )\n        if not hasattr(node, '_parents'):  ## only setup on the first pass\n            node._parents = set()\n            node._struct_def = dict()\n            node._subclasses = set()  ## required for generics generator\n            ## subclasses must be a struct union so that Go can convert between struct types\n            node._subclasses_union = dict()\n\n        out = []\n        sdef = dict()\n        props = set()\n        bases = set()\n        base_classes = set()\n\n        self._classes[ node.name ] = node\n        self._class_props[ node.name ] = props\n        if node.name not in self.method_returns_multiple_subclasses:\n            self.method_returns_multiple_subclasses[ node.name ] = set()\n\n        self.interfaces[ node.name ] = set()\n\n\n        for base in node.bases:\n            n = self.visit(base)\n            if n == 'object':\n                continue\n            node._parents.add( n )\n\n            bases.add( n )\n            if n in self._class_props:\n                props.update( self._class_props[n] )\n                base_classes.add( self._classes[n] )\n            #else:  ## special case - subclassing a builtin like `list`\n            #   continue\n\n            for p in self._classes[ n ]._parents:\n                bases.add( p )\n                props.update( self._class_props[p] )\n                base_classes.add( self._classes[p] )\n\n            self._classes[ n ]._subclasses.add( node.name )\n\n\n        for decor in node.decorator_list:  ## class decorators\n            if isinstance(decor, ast.Call):\n                assert decor.func.id=='__struct__'\n                #props.update( [self.visit(a) for a in decor.args] )\n                for kw in decor.keywords:\n                    props.add( kw.arg )\n                    T = kw.value.id\n                    if T == 'interface': T = 'interface{}'\n                    sdef[ kw.arg ] = T\n\n\n        init = None\n        method_names = set()\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                method_names.add( b.name )\n                if b.name == '__init__':\n                    init = b\n            elif isinstance(b, ast.Expr) and isinstance(b.value, ast.Dict):\n                for i in range( len(b.value.keys) ):\n                    k = self.visit( b.value.keys[ i ] )\n                    if isinstance(b.value.values[i], ast.Str):\n                        v = b.value.values[i].s\n                    else:\n                        v = self.visit( b.value.values[i] )\n                    if v == 'interface': v = 'interface{}'\n                    sdef[k] = v\n\n        for k in sdef:\n            v = sdef[k]\n            if v=='interface{}':\n                self.interfaces[node.name].add(k)\n\n        node._struct_def.update( sdef )\n        unionstruct = dict()\n        unionstruct.update( sdef )\n        for pname in node._parents:\n            parent = self._classes[ pname ]\n            parent._subclasses_union.update( sdef )        ## first pass\n            unionstruct.update( parent._subclasses_union ) ## second pass\n\n\n        parent_init = None\n        if base_classes:\n            for bnode in base_classes:\n                for b in bnode.body:\n                    if isinstance(b, ast.FunctionDef):\n                        if b.name in method_names:\n                            self.catch_call.add( '%s.%s' %(bnode.name, b.name))\n                            n = b.name\n                            b.name = '%s_%s'%(bnode.name, b.name)\n                            out.append( self.visit(b) )\n                            b.name = n\n                            continue\n                        if b.name == '__init__':\n                            parent_init = {'class':bnode, 'init':b}\n                            #continue\n                        out.append( self.visit(b) )\n\n\n        out.append( 'type %s struct {' %node.name)\n        if len(node._parents)==0:\n            out.append('__object__')\n\n        if base_classes:\n            for bnode in base_classes:\n                ## Go only needs the name of the parent struct and all its items are inserted automatically ##\n                out.append('%s' %bnode.name)\n                ## Go allows multiple a variable to redefined by the sub-struct,\n                ## but this can throw an error: `invalid operation: ambiguous selector`\n                ## removing the duplicate name here fixes that error.\n                for key in bnode._struct_def.keys():\n                    #if key in sdef:\n                    #   sdef.pop(key)\n                    if key in unionstruct:\n                        unionstruct.pop(key)\n\n        #for name in sdef:\n        #   out.append('%s %s' %(name, sdef[name]))\n        for name in unionstruct:\n            out.append('%s %s' %(name, unionstruct[name]))\n        out.append('}')\n\n\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                out.append( self.visit(b) )\n\n        if init or parent_init:\n            if parent_init:\n                classname = parent_init['class'].name\n                init = parent_init['init']\n            else:\n                classname = node.name\n\n            out.append( 'func __new__%s( %s ) *%s {' %(node.name, init._args_signature, node.name))\n            out.append( '  ob := %s{}' %node.name )\n            out.append( '  ob.__init__(%s)' %','.join(init._arg_names))\n            ## used by generics to workaround the problem that a super method that returns `self`,\n            ## may infact return wrong subclass type, because a struct to return that is not of type\n            ## self will be cast to self - while this is ok if just reading attributes from it,\n            ## it fails with method calls, because the casting operation on the struct changes its\n            ## method pointers.  by storing the class name on the instance, it can be used in a generics\n            ## type switch to get to the real class and call the right methods.\n            out.append( '  ob.__class__ = \n%s\n' %node.name)\n            out.append( '  return \nob')\n            out.append('}')\n\n        else:\n            #out.append( 'func __new__%s() *%s { return \n%s{} }' %(node.name, node.name, node.name))\n            out.append( 'func __new__%s() *%s {' %(node.name, node.name))\n            out.append( '  ob := %s{}' %node.name )\n            out.append( '  ob.__class__ = \n%s\n' %node.name)\n            out.append( '  return \nob')\n            out.append('}')\n\n\n\n        self.catch_call = set()\n        self._class_stack.pop()\n        return '\\n'.join(out)\n\n\n    def _visit_call_special( self, node ):\n        fname = self.visit(node.func)\n        assert fname in self.catch_call\n        assert len(self._class_stack)\n        if len(node.args):\n            if isinstance(node.args[0], ast.Name) and node.args[0].id == 'self':\n                node.args.remove( node.args[0] )\n\n        #name = '_%s_' %self._class_stack[-1].name\n        name = 'self.'\n        name += fname.replace('.', '_')\n        return self._visit_call_helper(node, force_name=name)\n\n\n    def visit_Subscript(self, node):\n        if isinstance(node.slice, ast.Ellipsis):\n            return '(*%s)' %self.visit(node.value)\n        else:\n            ## deference pointer and then index\n            if isinstance(node.slice, ast.Slice):\n                r = '\n(*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n            else:\n                r = '(*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n\n            #if isinstance(node.value, ast.Name) and node.value.id in self._known_arrays:\n            #   target = node.value.id\n            #   #value = self.visit( node.value )\n            #   cname = self._known_arrays[target]\n            #   #raise GenerateGenericSwitch( {'target':target, 'value':r, 'class':cname} )\n            #   raise GenerateGenericSwitch( {'value':r, 'class':cname} )\n\n            return r\n\n\n\n    def visit_Slice(self, node):\n        lower = upper = step = None\n        if node.lower:\n            lower = self.visit(node.lower)\n        if node.upper:\n            upper = self.visit(node.upper)\n        if node.step:\n            step = self.visit(node.step)\n\n        if lower and upper:\n            return '%s:%s' %(lower,upper)\n        elif upper:\n            return ':%s' %upper\n        elif lower:\n            return '%s:'%lower\n        else:\n            raise SyntaxError('TODO slice')\n\n\n    def visit_Print(self, node):\n        r = []\n        for e in node.values:\n            s = self.visit(e)\n            if s is None: raise RuntimeError(e)\n            if isinstance(e, ast.List):\n                r.append('fmt.Println(%s);' %s[1:-1])\n            else:\n                r.append('fmt.Println(%s);' %s)\n        return ''.join(r)\n\n    def visit_Expr(self, node):\n        return self.visit(node.value)\n\n\n    def visit_Module(self, node):\n        header = [\n            'package main',\n            'import \nfmt\n',\n            #'import \nreflect\n'\n        ]\n        lines = []\n\n        for b in node.body:\n            line = self.visit(b)\n\n            if line:\n                for sub in line.splitlines():\n                    if sub==';':\n                        raise SyntaxError(line)\n                    else:\n                        lines.append( sub )\n            else:\n                if isinstance(b, ast.Import):\n                    pass\n                elif isinstance(b, ast.ImportFrom):\n                    pass\n                else:\n                    raise SyntaxError(b)\n\n        lines.append('type _kwargs_type_ struct {')\n        for name in self._kwargs_type_:\n            type = self._kwargs_type_[name]\n            lines.append( '  %s %s' %(name,type))\n            lines.append( '  __use__%s bool' %name)\n        lines.append('}')\n\n        lines = header + list(self._imports) + lines\n        return '\\n'.join( lines )\n\n\n    def visit_Compare(self, node):\n        comp = [ '(']\n        comp.append( self.visit(node.left) )\n        comp.append( ')' )\n\n        for i in range( len(node.ops) ):\n            comp.append( self.visit(node.ops[i]) )\n\n            if isinstance(node.comparators[i], ast.BinOp):\n                comp.append('(')\n                comp.append( self.visit(node.comparators[i]) )\n                comp.append(')')\n            else:\n                comp.append( self.visit(node.comparators[i]) )\n\n        return ' '.join( comp )\n\n    def visit_For(self, node):\n        target = self.visit(node.target)\n        lines = []\n        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, ast.Name):\n\n            if node.iter.func.id == 'range':\n                if len(node.iter.args)==1:\n                    iter = self.visit(node.iter.args[0])\n                    lines.append('for %s := 0; %s \n %s; %s++ {' %(target, target, iter, target))\n                elif len(node.iter.args)==2:\n                    start = self.visit(node.iter.args[0])\n                    iter = self.visit(node.iter.args[1])\n                    lines.append('for %s := %s; %s \n %s; %s++ {' %(target, start, target, iter, target))\n                else:\n                    raise SyntaxError('invalid for range loop')\n\n            elif node.iter.func.id == 'enumerate':\n                iter = self.visit(node.iter.args[0])\n                idx = self.visit(node.target.elts[0])\n                tar = self.visit(node.target.elts[1])\n                lines.append('for %s,%s := range *%s {' %(idx,tar, iter))\n\n            else: ## generator function\n                gfunc = node.iter.func.id\n                gargs = ','.join( [self.visit(e) for e in node.iter.args] )\n                lines.append('__gen%s := __new__%s(%s)' %(gfunc,gfunc, gargs))\n                lines.append('for __gen%s.__done__ != 1 {' %gfunc)\n                lines.append('  %s := __gen%s.next()' %(self.visit(node.target), gfunc))\n\n        elif isinstance(node.target, ast.List) or isinstance(node.target, ast.Tuple):\n            iter = self.visit( node.iter )\n            key = self.visit(node.target.elts[0])\n            val = self.visit(node.target.elts[1])\n            lines.append('for %s,%s := range *%s {' %(key,val, iter))\n\n        else:\n            iter = self.visit( node.iter )\n            lines.append('for _,%s := range *%s {' %(target, iter))\n\n        self.push()\n        for b in node.body:\n            lines.append( self.indent()+self.visit(b) )\n        self.pull()\n        lines.append( self.indent()+'}' )  ## end of for loop\n        return '\\n'.join(lines)\n\n\n    def _visit_call_helper(self, node, force_name=None):\n        fname = force_name or self.visit(node.func)\n        is_append = False\n        if fname.endswith('.append'):\n            is_append = True\n            arr = fname.split('.append')[0]\n        ####################################\n        if fname=='main':  ## can not directly call `main` in Go\n            return '/*run main*/'\n        elif fname == '__arg_array__':\n            assert len(node.args)==1\n            T = self.parse_go_style_arg(node.args[0])\n            if self.is_prim_type(T):\n                return '*[]%s' %T\n            else:\n                return '*[]*%s' %T\n\n        elif fname=='__let__':\n            if len(node.args) and isinstance(node.args[0], ast.Attribute): ## syntax `let self.x:T = y`\n                assert node.args[0].value.id == 'self'\n                assert len(node.args)==3\n                T = None\n                value = self.visit(node.args[2])\n                if isinstance(node.args[1], ast.Str):\n                    T = node.args[1].s\n                else:\n                    T = self.visit(node.args[1])\n\n                return 'self.%s = %s' %(node.args[0].attr, self.visit(node.args[2]))\n            else:\n                raise RuntimeError('TODO let...')\n\n\n        elif fname == 'range':  ## hack to support range builtin, translates to `range1,2,3`\n            assert len(node.args)\n            fname += str(len(node.args))\n        elif fname == 'len':\n            return 'len(*%s)' %self.visit(node.args[0])\n        elif fname == 'go.type_assert':\n            raise RuntimeError('go.type_assert is deprecated')\n            val = self.visit(node.args[0])\n            type = self.visit(node.args[1])\n            raise GenerateTypeAssert( {'type':type, 'value':val} )\n            ## below is deprecated\n            if type == 'self':\n                ## todo how to better mark interfaces, runtime type switch?\n                if '.' in type and type.split('.')[0]=='self' and type.split('.')[-1] in self.interfaces[self._class_stack[-1].name]:\n                    val += '.(%s)' %self._class_stack[-1].name\n                    return '\n%s(%s)' %(type, val )\n                else:\n                    type = '\n' + self._class_stack[-1].name\n            else:\n                type = '*' + type  ## TODO tests - should this be \n\n            #return 'interface{}(%s).(%s)' %(self.visit(node.args[0]), type)\n\n\n            return '%s(*%s)' %(type, val )\n\n\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n\n        if node.keywords:\n            if args: args += ','\n            args += '_kwargs_type_{'\n            x = ['%s:%s' %(kw.arg,self.visit(kw.value)) for kw in node.keywords]\n            x.extend( ['__use__%s:true' %kw.arg for kw in node.keywords] )\n            args += ','.join( x )\n            args += '}'\n\n        if node.starargs:\n            if args: args += ','\n            args += '*%s...' %self.visit(node.starargs)\n\n        if is_append:\n            ## deference pointer as first arg to append, assign to temp variable, then set the pointer to the new array.\n            id = self._ids\n            self._ids += 1\n            item = args\n\n            if item in self._known_instances:\n                classname = self._known_instances[ item ]\n                #raise SyntaxError( self._known_instances[item] )\n                #if arr in self._known_vars:\n                #   raise SyntaxError('kow')\n                if arr in self._known_arrays and classname != self._known_arrays[arr]:\n                    #raise SyntaxError( self._known_arrays[arr])\n                    item = '%s(*%s)' %(self._known_arrays[arr], item)\n                    r = '__addr%s := %s;' %(id,item)\n                    return r + '__%s := append(*%s,\n__addr%s); *%s = __%s;' % (id, arr, id, arr, id)\n\n            return '__%s := append(*%s,%s); *%s = __%s;' % (id, arr, item, arr, id)\n\n        else:\n\n            if isinstance(node.func, ast.Attribute) and False:\n                if isinstance(node.func.value, ast.Name):\n                    varname = node.func.value.id\n                    if varname in self._known_vars:\n                        #raise SyntaxError(varname + ' is known class::' + self._known_instances[varname] + '%s(%s)' % (fname, args))\n                        cname = self._known_instances[varname]\n                        if node.func.attr in self.method_returns_multiple_subclasses[ cname ]:\n                            raise SyntaxError('%s(%s)' % (fname, args))\n\n            if fname in self._classes:\n                fname = '__new__%s' %fname\n\n            return '%s(%s)' % (fname, args)\n\n\n    def visit_Assert(self, node):\n        return 'if ((%s) == false) { panic(\nassertion failed\n); }' %self.visit(node.test)\n\n\n    def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n        right = self.visit(node.right)\n\n        if op == '\n' and left == '__new__':\n            ## calls generated class constructor: user example `new MyClass()` ##\n            ## for rare cases where the translator is not aware of some transpiled class ##\n            if not right.startswith('__new__'):\n                return '__new__%s' %right\n            else:\n                return right\n\n        elif op == '\n':\n            if left in ('__go__receive__', '__go__send__'):\n                return '\n- %s' %right\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id in ('__go__array__', '__go__arrayfixed__', '__go__map__', '__go__func__'):\n                if node.left.func.id == '__go__func__':\n                    raise SyntaxError('TODO - go.func')\n                elif node.left.func.id == '__go__map__':\n                    key_type = self.visit(node.left.args[0])\n                    value_type = self.visit(node.left.args[1])\n                    if value_type == 'interface': value_type = 'interface{}'\n                    return '\nmap[%s]%s%s' %(key_type, value_type, right)\n                else:\n                    if not right.startswith('{') and not right.endswith('}'):\n                        right = '{%s}' %right[1:-1]\n\n                    if node.left.func.id == '__go__array__':\n                        T = self.visit(node.left.args[0])\n                        if T in go_types:\n                            return '\n[]%s%s' %(T, right)\n                        else:\n                            self._catch_assignment = {'class':T}  ## visit_Assign catches this\n                            return '\n[]*%s%s' %(T, right)\n                    elif node.left.func.id == '__go__arrayfixed__':\n                        asize = self.visit(node.left.args[0])\n                        atype = self.visit(node.left.args[1])\n                        if atype not in go_types:\n                            if right != '{}': raise SyntaxError('todo init array of objects with args')\n                            return '\nmake([]*%s, %s)' %(atype, asize)\n                        else:\n                            return '\n[%s]%s%s' %(asize, atype, right)\n            elif isinstance(node.left, ast.Name) and node.left.id=='__go__array__' and op == '\n':\n                return '*[]%s' %self.visit(node.right)\n\n        if left in self._typed_vars and self._typed_vars[left] == 'numpy.float32':\n            left += '[_id_]'\n        if right in self._typed_vars and self._typed_vars[right] == 'numpy.float32':\n            right += '[_id_]'\n\n        return '(%s %s %s)' % (left, op, right)\n\n    def visit_Return(self, node):\n        if isinstance(node.value, ast.Tuple):\n            return 'return %s' % ', '.join(map(self.visit, node.value.elts))\n        if node.value:\n            try:\n                v = self.visit(node.value)\n            except GenerateTypeAssert as err:\n                G = err[0]\n                type = G['type']\n                if type == 'self':\n                    type = self._class_stack[-1].name\n\n\n                ## This hack using reflect will not work for either case where the value\n                ## maybe an empty interface, or a pointer to a struct, because it is known\n                ## to the Go compiler if the value is an interface or pointer to struct,\n                ## and will not allow the alternate case.\n                ## case struct pointer:  invalid type assertion: __unknown__.(*A) (non-interface type *A on left)\n                ## case empty interface: cannot convert __unknown__ (type interface {}) to type B: need type assertion\n                #out = [\n                #   '__unknown__ := %s' %G['value'],\n                #   'switch reflect.TypeOf(__unknown__).Kind() {',\n                #   ' case reflect.Interface:',\n                #   '    __addr := __unknown__.(*%s)' %type,\n                #   '    return __addr',\n                #   ' case reflect.Ptr:',\n                #   '    __addr := %s(__unknown__)' %type,\n                #   '    return __addr',\n                #   '}'\n                #]\n\n                if not hasattr(node.value, 'uid'):\n                    node.value.uid = self.uid()\n\n                id = '__magic__%s' % node.value.uid\n                if id not in self.unodes: self.unodes[ id ] = node.value\n\n                if hasattr(node.value, 'is_struct_pointer'):\n\n                    out = [\n                        '%s := %s( *%s )' %(id, type, G['value']),\n                        'return \n%s' %id,\n                    ]\n                else:\n                    out = [\n                        '%s := %s.( *%s )' %(id, G['value'], type),\n                        'return %s' %id,\n                    ]\n\n                return '\\n'.join(out)\n\n\n\n            if v.startswith('\n'):\n                return '_hack := %s; return \n_hack' %v[1:]\n            else:\n                return 'return %s' % v\n        return 'return'\n\n    def _visit_function(self, node):\n        is_closure = False\n        if self._function_stack[0] is node:\n            self._vars = set()\n            self._known_vars = set()\n            self._known_instances = dict()\n            self._known_arrays    = dict()\n\n\n        elif len(self._function_stack) \n 1:\n            ## do not clear self._vars and _known_vars inside of closure\n            is_closure = True\n\n        args_typedefs = {}\n        chan_args_typedefs = {}\n        return_type = None\n        generic_base_class = None\n        generics = set()\n        args_generics = dict()\n        returns_self = False\n        use_generics = False\n\n        for decor in node.decorator_list:\n            if isinstance(decor, ast.Name) and decor.id=='generic':\n                use_generics = True\n\n\n        for decor in node.decorator_list:\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef__':\n                for key in decor.keywords:\n                    if isinstance( key.value, ast.Str):\n                        args_typedefs[ key.arg ] = key.value.s\n                    else:\n                        args_typedefs[ key.arg ] = self.visit(key.value)\n\n                    ## check for super classes - generics ##\n                    if use_generics and args_typedefs[ key.arg ] in self._classes:\n                        if node.name=='__init__':\n                            ## generics type switch is not possible in __init__ because\n                            ## it is used to generate the type struct, where types are static.\n                            ## as a workaround generics passed to init always become `interface{}`\n                            args_typedefs[ key.arg ] = 'interface{}'\n                            #self._class_stack[-1]._struct_def[ key.arg ] = 'interface{}'\n                        else:\n                            classname = args_typedefs[ key.arg ]\n                            generic_base_class = classname\n                            generics.add( classname ) # switch v.(type) for each\n                            generics = generics.union( self._classes[classname]._subclasses )\n                            args_typedefs[ key.arg ] = 'interface{}'\n                            args_generics[ key.arg ] = classname\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef_chan__':\n                for key in decor.keywords:\n                    if isinstance(key.value, ast.Str):\n                        chan_args_typedefs[ key.arg ] = key.value.s.strip()\n                    else:\n                        chan_args_typedefs[ key.arg ] = self.visit(key.value)\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'returns':\n                if decor.keywords:\n                    raise SyntaxError('invalid go return type')\n                elif isinstance(decor.args[0], ast.Name):\n                    return_type = decor.args[0].id\n                else:\n                    return_type = decor.args[0].s\n\n                if return_type == 'self':\n                    return_type = '*' + self._class_stack[-1].name\n                    returns_self = True\n                    self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n\n        if return_type and not self.is_prim_type(return_type):\n            if not return_type.startswith('*') and not return_type.startswith('\n') and not return_type.startswith('func('):\n                return_type = '*'+return_type\n\n        node._arg_names = args_names = []\n        args = []\n        oargs = []\n        offset = len(node.args.args) - len(node.args.defaults)\n        varargs = False\n        varargs_name = None\n        is_method = False\n        for i, arg in enumerate(node.args.args):\n            arg_name = arg.id\n\n            if arg_name not in args_typedefs.keys()+chan_args_typedefs.keys():\n                if arg_name=='self':\n                    assert i==0\n                    is_method = True\n                    continue\n                else:\n                    err = 'error in function: %s' %node.name\n                    err += '\\n  missing typedef: %s' %arg.id\n                    raise SyntaxError(err)\n\n            if arg_name in args_typedefs:\n                arg_type = args_typedefs[arg_name]\n                #if generics and (i==0 or (is_method and i==1)):\n                if use_generics and generics and arg_name in args_generics.keys():  ## TODO - multiple generics in args\n                    a = '__gen__ %s' %arg_type\n                elif self.is_prim_type(arg_type):\n                    a = '%s %s' %(arg_name, arg_type)\n                elif not arg_type.startswith('*') and not arg_type.startswith('\n') and not arg_type.startswith('func('):\n                    ## assume pointer ##\n                    a = '%s *%s' %(arg_name, arg_type)\n                else:\n                    a = '%s %s' %(arg_name, arg_type)\n            else:\n                arg_type = chan_args_typedefs[arg_name]\n                if arg_type.startswith('Sender\n'):\n                    arg_type = arg_type[ len('Sender\n') : -1 ]\n                elif arg_type.startswith('Receiver\n'):\n                    arg_type = arg_type[ len('Receiver\n') : -1 ]\n                a = '%s chan %s' %(arg_name, arg_type)\n\n            dindex = i - offset\n\n\n            if dindex \n= 0 and node.args.defaults:\n                default_value = self.visit( node.args.defaults[dindex] )\n                self._kwargs_type_[ arg_name ] = arg_type\n                oargs.append( (arg_name, default_value) )\n            else:\n                args.append( a )\n                node._arg_names.append( arg_name )\n\n        ##############################################\n        if oargs:\n            #args.append( '[%s]' % ','.join(oargs) )\n            #args.append( '{%s}' % ','.join(oargs) )\n            args.append( '__kwargs _kwargs_type_')\n            node._arg_names.append( '__kwargs' )\n\n        starargs = None\n        if node.args.vararg:\n            starargs = node.args.vararg\n            assert starargs in args_typedefs\n            args.append( '__vargs__ ...%s' %args_typedefs[starargs])\n            node._arg_names.append( starargs )\n\n        node._args_signature = ','.join(args)\n\n        ####\n        if is_method:\n            assert self._class_stack\n            method = '(self *%s)  ' %self._class_stack[-1].name\n        else:\n            method = ''\n        out = []\n        if is_closure:\n            if return_type:\n                out.append( '%s := func (%s) %s {\\n' % (node.name, ', '.join(args), return_type) )\n            else:\n                out.append( '%s := func (%s) {\\n' % (node.name, ', '.join(args)) )\n        else:\n            if return_type:\n                out.append( 'func %s%s(%s) %s {\\n' % (method, node.name, ', '.join(args), return_type) )\n            else:\n                out.append( 'func %s%s(%s) {\\n' % (method, node.name, ', '.join(args)) )\n        self.push()\n\n        if oargs:\n            for n,v in oargs:\n                out.append(self.indent() + '%s := %s' %(n,v))\n                out.append(self.indent() + 'if __kwargs.__use__%s { %s = __kwargs.%s }' %(n,n,n))\n\n        if starargs:\n            out.append(self.indent() + '%s := \n__vargs__' %starargs)\n\n        if use_generics and generics:\n            gname = args_names[ args_names.index(args_generics.keys()[0]) ]\n\n            #panic: runtime error: invalid memory address or nil pointer dereference\n            #[signal 0xb code=0x1 addr=0x0 pc=0x402440]\n            ##out.append(self.indent() + '__type__ := __gen__.(object).getclassname()')\n\n\n            out.append(self.indent() + '__type__ := \nINVALID\n')\n            out.append(self.indent() + '__super__, __ok__ := __gen__.(object)')\n\n            #out.append(self.indent() + '__type__ = __super__.getclassname();')        ## TODO FIX ME\n            #out.append(self.indent() + 'fmt.Println(__type__); ')\n            #out.append(self.indent() + 'if __type__==\n { fmt.Println(__gen__.(object).__class__); }')\n\n            out.append(self.indent() + 'if __ok__ { __type__ = __super__.getclassname();')\n            out.append(self.indent() + '} else { fmt.Println(\nGython RuntimeError - struct must implement the `object` interface\n); }')\n\n            out.append(self.indent() + 'switch __type__ {')\n            #out.append(self.indent() + 'switch __gen__.(type) {')  ## this is not always correct\n            #out.append('fmt.Println(\nclass name: \n, __type__)')\n\n            self.push()\n            gsorted = list(generics)\n            gsorted.sort()\n            gsorted.reverse()\n            #for gt in generics:\n            ## this fails with a struct returned from a super method that returns self,\n            ## the generic function will fail with a nil struct, while it still works when passed the instance directly.\n            for gt in gsorted:\n                assert gt in self._classes\n                #if node.name in self._classes[gt]._subclasses:\n                #if len(self._classes[gt]._parents) == 0:\n\n                ## if in super class ##\n                if self._class_stack and len(self._classes[self._class_stack[-1].name]._parents) == 0:\n                    if return_type=='*'+gt or not is_method: pass\n                    else: continue\n                elif len(self._classes[gt]._parents) == 0: ## or if the generic is the super class skip it.\n                    if return_type=='*'+gt or not is_method: pass\n                    else: continue\n\n                ######out.append(self.indent() + 'case *%s:' %gt)\n                out.append(self.indent() + 'case \n%s\n:' %gt)\n                self.push()\n\n                #out.append(self.indent() + '%s,_ := __gen__.(*%s)' %(gname,gt) )  ## can not depend on the struct type, because subclasses are unions.\n                out.append(self.indent() + '%s,__ok__ := __gen__.(*%s)' %(gname,gt) )  ## can not depend on the struct type, because subclasses are unions.\n\n                out.append(self.indent() + 'if __ok__ {')\n\n                for b in node.body:\n                    v = self.visit(b)\n                    if v:\n                        if returns_self:\n                            v = self._hack_return(v, return_type, gname, gt, node)\n                        out.append( self.indent() + v )\n\n                out.append(self.indent() + '} else {' )\n                if generic_base_class == gt or returns_self:\n                    out.append(' fmt.Println(\nGenerics RuntimeError - generic argument is not a pointer to a struct\n, %s);' %gname)\n                    out.append(' fmt.Println(\nstruct: \n,__gen__);' )\n                else:\n                    # __gen__.(C).foo();\n                    # this fails because the go compiler thinks that __gen__ is *B, when infact its *C\n                    # panic: interface conversion: interface is *main.B, not *main.C,\n                    # workaround: switch on type go thinks it is, and then recast to the real type.\n                    # s := C( *__gen__.(*B) )\n                    self.push()\n                    out.append( self.indent() + 'switch __gen__.(type) {' )\n                    self.push()\n                    for gt2 in gsorted:\n                        if gt2 != gt:\n                            out.append(self.indent() + 'case *%s:' %gt2)\n                            self.push()\n                            if gt2 == generic_base_class:\n                                ## TODO panic here\n                                out.append(' fmt.Println(\nGenerics RuntimeError - can not cast base class to a subclass type\n, %s);' %gname)\n                            else:\n                                out.append(self.indent() + '%s := %s( *__gen__.(*%s) )' %(gname, gt, gt2) )\n                                for b2 in node.body:\n                                    v = self.visit(b2)\n                                    if v:\n                                        #if returns_self:\n                                        #   v = self._hack_return(v, return_type, gname, gt, node)\n                                        out.append( self.indent() + v )\n\n                            self.pull()\n\n                    self.pull()\n                    out.append(self.indent() + '}')\n                    self.pull()\n                out.append(self.indent() + '}')\n                self.pull()\n            self.pull()\n            out.append(self.indent() + '}')\n\n            ## this only helps with debugging when the generic function is expected to return something\n            if return_type:\n                out.append(self.indent() + 'fmt.Println(\nGenerics RuntimeError - failed to convert type to:\n, __type__, __gen__)')\n\n            if return_type == 'int':\n                out.append(self.indent() + 'return 0')\n            elif return_type == 'float':\n                out.append(self.indent() + 'return 0.0')\n            elif return_type == 'string':\n                out.append(self.indent() + 'return \n')\n            elif return_type == 'bool':\n                out.append(self.indent() + 'return false')\n            elif return_type:\n                #raise NotImplementedError('TODO other generic function return types', return_type)\n                out.append(self.indent() + 'return %s' %(return_type.replace('*','\n')+'{}'))\n\n        elif use_generics: ## no generics in args, generate generics caller switching\n            body = node.body[:]\n            body.reverse()\n            self.generate_generic_branches( body, out, self._vars, self._known_vars )\n\n        else: ## without generics ##\n            for b in node.body:\n                out.append(self.indent()+self.visit(b))\n\n        self._scope_stack = []\n\n        if is_method and return_type and node.name.endswith('__init__'):\n            ## note: this could be `__init__` or `ParentClass__init__`.\n            has_return = False\n            for ln in out:\n                if ln.strip().startswith('return '):\n                    has_return = True\n                    break\n\n            if not has_return:\n                out.append('return self')\n\n        self.pull()\n        out.append( self.indent()+'}' )\n        return '\\n'.join(out)\n\n    def _hack_return(self, v, return_type, gname, gt, node):\n        ## TODO - fix - this breaks easily\n        if v.strip().startswith('return ') and '*'+gt != return_type:\n            if gname in v and v.strip() != 'return self':\n                if '(' not in v:\n                    v += '.(%s)' %return_type\n                    v = v.replace(gname, '__gen__')\n                    self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n        return v\n\n    def generate_generic_branches(self, body, out, force_vars, force_used_vars):\n        #out.append('/* GenerateGeneric */')\n        #out.append('/*vars: %s*/' %self._vars)\n        #out.append('/*used: %s*/' %self._known_vars)\n\n        #force_vars, force_used_vars = self._scope_stack[-1]\n        self._vars = set(force_vars)\n        self._known_vars = set(force_used_vars)\n\n        #out.append('/*force vars: %s*/' %force_vars)\n        #out.append('/*force used: %s*/' %force_used_vars)\n\n        prev_vars = None\n        prev_used = None\n        vars = None\n        used = None\n\n        vars = set(self._vars)\n        used = set(self._known_vars)\n\n        #out.append('/*Sstack len: %s*/' %len(self._scope_stack))\n        #if self._scope_stack:\n        #   out.append('/*stack: %s - %s*/' %self._scope_stack[-1])\n        #   out.append('/*STAK: %s */' %self._scope_stack)\n\n\n        while len(body):\n            prev_vars = vars\n            prev_used = used\n\n            b = body.pop()\n            try:\n                v = self.visit(b)\n                if v: out.append( self.indent() + v )\n            except GenerateGenericSwitch as err:\n                self._scope_stack.append( (set(self._vars), set(self._known_vars)))\n\n                #out.append('/*         GenerateGenericSwitch */')\n                #out.append('/* vars: %s*/' %self._vars)\n                #out.append('/* used: %s*/' %self._known_vars)\n                #out.append('/* prev vars: %s*/' %prev_vars)\n                #out.append('/* prev used: %s*/' %prev_used)\n                #out.append('/* stack: %s - %s*/' %self._scope_stack[-1])\n                #out.append('/* stack len: %s*/' %len(self._scope_stack))\n                #out.append('/* stack: %s*/' %self._scope_stack)\n\n                G = err[0]\n                if 'target' not in G:\n                    if isinstance(b, ast.Assign):\n                        G['target'] = self.visit(b.targets[0])\n                    else:\n                        raise SyntaxError('no target to generate generic switch')\n\n\n                out.append(self.indent()+'__subclass__ := %s' %G['value'])\n                out.append(self.indent()+'switch __subclass__.__class__ {')\n                self.push()\n\n                subclasses = self.get_subclasses( G['class'] )\n                for sub in subclasses:\n                    #self._vars = prev_vars\n                    #self._known_vars = prev_used\n\n\n                    out.append(self.indent()+'case \n%s\n:' %sub)\n                    self.push()\n                    #out.append(self.indent()+'%s := __subclass__.(*%s)' %(G['target'], sub)) ## error not an interface\n                    #out.append(self.indent()+'%s := %s(*__subclass__)' %(G['target'], sub))\n                    out.append(self.indent()+'__addr := %s(*__subclass__)' %sub)\n                    out.append(self.indent()+'%s := \n__addr' %G['target'])\n\n                    pv, pu = self._scope_stack[-1]\n                    self.generate_generic_branches( body[:], out, pv, pu )\n\n                    self.pull()\n                self._scope_stack.pop()\n\n                self.pull()\n                out.append(self.indent()+'}')\n                return\n\n\n    def _visit_call_helper_var(self, node):\n        args = [ self.visit(a) for a in node.args ]\n        if node.keywords:\n            for key in node.keywords:\n                args.append( key.arg )\n\n        for name in args:\n            if name not in self._vars:\n                self._vars.add( name )\n\n        return ''  ## do not declare variables in function head for Go backend\n\n\n    def visit_Assign(self, node):\n        if isinstance(node.targets[0], ast.Tuple):\n            ## special case for rust compatible style of creating sender,recver,\n            ## which in go are actually the same channel, below the go channel is assigned to both targets.\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='__go_make_chan__':\n                sender = self.visit(node.targets[0].elts[0])\n                recver = self.visit(node.targets[0].elts[1])\n                T = self.visit(node.value.args[0])\n                return '%s := make(chan %s); %s := %s' %(sender, T, recver, sender)\n            else:\n                raise NotImplementedError('TODO')\n        self._catch_assignment = False\n\n        target = self.visit( node.targets[0] )\n\n\n        if isinstance(node.value, ast.BinOp) and self.visit(node.value.op)=='\n' and isinstance(node.value.left, ast.Call) and node.value.left.func.id=='__go__map__':\n            if isinstance(node.value.right, ast.Name) and node.value.right.id.startswith('__comp__'):\n                value = self.visit(node.value.right)\n                return '%s := %s;' % (target, value)  ## copy the map comprehension from the temp var to the original.\n\n        ################\n        if isinstance(node.value, ast.BinOp) and self.visit(node.value.op)=='\n' and isinstance(node.value.left, ast.Name) and node.value.left.id=='__go__send__':\n            value = self.visit(node.value.right)\n            return '%s \n- %s;' % (target, value)\n        else:\n            value = None\n            if isinstance(node.value, ast.Subscript) and isinstance(node.value.slice, ast.Slice):\n                if not node.value.slice.lower and not node.value.slice.upper and not node.value.slice.step:  ## copy array\n                    value = self.visit(node.value.value)\n                    self._known_arrays[target] = '?'\n\n            if value is None:\n                value = self.visit(node.value)\n                ## temp hack for 2D arrays\n                if value.startswith('(*[][]') and value.endswith(')') and ' \n ' in value:\n                    value = '\n' + value.split('\n')[0][2:].strip()\n\n            if not self._function_stack:\n                if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id in self._classes:\n                    #value = '__new__' + value\n                    return 'var %s *%s = %s;' % (target, node.value.func.id, value)\n                else:\n                    return 'var %s = %s;' % (target, value)\n\n            elif isinstance(node.targets[0], ast.Name) and node.targets[0].id in self._vars:\n                self._vars.remove( target )\n                self._known_vars.add( target )\n\n                if value.startswith('\n[]*') and self._catch_assignment:\n                    self._known_arrays[ target ] = self._catch_assignment['class']\n\n\n                if value.startswith('\n(*') and '[' in value and ']' in value:  ## slice hack\n                    v = value[1:]\n                    self._slice_hack_id += 1\n                    return '__slice%s := %s; %s := \n__slice%s;' %(self._slice_hack_id, v, target, self._slice_hack_id)\n\n                elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute) and isinstance(node.value.func.value, ast.Name):\n                    varname = node.value.func.value.id\n                    if varname in self._known_vars:\n                        #raise SyntaxError(varname + ' is known class::' + self._known_instances[varname] + '%s(%s)' % (fname, args))\n                        cname = self._known_instances[varname]\n                        if node.value.func.attr in self.method_returns_multiple_subclasses[ cname ]:\n                            self._known_instances[target] = cname\n                            #raise SyntaxError('xxxxxxxxx %s - %s' % (self.visit(node.value), target ) )\n                            raise GenerateGenericSwitch( {'target':target, 'value':value, 'class':cname, 'method':node.value.func.attr} )\n\n                    if target=='_':\n                        return '%s = %s;' % (target, value)\n                    else:\n                        return '%s := %s;' % (target, value)\n\n                elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n                    if node.value.func.id in self._classes:\n                        #raise SyntaxError(value+' in classes')\n                        self._known_instances[ target ] = node.value.func.id\n\n                    if target=='_':\n                        return '%s = %s;' % (target, value)\n                    else:\n                        return '%s := %s;' % (target, value)\n                elif target=='_':\n                    return '%s = %s;' % (target, value)\n                else:\n                    return '%s := %s;' % (target, value)\n\n            else:\n                #if '\n-' in value:\n                #   raise RuntimeError(target+value)\n                if value.startswith('\nmake('):\n                    #raise SyntaxError(value)\n                    v = value[1:]\n                    return '_tmp := %s; %s = \n_tmp;' %(v, target)\n                else:\n                    #if value.startswith('\n[]*') and self._catch_assignment:\n                    #   raise SyntaxError(value)\n                    return '%s = %s;' % (target, value)\n\n    def visit_While(self, node):\n        cond = self.visit(node.test)\n        if cond == 'true' or cond == '1': cond = ''\n        body = [ 'for %s {' %cond]\n        self.push()\n        for line in list( map(self.visit, node.body) ):\n            body.append( self.indent()+line )\n        self.pull()\n        body.append( self.indent() + '}' )\n        return '\\n'.join( body )\n\n    def _inline_code_helper(self, s):\n        return s\n\n\ndef translate_to_go(script, insert_runtime=True):\n    if '--debug-inter' in sys.argv:\n        raise RuntimeError(script)\n    if insert_runtime:\n        runtime = open( os.path.join(RUSTHON_LIB_ROOT, 'src/runtime/go_builtins.py') ).read()\n        script = runtime + '\\n' + script\n\n    try:\n        tree = ast.parse(script)\n    except SyntaxError as err:\n        sys.stderr.write(script)\n        raise err\n\n    g = GoGenerator( source=script )\n    g.visit(tree) # first pass gathers classes\n    pass2 = g.visit(tree)\n\n\n    ## linux package: apt-get install golang\n    exe = '/usr/bin/go'\n    if not os.path.isfile(exe):\n        ## default path on linux from the offical Go docs - installed with their installer ##\n        exe = '/usr/local/go/bin/go'  \n        if not os.path.isfile(exe):\n            exe = os.path.expanduser('~/go/bin/go')  ## fall back to user home directory\n            if not os.path.isfile(exe):\n                print 'WARNING: could not find go compiler'\n                print 'only a single translation pass was performed'\n                print '(the generated code may not compile)'\n                return pass2\n\n    ## this hack runs the code generated in the second pass into the Go compiler to check for errors,\n    ## where an interface could not be type asserted, because Go found that the variable was not an interface,\n    ## parsing the errors from `go build` and matching the magic ids, in self.unodes on the node is set\n    ## `is_struct_pointer`, this triggers different code to be generated in the 3rd pass.\n    ## the Gython translator also has the same type information as Go, but it is simpler to use this hack.\n    import subprocess\n    pass2lines = pass2.splitlines()\n    path = tempfile.gettempdir() + '/pass2.go'\n    open(path, 'wb').write( pass2 )\n    p = subprocess.Popen([exe, 'build', path], cwd=tempfile.gettempdir(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    errors = p.stderr.read().splitlines()\n    if len(errors):\n        for line in errors:\n            if 'invalid type assertion' in line:\n                if 'non-interface type' in line:\n                    lineno = int( line.split(':')[1] )\n                    src = pass2lines[ lineno-1 ]\n                    assert '__magic__' in src\n                    id = src.strip().split()[0]\n                    g.unodes[id].is_struct_pointer = True\n                else:\n                    raise SyntaxError(line)\n\n    return g.visit(tree) ## pass3", 
            "title": "GolangTranslator"
        }, 
        {
            "location": "/gotranslator/#go-translator", 
            "text": "note: The GoGenerator class subclasses from javascript generator.  \ngo_types = 'bool string int float64'.split()\n\nclass GoGenerator( JSGenerator ):\n    def __init__(self, source=None, requirejs=False, insert_runtime=False):\n        assert source\n        JSGenerator.__init__(self, source=source, requirejs=False, insert_runtime=False)\n\n        self._go = True\n        self._dart = False\n        self._class_stack = list()\n        self._classes = dict()      ## name : node\n        #   node._parents = set()\n        #   node._struct_def = dict()\n        #   node._subclasses = set()  ## required for generics generator\n        #   ## subclasses must be a struct union so that Go can convert between struct types\n        #   node._subclasses_union = dict()\n        self.method_returns_multiple_subclasses = dict() # class name : method name that can return multiple subclass types\n        self._class_props = dict()\n\n        self._vars = set()\n        self._known_vars = set()\n        self._kwargs_type_ = dict()\n\n        self._imports = set()\n        self._ids = 0\n        self._known_instances = dict()\n        self._known_arrays    = dict()\n        self._known_maps      = dict()\n        self._scope_stack = list()\n\n        self.interfaces = dict()  ## for Go backend, TODO unify Go/Rust/C++ logic\n        self.uids = 0\n        self.unodes = dict()\n\n        self._slice_hack_id = 0\n\n    def uid(self):\n        self.uids += 1\n        return self.uids\n\n\n    def visit_Import(self, node):\n        r = [alias.name.replace('__SLASH__', '/') for alias in node.names]\n        res = []\n        if r:\n            for name in r:\n                self._imports.add('import( %s );' %name)\n\n        if res:\n            return '\\n'.join(res)\n        else:\n            return ''\n\n    def visit_Str(self, node):\n        s = node.s.replace( \\\\ ,  \\\\\\\\ ).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace(' ', '\\\\ ')\n        return ' %s ' % s\n\n    def visit_Is(self, node):\n        return '=='\n    def visit_IsNot(self, node):\n        return '!='\n\n    def visit_If(self, node):\n        out = []\n        test = self.visit(node.test)\n        if test.startswith('(') and test.endswith(')'):\n            out.append( 'if %s {' %test )\n        else:\n            out.append( 'if (%s) {' %test )\n\n        self.push()\n\n        for line in list(map(self.visit, node.body)):\n            if line is None: continue\n            out.append( self.indent() + line )\n\n        orelse = []\n        for line in list(map(self.visit, node.orelse)):\n            orelse.append( self.indent() + line )\n\n        self.pull()\n\n        if orelse:\n            out.append( self.indent() + '} else {')\n            out.extend( orelse )\n\n        out.append( self.indent() + '}' )\n\n        return '\\n'.join( out )\n\n    def visit_Name(self, node):\n        if node.id == 'None':\n            return 'nil'\n        elif node.id == 'True':\n            return 'true'\n        elif node.id == 'False':\n            return 'false'\n        #elif node.id == 'null':\n        #   return 'nil'\n        return node.id\n\n    def get_subclasses( self, C ):\n        '''\n        returns all sibling subclasses, C can be a subclass or the base class\n        '''\n        subclasses = set()\n        self._collect_subclasses(C, subclasses)\n        return subclasses\n\n    def _collect_subclasses(self, C, subclasses):\n        node = self._classes[ C ]\n        if len(node._parents)==0:\n            for sub in node._subclasses:\n                subclasses.add( sub )\n        else:\n            for parent in node._parents:\n                self._collect_subclasses(parent, subclasses)\n\n\n    def visit_ClassDef(self, node):\n        self._class_stack.append( node )\n        if not hasattr(node, '_parents'):  ## only setup on the first pass\n            node._parents = set()\n            node._struct_def = dict()\n            node._subclasses = set()  ## required for generics generator\n            ## subclasses must be a struct union so that Go can convert between struct types\n            node._subclasses_union = dict()\n\n        out = []\n        sdef = dict()\n        props = set()\n        bases = set()\n        base_classes = set()\n\n        self._classes[ node.name ] = node\n        self._class_props[ node.name ] = props\n        if node.name not in self.method_returns_multiple_subclasses:\n            self.method_returns_multiple_subclasses[ node.name ] = set()\n\n        self.interfaces[ node.name ] = set()\n\n\n        for base in node.bases:\n            n = self.visit(base)\n            if n == 'object':\n                continue\n            node._parents.add( n )\n\n            bases.add( n )\n            if n in self._class_props:\n                props.update( self._class_props[n] )\n                base_classes.add( self._classes[n] )\n            #else:  ## special case - subclassing a builtin like `list`\n            #   continue\n\n            for p in self._classes[ n ]._parents:\n                bases.add( p )\n                props.update( self._class_props[p] )\n                base_classes.add( self._classes[p] )\n\n            self._classes[ n ]._subclasses.add( node.name )\n\n\n        for decor in node.decorator_list:  ## class decorators\n            if isinstance(decor, ast.Call):\n                assert decor.func.id=='__struct__'\n                #props.update( [self.visit(a) for a in decor.args] )\n                for kw in decor.keywords:\n                    props.add( kw.arg )\n                    T = kw.value.id\n                    if T == 'interface': T = 'interface{}'\n                    sdef[ kw.arg ] = T\n\n\n        init = None\n        method_names = set()\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                method_names.add( b.name )\n                if b.name == '__init__':\n                    init = b\n            elif isinstance(b, ast.Expr) and isinstance(b.value, ast.Dict):\n                for i in range( len(b.value.keys) ):\n                    k = self.visit( b.value.keys[ i ] )\n                    if isinstance(b.value.values[i], ast.Str):\n                        v = b.value.values[i].s\n                    else:\n                        v = self.visit( b.value.values[i] )\n                    if v == 'interface': v = 'interface{}'\n                    sdef[k] = v\n\n        for k in sdef:\n            v = sdef[k]\n            if v=='interface{}':\n                self.interfaces[node.name].add(k)\n\n        node._struct_def.update( sdef )\n        unionstruct = dict()\n        unionstruct.update( sdef )\n        for pname in node._parents:\n            parent = self._classes[ pname ]\n            parent._subclasses_union.update( sdef )        ## first pass\n            unionstruct.update( parent._subclasses_union ) ## second pass\n\n\n        parent_init = None\n        if base_classes:\n            for bnode in base_classes:\n                for b in bnode.body:\n                    if isinstance(b, ast.FunctionDef):\n                        if b.name in method_names:\n                            self.catch_call.add( '%s.%s' %(bnode.name, b.name))\n                            n = b.name\n                            b.name = '%s_%s'%(bnode.name, b.name)\n                            out.append( self.visit(b) )\n                            b.name = n\n                            continue\n                        if b.name == '__init__':\n                            parent_init = {'class':bnode, 'init':b}\n                            #continue\n                        out.append( self.visit(b) )\n\n\n        out.append( 'type %s struct {' %node.name)\n        if len(node._parents)==0:\n            out.append('__object__')\n\n        if base_classes:\n            for bnode in base_classes:\n                ## Go only needs the name of the parent struct and all its items are inserted automatically ##\n                out.append('%s' %bnode.name)\n                ## Go allows multiple a variable to redefined by the sub-struct,\n                ## but this can throw an error: `invalid operation: ambiguous selector`\n                ## removing the duplicate name here fixes that error.\n                for key in bnode._struct_def.keys():\n                    #if key in sdef:\n                    #   sdef.pop(key)\n                    if key in unionstruct:\n                        unionstruct.pop(key)\n\n        #for name in sdef:\n        #   out.append('%s %s' %(name, sdef[name]))\n        for name in unionstruct:\n            out.append('%s %s' %(name, unionstruct[name]))\n        out.append('}')\n\n\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                out.append( self.visit(b) )\n\n        if init or parent_init:\n            if parent_init:\n                classname = parent_init['class'].name\n                init = parent_init['init']\n            else:\n                classname = node.name\n\n            out.append( 'func __new__%s( %s ) *%s {' %(node.name, init._args_signature, node.name))\n            out.append( '  ob := %s{}' %node.name )\n            out.append( '  ob.__init__(%s)' %','.join(init._arg_names))\n            ## used by generics to workaround the problem that a super method that returns `self`,\n            ## may infact return wrong subclass type, because a struct to return that is not of type\n            ## self will be cast to self - while this is ok if just reading attributes from it,\n            ## it fails with method calls, because the casting operation on the struct changes its\n            ## method pointers.  by storing the class name on the instance, it can be used in a generics\n            ## type switch to get to the real class and call the right methods.\n            out.append( '  ob.__class__ =  %s ' %node.name)\n            out.append( '  return  ob')\n            out.append('}')\n\n        else:\n            #out.append( 'func __new__%s() *%s { return  %s{} }' %(node.name, node.name, node.name))\n            out.append( 'func __new__%s() *%s {' %(node.name, node.name))\n            out.append( '  ob := %s{}' %node.name )\n            out.append( '  ob.__class__ =  %s ' %node.name)\n            out.append( '  return  ob')\n            out.append('}')\n\n\n\n        self.catch_call = set()\n        self._class_stack.pop()\n        return '\\n'.join(out)\n\n\n    def _visit_call_special( self, node ):\n        fname = self.visit(node.func)\n        assert fname in self.catch_call\n        assert len(self._class_stack)\n        if len(node.args):\n            if isinstance(node.args[0], ast.Name) and node.args[0].id == 'self':\n                node.args.remove( node.args[0] )\n\n        #name = '_%s_' %self._class_stack[-1].name\n        name = 'self.'\n        name += fname.replace('.', '_')\n        return self._visit_call_helper(node, force_name=name)\n\n\n    def visit_Subscript(self, node):\n        if isinstance(node.slice, ast.Ellipsis):\n            return '(*%s)' %self.visit(node.value)\n        else:\n            ## deference pointer and then index\n            if isinstance(node.slice, ast.Slice):\n                r = ' (*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n            else:\n                r = '(*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n\n            #if isinstance(node.value, ast.Name) and node.value.id in self._known_arrays:\n            #   target = node.value.id\n            #   #value = self.visit( node.value )\n            #   cname = self._known_arrays[target]\n            #   #raise GenerateGenericSwitch( {'target':target, 'value':r, 'class':cname} )\n            #   raise GenerateGenericSwitch( {'value':r, 'class':cname} )\n\n            return r\n\n\n\n    def visit_Slice(self, node):\n        lower = upper = step = None\n        if node.lower:\n            lower = self.visit(node.lower)\n        if node.upper:\n            upper = self.visit(node.upper)\n        if node.step:\n            step = self.visit(node.step)\n\n        if lower and upper:\n            return '%s:%s' %(lower,upper)\n        elif upper:\n            return ':%s' %upper\n        elif lower:\n            return '%s:'%lower\n        else:\n            raise SyntaxError('TODO slice')\n\n\n    def visit_Print(self, node):\n        r = []\n        for e in node.values:\n            s = self.visit(e)\n            if s is None: raise RuntimeError(e)\n            if isinstance(e, ast.List):\n                r.append('fmt.Println(%s);' %s[1:-1])\n            else:\n                r.append('fmt.Println(%s);' %s)\n        return ''.join(r)\n\n    def visit_Expr(self, node):\n        return self.visit(node.value)\n\n\n    def visit_Module(self, node):\n        header = [\n            'package main',\n            'import  fmt ',\n            #'import  reflect '\n        ]\n        lines = []\n\n        for b in node.body:\n            line = self.visit(b)\n\n            if line:\n                for sub in line.splitlines():\n                    if sub==';':\n                        raise SyntaxError(line)\n                    else:\n                        lines.append( sub )\n            else:\n                if isinstance(b, ast.Import):\n                    pass\n                elif isinstance(b, ast.ImportFrom):\n                    pass\n                else:\n                    raise SyntaxError(b)\n\n        lines.append('type _kwargs_type_ struct {')\n        for name in self._kwargs_type_:\n            type = self._kwargs_type_[name]\n            lines.append( '  %s %s' %(name,type))\n            lines.append( '  __use__%s bool' %name)\n        lines.append('}')\n\n        lines = header + list(self._imports) + lines\n        return '\\n'.join( lines )\n\n\n    def visit_Compare(self, node):\n        comp = [ '(']\n        comp.append( self.visit(node.left) )\n        comp.append( ')' )\n\n        for i in range( len(node.ops) ):\n            comp.append( self.visit(node.ops[i]) )\n\n            if isinstance(node.comparators[i], ast.BinOp):\n                comp.append('(')\n                comp.append( self.visit(node.comparators[i]) )\n                comp.append(')')\n            else:\n                comp.append( self.visit(node.comparators[i]) )\n\n        return ' '.join( comp )\n\n    def visit_For(self, node):\n        target = self.visit(node.target)\n        lines = []\n        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, ast.Name):\n\n            if node.iter.func.id == 'range':\n                if len(node.iter.args)==1:\n                    iter = self.visit(node.iter.args[0])\n                    lines.append('for %s := 0; %s   %s; %s++ {' %(target, target, iter, target))\n                elif len(node.iter.args)==2:\n                    start = self.visit(node.iter.args[0])\n                    iter = self.visit(node.iter.args[1])\n                    lines.append('for %s := %s; %s   %s; %s++ {' %(target, start, target, iter, target))\n                else:\n                    raise SyntaxError('invalid for range loop')\n\n            elif node.iter.func.id == 'enumerate':\n                iter = self.visit(node.iter.args[0])\n                idx = self.visit(node.target.elts[0])\n                tar = self.visit(node.target.elts[1])\n                lines.append('for %s,%s := range *%s {' %(idx,tar, iter))\n\n            else: ## generator function\n                gfunc = node.iter.func.id\n                gargs = ','.join( [self.visit(e) for e in node.iter.args] )\n                lines.append('__gen%s := __new__%s(%s)' %(gfunc,gfunc, gargs))\n                lines.append('for __gen%s.__done__ != 1 {' %gfunc)\n                lines.append('  %s := __gen%s.next()' %(self.visit(node.target), gfunc))\n\n        elif isinstance(node.target, ast.List) or isinstance(node.target, ast.Tuple):\n            iter = self.visit( node.iter )\n            key = self.visit(node.target.elts[0])\n            val = self.visit(node.target.elts[1])\n            lines.append('for %s,%s := range *%s {' %(key,val, iter))\n\n        else:\n            iter = self.visit( node.iter )\n            lines.append('for _,%s := range *%s {' %(target, iter))\n\n        self.push()\n        for b in node.body:\n            lines.append( self.indent()+self.visit(b) )\n        self.pull()\n        lines.append( self.indent()+'}' )  ## end of for loop\n        return '\\n'.join(lines)\n\n\n    def _visit_call_helper(self, node, force_name=None):\n        fname = force_name or self.visit(node.func)\n        is_append = False\n        if fname.endswith('.append'):\n            is_append = True\n            arr = fname.split('.append')[0]\n        ####################################\n        if fname=='main':  ## can not directly call `main` in Go\n            return '/*run main*/'\n        elif fname == '__arg_array__':\n            assert len(node.args)==1\n            T = self.parse_go_style_arg(node.args[0])\n            if self.is_prim_type(T):\n                return '*[]%s' %T\n            else:\n                return '*[]*%s' %T\n\n        elif fname=='__let__':\n            if len(node.args) and isinstance(node.args[0], ast.Attribute): ## syntax `let self.x:T = y`\n                assert node.args[0].value.id == 'self'\n                assert len(node.args)==3\n                T = None\n                value = self.visit(node.args[2])\n                if isinstance(node.args[1], ast.Str):\n                    T = node.args[1].s\n                else:\n                    T = self.visit(node.args[1])\n\n                return 'self.%s = %s' %(node.args[0].attr, self.visit(node.args[2]))\n            else:\n                raise RuntimeError('TODO let...')\n\n\n        elif fname == 'range':  ## hack to support range builtin, translates to `range1,2,3`\n            assert len(node.args)\n            fname += str(len(node.args))\n        elif fname == 'len':\n            return 'len(*%s)' %self.visit(node.args[0])\n        elif fname == 'go.type_assert':\n            raise RuntimeError('go.type_assert is deprecated')\n            val = self.visit(node.args[0])\n            type = self.visit(node.args[1])\n            raise GenerateTypeAssert( {'type':type, 'value':val} )\n            ## below is deprecated\n            if type == 'self':\n                ## todo how to better mark interfaces, runtime type switch?\n                if '.' in type and type.split('.')[0]=='self' and type.split('.')[-1] in self.interfaces[self._class_stack[-1].name]:\n                    val += '.(%s)' %self._class_stack[-1].name\n                    return ' %s(%s)' %(type, val )\n                else:\n                    type = ' ' + self._class_stack[-1].name\n            else:\n                type = '*' + type  ## TODO tests - should this be  \n            #return 'interface{}(%s).(%s)' %(self.visit(node.args[0]), type)\n\n\n            return '%s(*%s)' %(type, val )\n\n\n        if node.args:\n            args = [self.visit(e) for e in node.args]\n            args = ', '.join([e for e in args if e])\n        else:\n            args = ''\n\n        if node.keywords:\n            if args: args += ','\n            args += '_kwargs_type_{'\n            x = ['%s:%s' %(kw.arg,self.visit(kw.value)) for kw in node.keywords]\n            x.extend( ['__use__%s:true' %kw.arg for kw in node.keywords] )\n            args += ','.join( x )\n            args += '}'\n\n        if node.starargs:\n            if args: args += ','\n            args += '*%s...' %self.visit(node.starargs)\n\n        if is_append:\n            ## deference pointer as first arg to append, assign to temp variable, then set the pointer to the new array.\n            id = self._ids\n            self._ids += 1\n            item = args\n\n            if item in self._known_instances:\n                classname = self._known_instances[ item ]\n                #raise SyntaxError( self._known_instances[item] )\n                #if arr in self._known_vars:\n                #   raise SyntaxError('kow')\n                if arr in self._known_arrays and classname != self._known_arrays[arr]:\n                    #raise SyntaxError( self._known_arrays[arr])\n                    item = '%s(*%s)' %(self._known_arrays[arr], item)\n                    r = '__addr%s := %s;' %(id,item)\n                    return r + '__%s := append(*%s, __addr%s); *%s = __%s;' % (id, arr, id, arr, id)\n\n            return '__%s := append(*%s,%s); *%s = __%s;' % (id, arr, item, arr, id)\n\n        else:\n\n            if isinstance(node.func, ast.Attribute) and False:\n                if isinstance(node.func.value, ast.Name):\n                    varname = node.func.value.id\n                    if varname in self._known_vars:\n                        #raise SyntaxError(varname + ' is known class::' + self._known_instances[varname] + '%s(%s)' % (fname, args))\n                        cname = self._known_instances[varname]\n                        if node.func.attr in self.method_returns_multiple_subclasses[ cname ]:\n                            raise SyntaxError('%s(%s)' % (fname, args))\n\n            if fname in self._classes:\n                fname = '__new__%s' %fname\n\n            return '%s(%s)' % (fname, args)\n\n\n    def visit_Assert(self, node):\n        return 'if ((%s) == false) { panic( assertion failed ); }' %self.visit(node.test)\n\n\n    def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n        right = self.visit(node.right)\n\n        if op == ' ' and left == '__new__':\n            ## calls generated class constructor: user example `new MyClass()` ##\n            ## for rare cases where the translator is not aware of some transpiled class ##\n            if not right.startswith('__new__'):\n                return '__new__%s' %right\n            else:\n                return right\n\n        elif op == ' ':\n            if left in ('__go__receive__', '__go__send__'):\n                return ' - %s' %right\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id in ('__go__array__', '__go__arrayfixed__', '__go__map__', '__go__func__'):\n                if node.left.func.id == '__go__func__':\n                    raise SyntaxError('TODO - go.func')\n                elif node.left.func.id == '__go__map__':\n                    key_type = self.visit(node.left.args[0])\n                    value_type = self.visit(node.left.args[1])\n                    if value_type == 'interface': value_type = 'interface{}'\n                    return ' map[%s]%s%s' %(key_type, value_type, right)\n                else:\n                    if not right.startswith('{') and not right.endswith('}'):\n                        right = '{%s}' %right[1:-1]\n\n                    if node.left.func.id == '__go__array__':\n                        T = self.visit(node.left.args[0])\n                        if T in go_types:\n                            return ' []%s%s' %(T, right)\n                        else:\n                            self._catch_assignment = {'class':T}  ## visit_Assign catches this\n                            return ' []*%s%s' %(T, right)\n                    elif node.left.func.id == '__go__arrayfixed__':\n                        asize = self.visit(node.left.args[0])\n                        atype = self.visit(node.left.args[1])\n                        if atype not in go_types:\n                            if right != '{}': raise SyntaxError('todo init array of objects with args')\n                            return ' make([]*%s, %s)' %(atype, asize)\n                        else:\n                            return ' [%s]%s%s' %(asize, atype, right)\n            elif isinstance(node.left, ast.Name) and node.left.id=='__go__array__' and op == ' ':\n                return '*[]%s' %self.visit(node.right)\n\n        if left in self._typed_vars and self._typed_vars[left] == 'numpy.float32':\n            left += '[_id_]'\n        if right in self._typed_vars and self._typed_vars[right] == 'numpy.float32':\n            right += '[_id_]'\n\n        return '(%s %s %s)' % (left, op, right)\n\n    def visit_Return(self, node):\n        if isinstance(node.value, ast.Tuple):\n            return 'return %s' % ', '.join(map(self.visit, node.value.elts))\n        if node.value:\n            try:\n                v = self.visit(node.value)\n            except GenerateTypeAssert as err:\n                G = err[0]\n                type = G['type']\n                if type == 'self':\n                    type = self._class_stack[-1].name\n\n\n                ## This hack using reflect will not work for either case where the value\n                ## maybe an empty interface, or a pointer to a struct, because it is known\n                ## to the Go compiler if the value is an interface or pointer to struct,\n                ## and will not allow the alternate case.\n                ## case struct pointer:  invalid type assertion: __unknown__.(*A) (non-interface type *A on left)\n                ## case empty interface: cannot convert __unknown__ (type interface {}) to type B: need type assertion\n                #out = [\n                #   '__unknown__ := %s' %G['value'],\n                #   'switch reflect.TypeOf(__unknown__).Kind() {',\n                #   ' case reflect.Interface:',\n                #   '    __addr := __unknown__.(*%s)' %type,\n                #   '    return __addr',\n                #   ' case reflect.Ptr:',\n                #   '    __addr := %s(__unknown__)' %type,\n                #   '    return __addr',\n                #   '}'\n                #]\n\n                if not hasattr(node.value, 'uid'):\n                    node.value.uid = self.uid()\n\n                id = '__magic__%s' % node.value.uid\n                if id not in self.unodes: self.unodes[ id ] = node.value\n\n                if hasattr(node.value, 'is_struct_pointer'):\n\n                    out = [\n                        '%s := %s( *%s )' %(id, type, G['value']),\n                        'return  %s' %id,\n                    ]\n                else:\n                    out = [\n                        '%s := %s.( *%s )' %(id, G['value'], type),\n                        'return %s' %id,\n                    ]\n\n                return '\\n'.join(out)\n\n\n\n            if v.startswith(' '):\n                return '_hack := %s; return  _hack' %v[1:]\n            else:\n                return 'return %s' % v\n        return 'return'\n\n    def _visit_function(self, node):\n        is_closure = False\n        if self._function_stack[0] is node:\n            self._vars = set()\n            self._known_vars = set()\n            self._known_instances = dict()\n            self._known_arrays    = dict()\n\n\n        elif len(self._function_stack)   1:\n            ## do not clear self._vars and _known_vars inside of closure\n            is_closure = True\n\n        args_typedefs = {}\n        chan_args_typedefs = {}\n        return_type = None\n        generic_base_class = None\n        generics = set()\n        args_generics = dict()\n        returns_self = False\n        use_generics = False\n\n        for decor in node.decorator_list:\n            if isinstance(decor, ast.Name) and decor.id=='generic':\n                use_generics = True\n\n\n        for decor in node.decorator_list:\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef__':\n                for key in decor.keywords:\n                    if isinstance( key.value, ast.Str):\n                        args_typedefs[ key.arg ] = key.value.s\n                    else:\n                        args_typedefs[ key.arg ] = self.visit(key.value)\n\n                    ## check for super classes - generics ##\n                    if use_generics and args_typedefs[ key.arg ] in self._classes:\n                        if node.name=='__init__':\n                            ## generics type switch is not possible in __init__ because\n                            ## it is used to generate the type struct, where types are static.\n                            ## as a workaround generics passed to init always become `interface{}`\n                            args_typedefs[ key.arg ] = 'interface{}'\n                            #self._class_stack[-1]._struct_def[ key.arg ] = 'interface{}'\n                        else:\n                            classname = args_typedefs[ key.arg ]\n                            generic_base_class = classname\n                            generics.add( classname ) # switch v.(type) for each\n                            generics = generics.union( self._classes[classname]._subclasses )\n                            args_typedefs[ key.arg ] = 'interface{}'\n                            args_generics[ key.arg ] = classname\n\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == '__typedef_chan__':\n                for key in decor.keywords:\n                    if isinstance(key.value, ast.Str):\n                        chan_args_typedefs[ key.arg ] = key.value.s.strip()\n                    else:\n                        chan_args_typedefs[ key.arg ] = self.visit(key.value)\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'returns':\n                if decor.keywords:\n                    raise SyntaxError('invalid go return type')\n                elif isinstance(decor.args[0], ast.Name):\n                    return_type = decor.args[0].id\n                else:\n                    return_type = decor.args[0].s\n\n                if return_type == 'self':\n                    return_type = '*' + self._class_stack[-1].name\n                    returns_self = True\n                    self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n\n        if return_type and not self.is_prim_type(return_type):\n            if not return_type.startswith('*') and not return_type.startswith(' ') and not return_type.startswith('func('):\n                return_type = '*'+return_type\n\n        node._arg_names = args_names = []\n        args = []\n        oargs = []\n        offset = len(node.args.args) - len(node.args.defaults)\n        varargs = False\n        varargs_name = None\n        is_method = False\n        for i, arg in enumerate(node.args.args):\n            arg_name = arg.id\n\n            if arg_name not in args_typedefs.keys()+chan_args_typedefs.keys():\n                if arg_name=='self':\n                    assert i==0\n                    is_method = True\n                    continue\n                else:\n                    err = 'error in function: %s' %node.name\n                    err += '\\n  missing typedef: %s' %arg.id\n                    raise SyntaxError(err)\n\n            if arg_name in args_typedefs:\n                arg_type = args_typedefs[arg_name]\n                #if generics and (i==0 or (is_method and i==1)):\n                if use_generics and generics and arg_name in args_generics.keys():  ## TODO - multiple generics in args\n                    a = '__gen__ %s' %arg_type\n                elif self.is_prim_type(arg_type):\n                    a = '%s %s' %(arg_name, arg_type)\n                elif not arg_type.startswith('*') and not arg_type.startswith(' ') and not arg_type.startswith('func('):\n                    ## assume pointer ##\n                    a = '%s *%s' %(arg_name, arg_type)\n                else:\n                    a = '%s %s' %(arg_name, arg_type)\n            else:\n                arg_type = chan_args_typedefs[arg_name]\n                if arg_type.startswith('Sender '):\n                    arg_type = arg_type[ len('Sender ') : -1 ]\n                elif arg_type.startswith('Receiver '):\n                    arg_type = arg_type[ len('Receiver ') : -1 ]\n                a = '%s chan %s' %(arg_name, arg_type)\n\n            dindex = i - offset\n\n\n            if dindex  = 0 and node.args.defaults:\n                default_value = self.visit( node.args.defaults[dindex] )\n                self._kwargs_type_[ arg_name ] = arg_type\n                oargs.append( (arg_name, default_value) )\n            else:\n                args.append( a )\n                node._arg_names.append( arg_name )\n\n        ##############################################\n        if oargs:\n            #args.append( '[%s]' % ','.join(oargs) )\n            #args.append( '{%s}' % ','.join(oargs) )\n            args.append( '__kwargs _kwargs_type_')\n            node._arg_names.append( '__kwargs' )\n\n        starargs = None\n        if node.args.vararg:\n            starargs = node.args.vararg\n            assert starargs in args_typedefs\n            args.append( '__vargs__ ...%s' %args_typedefs[starargs])\n            node._arg_names.append( starargs )\n\n        node._args_signature = ','.join(args)\n\n        ####\n        if is_method:\n            assert self._class_stack\n            method = '(self *%s)  ' %self._class_stack[-1].name\n        else:\n            method = ''\n        out = []\n        if is_closure:\n            if return_type:\n                out.append( '%s := func (%s) %s {\\n' % (node.name, ', '.join(args), return_type) )\n            else:\n                out.append( '%s := func (%s) {\\n' % (node.name, ', '.join(args)) )\n        else:\n            if return_type:\n                out.append( 'func %s%s(%s) %s {\\n' % (method, node.name, ', '.join(args), return_type) )\n            else:\n                out.append( 'func %s%s(%s) {\\n' % (method, node.name, ', '.join(args)) )\n        self.push()\n\n        if oargs:\n            for n,v in oargs:\n                out.append(self.indent() + '%s := %s' %(n,v))\n                out.append(self.indent() + 'if __kwargs.__use__%s { %s = __kwargs.%s }' %(n,n,n))\n\n        if starargs:\n            out.append(self.indent() + '%s :=  __vargs__' %starargs)\n\n        if use_generics and generics:\n            gname = args_names[ args_names.index(args_generics.keys()[0]) ]\n\n            #panic: runtime error: invalid memory address or nil pointer dereference\n            #[signal 0xb code=0x1 addr=0x0 pc=0x402440]\n            ##out.append(self.indent() + '__type__ := __gen__.(object).getclassname()')\n\n\n            out.append(self.indent() + '__type__ :=  INVALID ')\n            out.append(self.indent() + '__super__, __ok__ := __gen__.(object)')\n\n            #out.append(self.indent() + '__type__ = __super__.getclassname();')        ## TODO FIX ME\n            #out.append(self.indent() + 'fmt.Println(__type__); ')\n            #out.append(self.indent() + 'if __type__==  { fmt.Println(__gen__.(object).__class__); }')\n\n            out.append(self.indent() + 'if __ok__ { __type__ = __super__.getclassname();')\n            out.append(self.indent() + '} else { fmt.Println( Gython RuntimeError - struct must implement the `object` interface ); }')\n\n            out.append(self.indent() + 'switch __type__ {')\n            #out.append(self.indent() + 'switch __gen__.(type) {')  ## this is not always correct\n            #out.append('fmt.Println( class name:  , __type__)')\n\n            self.push()\n            gsorted = list(generics)\n            gsorted.sort()\n            gsorted.reverse()\n            #for gt in generics:\n            ## this fails with a struct returned from a super method that returns self,\n            ## the generic function will fail with a nil struct, while it still works when passed the instance directly.\n            for gt in gsorted:\n                assert gt in self._classes\n                #if node.name in self._classes[gt]._subclasses:\n                #if len(self._classes[gt]._parents) == 0:\n\n                ## if in super class ##\n                if self._class_stack and len(self._classes[self._class_stack[-1].name]._parents) == 0:\n                    if return_type=='*'+gt or not is_method: pass\n                    else: continue\n                elif len(self._classes[gt]._parents) == 0: ## or if the generic is the super class skip it.\n                    if return_type=='*'+gt or not is_method: pass\n                    else: continue\n\n                ######out.append(self.indent() + 'case *%s:' %gt)\n                out.append(self.indent() + 'case  %s :' %gt)\n                self.push()\n\n                #out.append(self.indent() + '%s,_ := __gen__.(*%s)' %(gname,gt) )  ## can not depend on the struct type, because subclasses are unions.\n                out.append(self.indent() + '%s,__ok__ := __gen__.(*%s)' %(gname,gt) )  ## can not depend on the struct type, because subclasses are unions.\n\n                out.append(self.indent() + 'if __ok__ {')\n\n                for b in node.body:\n                    v = self.visit(b)\n                    if v:\n                        if returns_self:\n                            v = self._hack_return(v, return_type, gname, gt, node)\n                        out.append( self.indent() + v )\n\n                out.append(self.indent() + '} else {' )\n                if generic_base_class == gt or returns_self:\n                    out.append(' fmt.Println( Generics RuntimeError - generic argument is not a pointer to a struct , %s);' %gname)\n                    out.append(' fmt.Println( struct:  ,__gen__);' )\n                else:\n                    # __gen__.(C).foo();\n                    # this fails because the go compiler thinks that __gen__ is *B, when infact its *C\n                    # panic: interface conversion: interface is *main.B, not *main.C,\n                    # workaround: switch on type go thinks it is, and then recast to the real type.\n                    # s := C( *__gen__.(*B) )\n                    self.push()\n                    out.append( self.indent() + 'switch __gen__.(type) {' )\n                    self.push()\n                    for gt2 in gsorted:\n                        if gt2 != gt:\n                            out.append(self.indent() + 'case *%s:' %gt2)\n                            self.push()\n                            if gt2 == generic_base_class:\n                                ## TODO panic here\n                                out.append(' fmt.Println( Generics RuntimeError - can not cast base class to a subclass type , %s);' %gname)\n                            else:\n                                out.append(self.indent() + '%s := %s( *__gen__.(*%s) )' %(gname, gt, gt2) )\n                                for b2 in node.body:\n                                    v = self.visit(b2)\n                                    if v:\n                                        #if returns_self:\n                                        #   v = self._hack_return(v, return_type, gname, gt, node)\n                                        out.append( self.indent() + v )\n\n                            self.pull()\n\n                    self.pull()\n                    out.append(self.indent() + '}')\n                    self.pull()\n                out.append(self.indent() + '}')\n                self.pull()\n            self.pull()\n            out.append(self.indent() + '}')\n\n            ## this only helps with debugging when the generic function is expected to return something\n            if return_type:\n                out.append(self.indent() + 'fmt.Println( Generics RuntimeError - failed to convert type to: , __type__, __gen__)')\n\n            if return_type == 'int':\n                out.append(self.indent() + 'return 0')\n            elif return_type == 'float':\n                out.append(self.indent() + 'return 0.0')\n            elif return_type == 'string':\n                out.append(self.indent() + 'return  ')\n            elif return_type == 'bool':\n                out.append(self.indent() + 'return false')\n            elif return_type:\n                #raise NotImplementedError('TODO other generic function return types', return_type)\n                out.append(self.indent() + 'return %s' %(return_type.replace('*',' ')+'{}'))\n\n        elif use_generics: ## no generics in args, generate generics caller switching\n            body = node.body[:]\n            body.reverse()\n            self.generate_generic_branches( body, out, self._vars, self._known_vars )\n\n        else: ## without generics ##\n            for b in node.body:\n                out.append(self.indent()+self.visit(b))\n\n        self._scope_stack = []\n\n        if is_method and return_type and node.name.endswith('__init__'):\n            ## note: this could be `__init__` or `ParentClass__init__`.\n            has_return = False\n            for ln in out:\n                if ln.strip().startswith('return '):\n                    has_return = True\n                    break\n\n            if not has_return:\n                out.append('return self')\n\n        self.pull()\n        out.append( self.indent()+'}' )\n        return '\\n'.join(out)\n\n    def _hack_return(self, v, return_type, gname, gt, node):\n        ## TODO - fix - this breaks easily\n        if v.strip().startswith('return ') and '*'+gt != return_type:\n            if gname in v and v.strip() != 'return self':\n                if '(' not in v:\n                    v += '.(%s)' %return_type\n                    v = v.replace(gname, '__gen__')\n                    self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n        return v\n\n    def generate_generic_branches(self, body, out, force_vars, force_used_vars):\n        #out.append('/* GenerateGeneric */')\n        #out.append('/*vars: %s*/' %self._vars)\n        #out.append('/*used: %s*/' %self._known_vars)\n\n        #force_vars, force_used_vars = self._scope_stack[-1]\n        self._vars = set(force_vars)\n        self._known_vars = set(force_used_vars)\n\n        #out.append('/*force vars: %s*/' %force_vars)\n        #out.append('/*force used: %s*/' %force_used_vars)\n\n        prev_vars = None\n        prev_used = None\n        vars = None\n        used = None\n\n        vars = set(self._vars)\n        used = set(self._known_vars)\n\n        #out.append('/*Sstack len: %s*/' %len(self._scope_stack))\n        #if self._scope_stack:\n        #   out.append('/*stack: %s - %s*/' %self._scope_stack[-1])\n        #   out.append('/*STAK: %s */' %self._scope_stack)\n\n\n        while len(body):\n            prev_vars = vars\n            prev_used = used\n\n            b = body.pop()\n            try:\n                v = self.visit(b)\n                if v: out.append( self.indent() + v )\n            except GenerateGenericSwitch as err:\n                self._scope_stack.append( (set(self._vars), set(self._known_vars)))\n\n                #out.append('/*         GenerateGenericSwitch */')\n                #out.append('/* vars: %s*/' %self._vars)\n                #out.append('/* used: %s*/' %self._known_vars)\n                #out.append('/* prev vars: %s*/' %prev_vars)\n                #out.append('/* prev used: %s*/' %prev_used)\n                #out.append('/* stack: %s - %s*/' %self._scope_stack[-1])\n                #out.append('/* stack len: %s*/' %len(self._scope_stack))\n                #out.append('/* stack: %s*/' %self._scope_stack)\n\n                G = err[0]\n                if 'target' not in G:\n                    if isinstance(b, ast.Assign):\n                        G['target'] = self.visit(b.targets[0])\n                    else:\n                        raise SyntaxError('no target to generate generic switch')\n\n\n                out.append(self.indent()+'__subclass__ := %s' %G['value'])\n                out.append(self.indent()+'switch __subclass__.__class__ {')\n                self.push()\n\n                subclasses = self.get_subclasses( G['class'] )\n                for sub in subclasses:\n                    #self._vars = prev_vars\n                    #self._known_vars = prev_used\n\n\n                    out.append(self.indent()+'case  %s :' %sub)\n                    self.push()\n                    #out.append(self.indent()+'%s := __subclass__.(*%s)' %(G['target'], sub)) ## error not an interface\n                    #out.append(self.indent()+'%s := %s(*__subclass__)' %(G['target'], sub))\n                    out.append(self.indent()+'__addr := %s(*__subclass__)' %sub)\n                    out.append(self.indent()+'%s :=  __addr' %G['target'])\n\n                    pv, pu = self._scope_stack[-1]\n                    self.generate_generic_branches( body[:], out, pv, pu )\n\n                    self.pull()\n                self._scope_stack.pop()\n\n                self.pull()\n                out.append(self.indent()+'}')\n                return\n\n\n    def _visit_call_helper_var(self, node):\n        args = [ self.visit(a) for a in node.args ]\n        if node.keywords:\n            for key in node.keywords:\n                args.append( key.arg )\n\n        for name in args:\n            if name not in self._vars:\n                self._vars.add( name )\n\n        return ''  ## do not declare variables in function head for Go backend\n\n\n    def visit_Assign(self, node):\n        if isinstance(node.targets[0], ast.Tuple):\n            ## special case for rust compatible style of creating sender,recver,\n            ## which in go are actually the same channel, below the go channel is assigned to both targets.\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='__go_make_chan__':\n                sender = self.visit(node.targets[0].elts[0])\n                recver = self.visit(node.targets[0].elts[1])\n                T = self.visit(node.value.args[0])\n                return '%s := make(chan %s); %s := %s' %(sender, T, recver, sender)\n            else:\n                raise NotImplementedError('TODO')\n        self._catch_assignment = False\n\n        target = self.visit( node.targets[0] )\n\n\n        if isinstance(node.value, ast.BinOp) and self.visit(node.value.op)==' ' and isinstance(node.value.left, ast.Call) and node.value.left.func.id=='__go__map__':\n            if isinstance(node.value.right, ast.Name) and node.value.right.id.startswith('__comp__'):\n                value = self.visit(node.value.right)\n                return '%s := %s;' % (target, value)  ## copy the map comprehension from the temp var to the original.\n\n        ################\n        if isinstance(node.value, ast.BinOp) and self.visit(node.value.op)==' ' and isinstance(node.value.left, ast.Name) and node.value.left.id=='__go__send__':\n            value = self.visit(node.value.right)\n            return '%s  - %s;' % (target, value)\n        else:\n            value = None\n            if isinstance(node.value, ast.Subscript) and isinstance(node.value.slice, ast.Slice):\n                if not node.value.slice.lower and not node.value.slice.upper and not node.value.slice.step:  ## copy array\n                    value = self.visit(node.value.value)\n                    self._known_arrays[target] = '?'\n\n            if value is None:\n                value = self.visit(node.value)\n                ## temp hack for 2D arrays\n                if value.startswith('(*[][]') and value.endswith(')') and '   ' in value:\n                    value = ' ' + value.split(' ')[0][2:].strip()\n\n            if not self._function_stack:\n                if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id in self._classes:\n                    #value = '__new__' + value\n                    return 'var %s *%s = %s;' % (target, node.value.func.id, value)\n                else:\n                    return 'var %s = %s;' % (target, value)\n\n            elif isinstance(node.targets[0], ast.Name) and node.targets[0].id in self._vars:\n                self._vars.remove( target )\n                self._known_vars.add( target )\n\n                if value.startswith(' []*') and self._catch_assignment:\n                    self._known_arrays[ target ] = self._catch_assignment['class']\n\n\n                if value.startswith(' (*') and '[' in value and ']' in value:  ## slice hack\n                    v = value[1:]\n                    self._slice_hack_id += 1\n                    return '__slice%s := %s; %s :=  __slice%s;' %(self._slice_hack_id, v, target, self._slice_hack_id)\n\n                elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute) and isinstance(node.value.func.value, ast.Name):\n                    varname = node.value.func.value.id\n                    if varname in self._known_vars:\n                        #raise SyntaxError(varname + ' is known class::' + self._known_instances[varname] + '%s(%s)' % (fname, args))\n                        cname = self._known_instances[varname]\n                        if node.value.func.attr in self.method_returns_multiple_subclasses[ cname ]:\n                            self._known_instances[target] = cname\n                            #raise SyntaxError('xxxxxxxxx %s - %s' % (self.visit(node.value), target ) )\n                            raise GenerateGenericSwitch( {'target':target, 'value':value, 'class':cname, 'method':node.value.func.attr} )\n\n                    if target=='_':\n                        return '%s = %s;' % (target, value)\n                    else:\n                        return '%s := %s;' % (target, value)\n\n                elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n                    if node.value.func.id in self._classes:\n                        #raise SyntaxError(value+' in classes')\n                        self._known_instances[ target ] = node.value.func.id\n\n                    if target=='_':\n                        return '%s = %s;' % (target, value)\n                    else:\n                        return '%s := %s;' % (target, value)\n                elif target=='_':\n                    return '%s = %s;' % (target, value)\n                else:\n                    return '%s := %s;' % (target, value)\n\n            else:\n                #if ' -' in value:\n                #   raise RuntimeError(target+value)\n                if value.startswith(' make('):\n                    #raise SyntaxError(value)\n                    v = value[1:]\n                    return '_tmp := %s; %s =  _tmp;' %(v, target)\n                else:\n                    #if value.startswith(' []*') and self._catch_assignment:\n                    #   raise SyntaxError(value)\n                    return '%s = %s;' % (target, value)\n\n    def visit_While(self, node):\n        cond = self.visit(node.test)\n        if cond == 'true' or cond == '1': cond = ''\n        body = [ 'for %s {' %cond]\n        self.push()\n        for line in list( map(self.visit, node.body) ):\n            body.append( self.indent()+line )\n        self.pull()\n        body.append( self.indent() + '}' )\n        return '\\n'.join( body )\n\n    def _inline_code_helper(self, s):\n        return s\n\n\ndef translate_to_go(script, insert_runtime=True):\n    if '--debug-inter' in sys.argv:\n        raise RuntimeError(script)\n    if insert_runtime:\n        runtime = open( os.path.join(RUSTHON_LIB_ROOT, 'src/runtime/go_builtins.py') ).read()\n        script = runtime + '\\n' + script\n\n    try:\n        tree = ast.parse(script)\n    except SyntaxError as err:\n        sys.stderr.write(script)\n        raise err\n\n    g = GoGenerator( source=script )\n    g.visit(tree) # first pass gathers classes\n    pass2 = g.visit(tree)\n\n\n    ## linux package: apt-get install golang\n    exe = '/usr/bin/go'\n    if not os.path.isfile(exe):\n        ## default path on linux from the offical Go docs - installed with their installer ##\n        exe = '/usr/local/go/bin/go'  \n        if not os.path.isfile(exe):\n            exe = os.path.expanduser('~/go/bin/go')  ## fall back to user home directory\n            if not os.path.isfile(exe):\n                print 'WARNING: could not find go compiler'\n                print 'only a single translation pass was performed'\n                print '(the generated code may not compile)'\n                return pass2\n\n    ## this hack runs the code generated in the second pass into the Go compiler to check for errors,\n    ## where an interface could not be type asserted, because Go found that the variable was not an interface,\n    ## parsing the errors from `go build` and matching the magic ids, in self.unodes on the node is set\n    ## `is_struct_pointer`, this triggers different code to be generated in the 3rd pass.\n    ## the Gython translator also has the same type information as Go, but it is simpler to use this hack.\n    import subprocess\n    pass2lines = pass2.splitlines()\n    path = tempfile.gettempdir() + '/pass2.go'\n    open(path, 'wb').write( pass2 )\n    p = subprocess.Popen([exe, 'build', path], cwd=tempfile.gettempdir(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    errors = p.stderr.read().splitlines()\n    if len(errors):\n        for line in errors:\n            if 'invalid type assertion' in line:\n                if 'non-interface type' in line:\n                    lineno = int( line.split(':')[1] )\n                    src = pass2lines[ lineno-1 ]\n                    assert '__magic__' in src\n                    id = src.strip().split()[0]\n                    g.unodes[id].is_struct_pointer = True\n                else:\n                    raise SyntaxError(line)\n\n    return g.visit(tree) ## pass3", 
            "title": "Go Translator"
        }, 
        {
            "location": "/cpprustbase/", 
            "text": "C++ and Rust\n\n\ncommon base\n\n\nTODO: do not subclass from \nGoGenerator\n\n\n\nclass CppRustBase( GoGenerator ):\n\n    def __init__(self, source=None, requirejs=False, insert_runtime=False):\n        assert source\n        GoGenerator.__init__(self, source=source, requirejs=False, insert_runtime=False)\n        self._global_types = {\n            'string' : set()\n        }\n        self._with_type = []\n        self._switch_on_type_object = []\n        self._lambda_stack = []\n        self._memory = ['HEAP']  ## affects how `.` is default translated to `-\n` or `.`\n        self._rust = True\n        self._go   = False\n        self._threads = []  ## c++11 threads\n        self._unique_ptr = False ## TODO\n        self._has_channels = False\n        self._crates = {}\n        self._root_classes = {}\n        self._java_classpaths = []\n        self._known_strings = set()\n        self._force_cstr = False\n        self._known_pointers = {}\n        self._global_arrays  = {}\n        self._global_refs    = {}\n        self._typedefs       = {}\n        self._in_constant    = False\n        self._known_tuples   = {}\n        self._global_tuples  = {}\n        self.macros = {}\n\n\n    def _inline_code_helper(self, s):\n        return s\n\n    def visit_Expr(self, node):\n        # XXX: this is UGLY\n        s = self.visit(node.value)\n        if s is None:\n            raise RuntimeError('error in rusttranslator.md:' +node.value.func.id)\n        if s.strip() and not s.endswith(';'):\n            s += ';'\n        if s==';': return ''\n        else: return s\n\n\n    def visit_Str(self, node):\n        s = node.s.replace(\n\\\\\n, \n\\\\\\\\\n).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\n', '\\\\\n')\n        #return '\n%s\n' % s\n        if self._function_stack: return '\n%s\n.to_string()' % s\n        else: return '\n%s\n' % s\n\n    def visit_Is(self, node):\n        return '=='\n\n    def visit_IsNot(self, node):\n        return '!='\n\n\n\n\n\nFor Loop\n\n\nhooks into bad magic hack, 2nd pass rustc compile.\n\n\n\n\n    def visit_For(self, node):\n        if not hasattr(node.iter, 'uid'):\n            ## in the first rustc pass we assume regular references using `\nX`,\n            ## for loops over an array of Strings requires the other type using just `X` or `ref X`\n            node.iter.uid = self.uid()\n            node.iter.is_ref = True\n            self.unodes[ node.iter.uid ] = node.iter\n\n        target = self.visit(node.target)\n        lines = []\n\n        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, ast.Name):\n\n            if node.iter.func.id == 'range':\n                if len(node.iter.args)==1:\n                    iter = self.visit(node.iter.args[0])\n                    if self._cpp:\n                        lines.append('for (int %s=0; %s\n%s; %s++) {' %(target, target, iter, target))\n                    else:\n                        lines.append('for %s in range(0u, %s) {' %(target, iter))\n                elif len(node.iter.args)==2:\n                    start = self.visit(node.iter.args[0])\n                    iter = self.visit(node.iter.args[1])\n                    if self._cpp:\n                        lines.append('for (int %s=%s; %s\n%s; %s++) {' %(target, start, target, iter, target))\n\n                    else:\n                        lines.append('for %s in range(%s as uint, %s as uint) {' %(target, start, iter))\n                else:\n                    raise SyntaxError('invalid for range loop')\n\n            elif node.iter.func.id == 'enumerate':\n                iter = self.visit(node.iter.args[0])\n                idx = self.visit(node.target.elts[0])\n                tar = self.visit(node.target.elts[1])\n                if self._cpp:\n                    lines.append('int %s = -1;' %idx)\n                    lines.append('for (auto \n%s: _ref_%s) {' %(tar, iter))  ## TODO remove _ref_\n                else:\n                    lines.append('let mut %s = -1i;' %idx)\n                    if node.iter.is_ref:\n                        lines.append('for \n%s in %s.iter() { //magic:%s' %(tar, iter, node.iter.uid))\n                    else:\n                        lines.append('for %s in %s.iter() { //magic:%s' %(tar, iter, node.iter.uid))\n\n                lines.append('  %s += 1;' %idx)\n\n            else: ## generator function\n                gfunc = node.iter.func.id\n                gargs = ','.join( [self.visit(e) for e in node.iter.args] )\n                lines.append('__gen%s := __new__%s(%s)' %(gfunc,gfunc, gargs))\n                lines.append('for __gen%s.__done__ != 1 {' %gfunc)\n                lines.append('  %s := __gen%s.next()' %(self.visit(node.target), gfunc))\n\n        elif isinstance(node.target, ast.List) or isinstance(node.target, ast.Tuple):\n            iter = self.visit( node.iter )\n            if len(node.target.elts)==3 and isinstance(node.target.elts[1], ast.Name) and node.target.elts[1].id == '__as__':\n                target = self.visit(node.target.elts[0])\n                astype = self.visit(node.target.elts[2])\n                if iter.startswith('PyObject_GetAttrString('):\n                    lines.append('PyObject* __pyiter__%s = PyObject_GetIter(%s);' %(target,iter))\n                    lines.append('while (auto _pyob_%s = PyIter_Next(__pyiter__%s)) {' %(target, target))\n                    if astype in 'int long i32 i64'.split():\n                        lines.append('  auto %s = PyInt_AS_LONG(_pyob_%s);' %(target,target))\n                else:\n                    lines.append('for (auto \n%s: *%s) {' %(target, iter))\n\n            else:\n                key = self.visit(node.target.elts[0])\n                val = self.visit(node.target.elts[1])\n                iname = iter.split('.')[0]\n                if self._cpp:\n                    if iname not in self._known_maps:\n                        raise SyntaxError(self.format_error('for loop target tuple unpack over some unknown type, not a known map'))\n                    lines.append('for (auto \n_pair_%s : *%s) {' %(key, iter))\n                    lines[-1] += '  auto %s = _pair_%s.first;' %(key, key)\n                    lines[-1] += '  auto %s = _pair_%s.second;' %(val, key)\n\n                else:  ## rust\n                    lines.append('for (%s,\n%s) in %s.iter() {' %(key,val, iter))\n\n        else:\n\n            iter = self.visit( node.iter )\n            arrname = iter.split('.')[0]\n            if node.iter.is_ref:\n                if self._cpp:\n                    if arrname in self._known_arrays:\n                        if isinstance(self._known_arrays[arrname], tuple):\n                            lines.append('for (int __idx=0; __idx\n%s; __idx++) { /*loop over fixed array*/' %self._known_arrays[arrname][1])\n                            lines.append(self.indent()+'%s %s = %s[__idx];' %(self._known_arrays[arrname][0], target, iter))\n                        elif arrname in self._known_refs:\n                            lines.append('for (auto \n%s: %s) { /*loop over stack vector*/' %(target, iter))\n                        else:\n                            lines.append('for (auto \n%s: (*%s)) { /*loop over heap vector*/' %(target, iter))\n                    elif arrname in self._known_maps:\n                        lines.append('for (auto \n_pair_%s: (*%s)) {' %(target, iter))\n                        #lines.append('  auto %s = _pair_%s.second;' %(target, target))\n                        lines.append('  auto %s = _pair_%s.first;' %(target, target))\n                    else:\n                        if iter.startswith('PyObject_GetAttrString('):\n                            lines.append('PyObject *__pyiterator = PyObject_GetIter(%s);' %iter)\n                            lines.append('while (auto %s = PyIter_Next(__pyiterator)) {' %target)\n                        else:\n                            lines.append('for (auto \n%s: *%s) { /*loop over unknown type*/' %(target, iter))\n\n                else:\n                    lines.append('for \n%s in %s.borrow_mut().iter() { //magic:%s' %(target, iter, node.iter.uid))\n            else:\n                lines.append('for %s in %s.borrow_mut().iter() { //magic:%s' %(target, iter, node.iter.uid))\n\n        clean_up_scope = []\n        self.push()\n        for b in node.body:\n            lines.append( self.indent()+self.visit(b) )\n            ## after `b` has been visited, if it was an assignment node,\n            ## it will then need to be removed from the known variables list,\n            ## because C++ is block scoped, and in regular python variables escape for loops.\n            if hasattr(b, '_new_assignment'):\n                clean_up_scope.append(b._new_assignment)\n\n        self.pull()\n        lines.append( self.indent()+'}' )  ## end of for loop\n\n        for name in clean_up_scope:\n            self._known_vars.remove(name)\n            self._vars.add(name)\n\n        return '\\n'.join(lines)\n\n\n\n\n\n\nWhile Loop\n\n\nworks with rust and c++\n\n\n\n    def visit_While(self, node):\n        cond = self.visit(node.test)\n        if cond == 'true' or cond == '1': cond = ''\n        body = []\n        if not cond.strip():\n            if self._cpp:\n                body.append('while (true) {')\n            else:\n                body.append('loop {')\n        else:\n            if self._cpp:\n                body.append('while (%s) {' %cond)\n            else:\n                body.append('while %s {' %cond)\n\n        self.push()\n        for line in list( map(self.visit, node.body) ):\n            body.append( self.indent()+line )\n        self.pull()\n        body.append( self.indent() + '}' )\n        return '\\n'.join( body )\n\n\n\n\n\n\nCompare \nx==y\n\n\nneeds to check if item is a string there is an \nin\n test, \nif \"x\" in \"xyz\"\n\nso that can be translated to string.find or if it is a vector \nstd::find\n.\n\n\n    def visit_Compare(self, node):\n        comp = ['(']\n        left = self.visit(node.left)\n        if isinstance(node.left, ast.BinOp):\n            comp.extend( ['(', self.visit(node.left), ')'] )\n        else:\n            comp.append( self.visit(node.left) )\n\n        for i in range( len(node.ops) ):\n            op = node.ops[i]\n            if isinstance(op, ast.In) or isinstance(op, ast.NotIn):\n                if comp[-1]==left:\n                    comp.pop()\n                else:\n                    comp.append(' \n ')\n                rator = self.visit(node.comparators[i])\n                if rator in self._known_strings:\n                    comp.append('(%s.find(%s) != std::string::npos)' %(rator, left))\n                else:\n                    comp.append('(std::find(%s-\nbegin(), %s-\nend(), %s) != %s-\nend())' %(rator, rator, left, rator))\n\n            else:\n                comp.append( self.visit(op) )\n\n                if isinstance(node.comparators[i], ast.BinOp):\n                    comp.append('(')\n                    comp.append( self.visit(node.comparators[i]) )\n                    comp.append(')')\n                else:\n                    comp.append( self.visit(node.comparators[i]) )\n\n        comp.append( ')' )\n\n        return ' '.join( comp )\n\n\n\n\n\nIf\n\n\nTODO test \nif pointer:\n c++\n\n\n\n    def visit_If(self, node):\n        out = []\n        isinstance_test = False\n        ispyinstance_test = False\n        target = None\n        classname = None\n\n        if isinstance(node.test, ast.Compare) or isinstance(node.test, ast.UnaryOp) or isinstance(node.test, ast.BoolOp):\n            test = self.visit(node.test)\n        elif isinstance(node.test, ast.Name):\n            if node.test.id in ('null', 'None', 'False'):\n                test = 'false'\n            elif node.test.id == 'True':\n                test = 'true'\n            else:\n                test = '%s==true' %node.test.id\n        elif isinstance(node.test, ast.Num):\n            test = '%s!=0' %node.test.n\n        elif isinstance(node.test, ast.Call) and isinstance(node.test.func, ast.Name) and node.test.func.id=='isinstance':\n            isinstance_test = True\n            target = self.visit(node.test.args[0])\n            classname = self.visit(node.test.args[1])\n            if self._memory[-1]=='STACK':\n                test = '(%s.__class__==std::string(\n%s\n))' %(target, classname)\n            else:\n                test = '(%s-\n__class__==std::string(\n%s\n))' %(target, classname)\n\n        elif isinstance(node.test, ast.Call) and isinstance(node.test.func, ast.Name) and node.test.func.id=='ispyinstance':\n            ispyinstance_test = True\n            target = self.visit(node.test.args[0])\n            classname = self.visit(node.test.args[1])\n            test = 'ispyinstance(%s, std::string(\n%s\n))==true' %(target, classname)\n            if 'ispyinstance' not in self._called_functions:\n                self._called_functions['ispyinstance'] = 0\n            self._called_functions['ispyinstance'] += 1\n\n        else:\n            test = '%s==true' %self.visit(node.test)\n\n        out.append( 'if (%s) {' %test )\n\n        self.push()\n        if isinstance_test:\n            assert self._cpp\n            self._rename_hacks[target] = '_cast_%s' %target\n            targ = target\n            if '-\n' in target:\n                targ = target.replace('-\n', '_')\n\n            if self._memory[-1] == 'STACK':\n                out.append(self.indent()+'auto _cast_%s = static_cast\n%s\n(%s);' %(targ, classname, target))\n            elif self._polymorphic:\n                out.append(self.indent()+'auto _cast_%s = std::dynamic_pointer_cast\n%s\n(%s);' %(targ, classname, target))\n            else:\n                out.append(self.indent()+'auto _cast_%s = std::static_pointer_cast\n%s\n(%s);' %(targ, classname, target))\n\n        elif ispyinstance_test:\n            assert self._cpp\n            self._rename_hacks[target] = '_cast_%s' %target\n            if classname in 'int i32 long i64'.split():\n                out.append(self.indent()+'auto _cast_%s = PyInt_AS_LONG(%s);' %(target, target))\n            elif classname in 'float f32 double f64'.split():\n                out.append(self.indent()+'auto _cast_%s = PyFloat_AS_DOUBLE(%s);' %(target, target))\n            elif classname in 'string str'.split():\n                out.append(self.indent()+'auto _cast_%s = std::string(PyString_AS_STRING(%s));' %(target, target))\n            else:\n                #raise RuntimeError('TODO pytype:'+classname)\n                ## user class\n                self._rename_hacks.pop(target)\n\n\n\n        for line in list(map(self.visit, node.body)):\n            if line is None: continue\n            out.append( self.indent() + line )\n\n        if isinstance_test or ispyinstance_test:\n            if target in self._rename_hacks:\n                self._rename_hacks.pop(target)\n\n\n        orelse = []\n        for line in list(map(self.visit, node.orelse)):\n            orelse.append( self.indent() + line )\n\n        self.pull()\n\n        if orelse:\n            out.append( self.indent() + '} else {')\n            out.extend( orelse )\n\n        out.append( self.indent() + '}' )\n\n        return '\\n'.join( out )\n\n\n    def visit_Index(self, node):\n        if isinstance(node.value, ast.Num):\n            return str(node.value.n)\n        else:\n            return self.visit(node.value)\n\n\n\n\n\nName\n\n\nnote: \nnullptr\n is c++11\n\n\n\n    def visit_Name(self, node):\n        if node.id == 'None' or node.id == 'nil' or node.id == 'null':\n            if self._cpp:\n                return 'nullptr'\n            else:\n                return 'None'\n        elif node.id == 'True':\n            return 'true'\n        elif node.id == 'False':\n            return 'false'\n        elif node.id in self._rename_hacks:  ## TODO make the node above on the stack is not an attribute node.\n            return self._rename_hacks[ node.id ]\n        elif node.id=='self' and self._class_stack and self._cpp:\n            return 'this'\n        elif node.id=='__finally__':\n            return 'finally'\n        else:\n            return node.id\n\n    def get_subclasses( self, C ):\n        '''\n        returns all sibling subclasses, C can be a subclass or the base class\n        '''\n        subclasses = set()\n        self._collect_subclasses(C, subclasses)\n        return subclasses\n\n    def _collect_subclasses(self, C, subclasses):\n        node = self._classes[ C ]\n        if len(node._parents)==0:\n            for sub in node._subclasses:\n                subclasses.add( sub )\n        else:\n            for parent in node._parents:\n                self._collect_subclasses(parent, subclasses)\n\n\n    def visit_ClassDef(self, node):\n        self._class_stack.append( node )\n        if not hasattr(node, '_parents'):  ## only setup on the first pass\n            node._parents = set()\n            node._struct_def = dict()\n            node._subclasses = set()  ## required for generics generator\n            ## subclasses must be a struct union so that Go can convert between struct types\n            node._subclasses_union = dict()\n            ## any classes that this class contains in arrays or maps,\n            ## this is used by the child to create a weakref to the parent if required.\n            node._contains_classes = set()\n            node._weak_members = set()\n            node._requires_init = False\n            ## subclasses need to check the parent class for methods with the same name\n            ## and a different signature.  These are regenerated in the subclass.\n            node._methods = list()  ## nodes\n\n        out = []\n        sdef = dict()\n        props = set()\n        bases = set()\n        base_classes = set()\n        self._classes[ node.name ] = node\n        self._class_props[ node.name ] = props\n        if node.name not in self.method_returns_multiple_subclasses:\n            self.method_returns_multiple_subclasses[ node.name ] = set()  ## tracks which methods in a class return different subclass types\n\n        comments = []\n        for b in node.body:\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Str):\n                comments.append(b.value.s)\n\n        if comments:\n            out.append('/**')\n            for line in comments[0].splitlines():\n                out.append(' * '+line)\n            out.append(' */')\n\n\n        root_classes = set()  ## subsubclasses in c++ need to inherit from the roots\n        cpp_bases = list()\n        extern_classes = list()\n        for base in node.bases:\n            n = self.visit(base)\n            if n == 'object':\n                continue\n            if n in self._root_classes:\n                root_classes.add(n)\n\n            node._parents.add( n )\n            cpp_bases.append( n )\n            bases.add( n )\n\n            if n in self._class_props:\n                props.update( self._class_props[n] )\n                base_classes.add( self._classes[n] )\n\n            if n not in self._classes:\n                extern_classes.append(n)\n            else:\n                for p in self._classes[ n ]._parents:\n                    bases.add( p )\n                    props.update( self._class_props[p] )\n                    base_classes.add( self._classes[p] )\n                    if p in self._root_classes:\n                        root_classes.add(p)\n\n                self._classes[ n ]._subclasses.add( node.name )\n\n        if len(root_classes)\n1 and self._cpp:\n            raise RuntimeError(root_classes)\n\n        if not len(base_classes):\n            self._root_classes[ node.name ] = node\n\n        ## class decorators ##\n        is_jvm_class = False\n        external_header = None\n        for decor in node.decorator_list:\n            ## __struct__ is generated in python_to_pythonjs.py\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id=='__struct__':\n                for kw in decor.keywords:\n                    props.add( kw.arg )\n                    T = kw.value.id\n                    sdef[ kw.arg ] = T\n            elif self._cpp:\n                if isinstance(decor, ast.Name) and decor.id=='jvm':\n                    ## subclasses from a Java class ##\n                    self._jvm_classes[ node.name ] = node\n                    is_jvm_class = True\n                elif isinstance(decor, ast.Name) and decor.id in self._user_class_headers:\n                    external_header = self._user_class_headers[ decor.id ]\n                elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'macro':\n                    out.append( decor.args[0].s )\n                else:\n                    raise RuntimeError('TODO class decorator')\n\n        init = None\n        method_names = set()\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                method_names.add( b.name )\n                node._methods.append( b )  ## save method node, header-signature and body.\n\n                if b.name == '__init__':\n                    init = b\n                    node._requires_init = True\n\n            elif isinstance(b, ast.Expr) and isinstance(b.value, ast.Dict):\n                for i in range( len(b.value.keys) ):\n                    k = self.visit( b.value.keys[ i ] )\n                    if isinstance(b.value.values[i], ast.Str):\n                        v = b.value.values[i].s\n                    elif isinstance(b.value.values[i], ast.Call):\n                        n = b.value.values[i]\n                        if n.func.id in ('__go__map__', '__arg_map__'):\n                            if n.func.id=='__arg_map__':\n                                assert n.args[0].s.startswith('map[')\n                                key_type = n.args[0].s.split('[')[-1].split(']')[0]\n                                value_type = n.args[0].s.split(']')[-1]\n                            else:\n                                key_type = self.visit(n.args[0])\n                                value_type = self.visit(n.args[1])\n                            if key_type=='string': key_type = 'std::string'\n                            if value_type=='string': value_type = 'std::string'\n                            v = 'std::map\n%s, %s\n' %(key_type, value_type)\n                        elif n.func.id == '__arg_array__':\n                            if isinstance(n.args[0], ast.Str):\n                                t = n.args[0].s\n                            else:\n                                t = self.visit(n.args[0])\n                            dims = 0\n                            if t.startswith('['):\n                                dims = t.count('[')\n                                t = t.split(']')[-1]\n                            if t=='string':\n                                if self.usertypes and 'string' in self.usertypes:\n                                    key_type = self.usertypes['string']['type']\n                                else:\n                                    key_type = 'std::string'\n\n                            if not self.is_prim_type(t):\n                                if self.usertypes and 'shared' in self.usertypes:\n                                    t = self.usertypes['shared']['template'] % t\n                                else:\n                                    t = 'std::shared_ptr\n%s\n' %t\n\n                            if not dims or dims==1:\n                                if self.usertypes and 'vector' in self.usertypes:\n                                    v = self.usertypes['vector']['template'] % t\n                                else:\n                                    v = 'std::vector\n%s\n' %t\n                            elif dims == 2:  ## TODO clean this up, support more dims, and self.usertypes\n                                v = 'std::vector\nstd::shared_ptr\nstd::vector\n%s\n' %t\n\n                        else:\n                            raise RuntimeError('TODO', n.func.id)\n\n                    else:\n                        v = self.visit( b.value.values[i] )\n\n                    if v.startswith('['):  ## swap array style to C++\n                        x,y = v.split(']')\n                        v = y + x + ']'\n                        if self._memory[-1]=='HEAP':\n                            if self.is_prim_type(y):\n                                v = 'std::vector\n%s\n' %y\n                            else:\n                                v = 'std::vector\nstd::shared_ptr\n%s\n' %y\n\n                    sdef[k] = v\n\n\n        node._struct_def.update( sdef )\n        unionstruct = dict()\n        unionstruct.update( sdef )\n        for pname in node._parents:\n            if pname in self._classes:\n                parent = self._classes[ pname ]\n                parent._subclasses_union.update( sdef )        ## first pass\n                unionstruct.update( parent._subclasses_union ) ## second pass\n            else:\n                pass  ## class from external c++ library\n\n\n        parent_init = None\n        overload_nodes = []\n        overloaded  = []  ## this is just for rust\n        overloaded_returns_self = []\n        if base_classes:\n            for bnode in base_classes:\n                for b in bnode.body:\n                    if isinstance(b, ast.FunctionDef):\n                        overload_nodes.append( b )\n                        #if hasattr(b, 'returns_self') and b.returns_self:\n                        #   if b.name != '__init__' and not b.is_abstract:\n                        #       overloaded_returns_self.append(b)\n                        if b.name != '__init__' and b.name not in method_names:\n                            overloaded_returns_self.append(b)\n\n                        ## catch_call trick is used to call methods on base classes from the subclass.\n                        if self._cpp:\n                            ##self.catch_call.add( '%s-\n%s' %(bnode.name, b.name))\n                            #note: `::` is automatic now when calling classmethod/staticmethods.\n                            self.catch_call.add( '%s::%s' %(bnode.name, b.name))\n                        else:\n                            self.catch_call.add( '%s.%s' %(bnode.name, b.name))\n\n                        if b.name in method_names:\n                            b.overloaded = True\n                            b.classname  = bnode.name\n                        if b.name == '__init__':\n                            parent_init = {'class':bnode, 'node':b}\n                            node._requires_init = True\n\n\n        for b in overload_nodes:\n            if hasattr(b, 'overloaded'):\n                original = b.name\n                b.name = '__%s_%s'%(b.classname, b.name)  ## rust requires this extra hackery\n                overloaded.append( self.visit(b) )\n                b.name = original\n            else:\n                overloaded.append( self.visit(b) )\n\n        if self._cpp:\n            if cpp_bases:\n                #parents = ','.join(['public %s' % rname for rname in root_classes])\n                parents = ','.join(['public %s' % rname for rname in cpp_bases])\n                out.append( 'class %s:  %s {' %(node.name, parents))\n            else:\n                #out.append( 'class %s {' %node.name)\n                ## shared from this is required so that `self` (this) can be passed to\n                ## other functions and objects that may take ownership of `self`.\n                ## on subclasses the base class is returned from `shared_from_this()`\n                out.append( 'class %s: public std::enable_shared_from_this\n%s\n {' %(node.name, node.name))\n\n            ## body macros come before public ##\n            for b in node.body:\n                if isinstance(b, ast.Expr) and isinstance(b.value, ast.Call) and isinstance(b.value.func, ast.Name) and b.value.func.id=='macro':\n                    out.append(b.value.args[0].s)\n\n\n            out.append( '  public:')\n\n            #if not base_classes:\n            if not cpp_bases or is_jvm_class:\n                ## only the base class defines `__class__`, this must be the first element\n                ## in the struct so that all rusthon object has the same header memory layout.\n                ## note if a subclass redefines `__class__` even as a string, and even as the\n                ## first struct item, it will still not have the same memory location as super.__class__.\n                ## We require the same memory location for `__class__` because the `isinstance`\n                ## hack requires on `__class__` always being valid to check an objects class type at runtime.\n                out.append( '   std::string __class__;')\n                out.append( '   bool __initialized__;')\n                out.append( '   int  __classid__;')\n        else:\n            out.append( 'struct %s {' %node.name)\n            ## rust requires that a struct contains at least one item,\n            ## `let a = A{}` is invalid in rust, and will fail with this error\n            ## error: structure literal must either have at least one field or use functional structure update syntax\n            ## to workaround this problem in the init constructor, the A::new static method simply makes\n            ## the new struct passing the classname as a static string, and then calls the users __init__ method\n            out.append( '   __class__ : string,')\n\n\n        rust_struct_init = ['__class__:\n%s\n' %node.name]\n        parent_attrs = {}\n\n        if base_classes:\n            for bnode in base_classes:\n                if self._cpp:\n                    if bnode._struct_def.keys():\n                        out.append('//  members from class: %s  %s'  %(bnode.name, bnode._struct_def.keys()))\n                        ## not required, the subclass should not redeclare members of parents\n                        #for key in bnode._struct_def:\n                        #   if key not in unionstruct:\n                        #       unionstruct[key] = bnode._struct_def[key]\n                        parent_attrs.update( bnode._struct_def )\n\n                elif self._rust:\n                    out.append('//  members from class: %s  %s'  %(bnode.name, bnode._struct_def.keys()))\n                    ## to be safe order should be the same?\n                    for key in bnode._struct_def.keys():\n                        if key in unionstruct:\n                            unionstruct.pop(key)  ## can subclass have different types in rust?\n                        out.append('    %s : %s,' %(key, bnode._struct_def[key]))\n                        rust_struct_init.append('%s:%s' %(key, default_type(bnode._struct_def[key])))\n\n                else:\n                    raise RuntimeError('invalid backend')\n\n        node._struct_init_names = []  ## save order of struct layout\n\n        for name in unionstruct:\n\n            if unionstruct[name]=='interface{}':\n                raise SyntaxError('interface{} is just for the Go backend')\n\n            node._struct_init_names.append( name )\n            #if name=='__class__': continue\n\n            T = unionstruct[name]\n            ## skip redefines of attributes in a subclass with the same type,\n            ## this ensures that subclasses will have the same memory layout\n            ## for shared attributes of the same type, and that std::static_pointer_cast also works.\n            if name in parent_attrs and parent_attrs[name]==T:\n                continue\n\n            member_isprim = self.is_prim_type(T)\n            if self._cpp:\n                if T=='string': T = 'std::string'\n\n                if T.endswith(']'):\n                    x,y = T.split('[')\n                    out.append('    %s  %s[%s;' %(x, name, y ))\n                elif member_isprim:\n                    out.append('    %s  %s;' %(T, name ))\n                else:\n                    otherclass = T.split('\n')[-1].split('\n')[0]\n\n                    if self.is_container_type(T):\n                        node._contains_classes.add( otherclass )\n\n                    weakref = False\n                    if otherclass in self._classes:\n                        if node.name in self._classes[otherclass]._contains_classes:\n                            #raise RuntimeError('%s contains %s' %(otherclass, node.name))\n                            weakref = True\n\n                    if not self._shared_pointers or self._memory[-1]=='STACK':\n                        out.append('    %s*  %s;' %(T, name ))\n                    elif self._unique_ptr:\n                        out.append('    std::unique_ptr\n%s\n  %s;' %(T, name ))\n                    else:\n\n                        if weakref:\n                            node._weak_members.add(name)\n                            if self.usertypes and 'weakref' in self.usertypes:\n                                out.append('    %s  %s;' %( self.usertypes['weakref']['template']%T, name ))\n                            else:\n                                out.append('    std::weak_ptr\n%s\n  %s;' %(T, name ))\n\n                        elif T.startswith('std::shared_ptr\n'):  ## TODO check this\n                            out.append('    %s  %s;' %(T, name ))\n\n                        else:\n                            if self.usertypes and 'shared' in self.usertypes:\n                                out.append('    %s  %s;' %(self.usertypes['shared']['template']%T, name ))\n                            else:\n                                out.append('    std::shared_ptr\n%s\n  %s;' %(T, name ))\n            else:\n                rust_struct_init.append('%s:%s' %(name, default_type(T)))\n                if T=='string': T = 'String'\n                if member_isprim:\n                    out.append('    %s : %s,' %(name, T))\n                else:\n                    out.append('    %s : Rc\nRefCell\n%s\n,' %(name, T))\n\n\n        self._rust_trait = []\n        self._cpp_class_header = []\n        impl  = []\n        self.push()\n\n        ## required by new style because __init__ returns this which needs to be defined for each subclass type ##\n        if self._cpp and parent_init:\n            if not init:\n                impl.append( self.visit(parent_init['node']) )\n            elif len(init.args.args) != len(parent_init['node'].args.args):\n                impl.append( self.visit(parent_init['node']) )\n\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                impl.append( self.visit(b) )\n\n        for b in overloaded_returns_self:\n            impl.append( self.visit(b) )\n\n\n        self.pull()\n\n        if self._cpp:\n            for impl_def in self._cpp_class_header:\n                out.append( '\\t' + impl_def )\n\n\n\n            ## c++ empty constructor with `struct-emeddding` the class name\n            #out.append('   %s() : __class__(std::string(\n%s\n)) {}' %(node.name, node.name) )  ## this breaks when looping over array items\n            ## member initializer list `MyClass() : x(1) {}` only work when `x` is locally defined inside the class,\n            ## it breaks on `__class__` because that is defined in the parent class, instead `__class__` is initalized in the constructors body.\n            ## TODO make __class__ static const string.\n\n            if not extern_classes:\n                classid = self._classes.keys().index(node.name)\n                out.append('    bool operator != (std::nullptr_t rhs) {return __initialized__;}' )\n                out.append('    bool operator == (std::nullptr_t rhs) {return !__initialized__;}' )\n                out.append('    %s() {__class__ = std::string(\n%s\n); __initialized__ = true; __classid__=%s;}' %(node.name, node.name, classid) )\n\n                ## `let a:MyClass = None` is generated when in stack mode and an object is created and set to None.\n                out.append('    %s(bool init) {__class__ = std::string(\n%s\n); __initialized__ = init; __classid__=%s;}' %(node.name, node.name, classid) )\n\n                if self._polymorphic:\n                    out.append('    virtual std::string getclassname() {return this-\n__class__;}')  ## one virtual method makes class polymorphic\n                elif self._memory[-1]=='STACK':\n                    out.append('    std::string getclassname() {return __class__;}')\n                else: #not base_classes:\n                    out.append('    std::string getclassname() {return this-\n__class__;}')\n\n            elif is_jvm_class:\n                ## TODO constructor args for jvm super class and __init__ for subclass\n                out.append('    %s(JavaVM* _jvm) : %s(_jvm) {__class__ = std::string(\n%s\n);}' %(node.name, extern_classes[0], node.name) )\n                out.append('    std::string getclassname() {return this-\n__class__;}')\n            else:\n                pass ## some unknown external c++ class, TODO constructor.\n\n            out.append('};')\n\n        else: ## rust\n            out.append('}')\n\n        cpp_method_impl = []\n        if self._cpp:\n            for idef in impl:\n                if external_header:\n                    cpp_method_impl.append( idef )\n                else:  ## can not write c++ method implementations before other class headers\n                    self._cpp_class_impl.append( idef )\n\n        else:\n            ## using a trait is not required, because a struct type can be directly implemented.\n            ## note: methods require a lambda wrapper to be passed to another function.\n            #out.append('trait %s {' %node.name)\n            #for trait_def in self._rust_trait: out.append( '\\t'+ trait_def )\n            #out.append('}')\n            #out.append('impl %s for %sStruct {' %(node.name, node.name))\n            #for impl_def in impl: out.append( impl_def )\n            #out.append('}')\n\n            out.append('impl %s {' %node.name)\n            for impl_def in impl: out.append( impl_def )\n\n            if overloaded:\n                out.append('/*      overloaded methods      */')\n                for o in overloaded:\n                    out.append( o )\n\n            if init:\n                tmp = 'let mut __ref__ = %s{%s};' %(node.name, ','.join(rust_struct_init))\n                tmp += '__ref__.__init__(%s);' % ','.join(init._arg_names)\n                tmp += 'return __ref__;'\n                out.append('/*      constructor     */')\n                out.append('    fn new( %s ) -\n %s { %s }' %(init._args_signature, node.name, tmp) )\n            else:\n                tmp = 'let mut __ref__ = %s{%s};' %(node.name, ','.join(rust_struct_init))\n                tmp += 'return __ref__;'\n                out.append('/*      constructor     */')\n                out.append('    fn new() -\n %s { %s }' %(node.name, tmp) )\n\n\n            out.append('}')  ## end rust `impl`\n\n\n        self.catch_call = set()\n        self._class_stack.pop()\n        if external_header:\n            external_header['source'].extend( out )\n            out.append( '// header saved to: %s'  % external_header['file'])\n            return '\\n'.join(cpp_method_impl)\n\n        else:\n            return '\\n'.join(out)\n\n\n\n\n\nVisit Call Special\n\n\nhack for calling base class methods.\n\n\n\n    def _visit_call_special( self, node ):\n        fname = self.visit(node.func)\n        assert fname in self.catch_call\n        assert len(self._class_stack)\n        if len(node.args):\n            if isinstance(node.args[0], ast.Name) and node.args[0].id == 'self':\n                node.args.remove( node.args[0] )\n\n        if self._cpp:\n            if fname.count('::') \n 1: raise RuntimeError('TODO: %s'%fname)\n            ##classname = fname.split('-\n')[0]\n            classname = fname.split('::')[0]\n            hacked = classname + '::' + fname[len(classname)+2:]\n            return self._visit_call_helper(node, force_name=hacked)\n        else:\n            classname = fname.split('.')[0]\n            hacked = 'self.__%s_%s' %(classname, fname[len(classname)+1:])\n            return self._visit_call_helper(node, force_name=hacked)\n\n\n\n\n\nSubscript \na[n]\n\n\n\n\n    def visit_Subscript(self, node):\n        if isinstance(node.slice, ast.Ellipsis):  ## special deference pointer syntax\n            return '(*%s)' %self.visit(node.value)\n        else:\n            ## deference pointer and then index\n            if isinstance(node.slice, ast.Slice):\n                if self._cpp:\n                    ## std::valarray has a slice operator `arr[ std::slice(start,end,step) ]`\n                    ## but std::valarray only works on numeric values, and can not grow in size.\n                    msg = {'value':self.visit(node.value), 'slice':node.slice, 'lower':None, 'upper':None, 'step':None}\n                    if node.slice.lower:\n                        msg['lower'] = self.visit(node.slice.lower)\n                    if node.slice.upper:\n                        msg['upper'] = self.visit(node.slice.upper)\n                    if node.slice.step:\n                        msg['step'] = self.visit(node.slice.step)\n\n                    if msg['step'] is None and (msg['value'] in self._known_strings or msg['value'] in self._global_types['string']):\n                        if msg['lower'] and msg['upper']:\n                            return '%s.substr(%s, %s)' %(msg['value'], msg['lower'], msg['upper'])\n                        elif msg['lower']:\n                            return '%s.substr(%s, %s.size()-1)' %(msg['value'], msg['lower'], msg['value'])\n                        else:\n                            return '%s.substr(0, %s)' %(msg['value'], msg['upper'])\n\n                    raise GenerateSlice( msg )\n\n                else:\n                    r = '\n(*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n            else:\n                if self._cpp:\n                    ## default to deference shared pointer ##\n                    value = self.visit(node.value)\n                    is_tuple_index = isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.Set)\n\n                    if value in self._known_pointers:\n                        if is_tuple_index:\n                            r = 'std::get\n%s\n(*%s)' % (self.visit(node.slice.value.elts[0]), value)\n                        else:\n                            r = '(*%s)[%s]' % (value, self.visit(node.slice))\n                    elif self._memory[-1]=='STACK':\n                        if is_tuple_index:\n                            r = 'std::get\n%s\n(%s)' % (self.visit(node.slice.value.elts[0]), value)\n                        else:\n                            r = '%s[%s]' % (value, self.visit(node.slice))\n                    else:\n                        if is_tuple_index:\n                            r = 'std::get\n%s\n(*%s)' % (self.visit(node.slice.value.elts[0]), value)\n                        else:\n                            r = '(*%s)[%s]' % (value, self.visit(node.slice))\n\n                    #############################################\n                    if value.startswith('PyObject_GetAttrString(') and value.endswith(')'):\n                        r = 'PyObject_CallFunction(PyObject_GetAttrString(%s,\n__getitem__\n),\ni\n, %s)' % (value, self.visit(node.slice))\n\n                    elif isinstance(node.value, ast.Name):\n                        target = node.value.id\n                        is_neg = False\n                        if isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.Num) and node.slice.value.n \n 0:\n                            is_neg = True\n\n                        if self._function_stack:\n                            if target in self._known_strings:\n                                if is_neg:\n                                    r = '%s.substr(%s.size()%s,1)' %(target, target,self.visit(node.slice))\n                                else:\n                                    r = '%s.substr(%s,1)' %(target, self.visit(node.slice))\n                        ## need to also check if the target name is a global string ##\n                        if target in self._global_types['string']:\n                            if is_neg:\n                                r = '%s.substr(%s.size()%s,1)' %(target, target,self.visit(node.slice))\n                            else:\n                                r = '%s.substr(%s,1)' %(target, self.visit(node.slice))\n\n                elif self._rust:\n                    r = '%s.borrow_mut()[%s]' % (self.visit(node.value), self.visit(node.slice))\n                else:\n                    r = '(*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n\n            ## TODO: subclass generics for arrays\n            #if isinstance(node.value, ast.Name) and node.value.id in self._known_generics_arrays:\n            #   target = node.value.id\n            #   #value = self.visit( node.value )\n            #   cname = self._known_arrays[target]\n            #   #raise GenerateGenericSwitch( {'target':target, 'value':r, 'class':cname} )\n            #   raise GenerateGenericSwitch( {'value':r, 'class':cname} )\n\n            return r\n\n\n\n\n\nCall Function/Method\n\n\nhandles all special calls\n\n\n\n    def _visit_call_helper(self, node, force_name=None):\n        fname = force_name or self.visit(node.func)\n        if fname =='cdef':\n            s = node.args[0].s\n            varname = s.split('=')[0].split()[-1]\n            if varname.startswith('*'):\n                varname = varname.split('*')[-1]\n            elif varname.startswith('\n'):\n                varname = varname.split('\n')[-1]\n\n            self._known_vars.add(varname)\n            if varname in self._vars:\n                self._vars.remove(varname)\n\n            return s\n\n        elif fname=='__array__':\n            if len(node.args)==4:\n                aname  = self.visit(node.args[0])\n                asize  = self.visit(node.args[1])\n                atype = self.visit(node.args[2])\n                ainit = self.visit(node.args[3])\n                self._known_arrays[aname] = (atype, asize)\n                return '%s %s[%s] = %s;' %(atype, aname, asize, ainit)\n            else:\n                raise SyntaxError(self.format_error('invalid __array__'))\n\n        elif self._cpp and fname=='move':\n            args = ','.join([self.visit(arg) for arg in node.args])\n            return 'std::move(%s)' %args\n\n        elif self._cpp and fname=='complex':\n            args = ','.join([self.visit(arg) for arg in node.args])\n            return 'std::complex\ndouble\n(%s)' %args\n\n        elif self._cpp and fname in self._typedefs:\n            typedef = self._typedefs[fname]\n            args = ','.join([self.visit(arg) for arg in node.args])\n            if typedef.startswith('tuple('):\n                if self._memory[-1]=='STACK':\n                    return 'std::make_tuple(%s)' %args\n                else:\n                    return '/*typedef: %s*/[\n](){auto _ = std::make_tuple(%s); return std::make_shared\ndecltype(_)\n(_);}()' %(typedef,args)\n            #elif typedef.startswith('std::shared_ptr\nstd::vector\n') and args:\n            elif typedef.startswith('std::vector\n') and not args:\n                if typedef=='std::vector\ntuple\n':\n                    return '/*typedef-tuple-array:%s*/%s(%s)' %(typedef, fname, args)  ## requires `new` ?\n                else:\n                    subtype = typedef.split('\n')[-1].split('\n')[0]\n                    if subtype in self._typedefs:\n                        subsubtype = self._typedefs[subtype]\n                        if subsubtype.startswith('tuple('):\n                            for tsub in subsubtype[len('tuple('):-1].split(','):\n                                if tsub in self._typedefs:\n                                    tsubtype = self._typedefs[tsub]\n                                    if tsubtype.startswith('tuple('):\n                                        raise SyntaxError(self.format_error('TRANSLATION-ERROR: an array of nested tuple of tuples, must be constructed with at least one item.'))\n                    return '/*typedef-array:%s*/%s(%s)' %(typedef, fname, args)  ## requires `new` ?\n\n            elif typedef.startswith('std::vector\n') and args:\n                args = [self.visit(arg) for arg in node.args]\n                assert args[0].startswith('new std::vector\n')\n                tvectype = args[0].split('{')[0][4:]\n                hacked_args = []\n                for arg in args:\n                    if arg.startswith('new '):\n                        arg = arg[4:]\n                    hacked_args.append(arg)\n                return '/*typedef: %s*/std::make_shared\n%s\n(%s)' %(typedef, tvectype, ','.join(hacked_args))\n            else:\n                return '/*typedef:%s*/%s(%s)' %(typedef, fname, args)  ## requires `new` ?\n\n        elif self._cpp and fname =='tuple-\nget':\n            return 'std::get\n%s\n(*%s)' %(self.visit(node.args[1]), self.visit(node.args[0]))\n\n        elif self._cpp and fname == 'tuple.get':\n            return 'std::get\n%s\n(%s)' %(self.visit(node.args[1]), self.visit(node.args[0]))\n\n        elif self._cpp and fname == 'dict-\nkeys':\n            if len(node.args) != 1:\n                raise SyntaxError(self.format_error('dict.keys(mymap) requires a single argument'))\n\n            arrname = self.visit(node.args[0])\n            vectype = 'std::vector\ndecltype(%s)::element_type::key_type\n' %arrname\n            r = [\n                '[\n%s](){' %arrname,\n                'auto __ = std::make_shared\n%s\n(%s());' %(vectype,vectype),\n                'for (const auto \n_ : *%s) {' %arrname,\n                '__-\npush_back(_.first);',\n                '}',\n                'return __;}()'\n            ]\n            return ''.join(r)\n\n        elif self._cpp and fname == 'dict-\nvalues':\n            if len(node.args) != 1:\n                raise SyntaxError(self.format_error('dict.values(mymap) requires a single argument'))\n\n            arrname = self.visit(node.args[0])\n            vectype = 'std::vector\ndecltype(%s)::element_type::mapped_type\n' %arrname\n            r = [\n                '[\n%s](){' %arrname,\n                'auto __ = std::make_shared\n%s\n(%s());' %(vectype,vectype),\n                'for (auto \n_ : *%s) {' %arrname,\n                '__-\npush_back(_.second);',\n                '}',\n                'return __;}()'\n            ]\n            return ''.join(r)\n\n        elif fname=='future':\n            if not len(self._function_stack):\n                raise SyntaxError('future() call used at global level')\n            elif not self._function_stack[-1].return_type.startswith('future\n'):\n                raise SyntaxError('expected future\nT\n return type, instead got: %s' %self._function_stack[-1].return_type )\n\n            args = ','.join([self.visit(arg) for arg in node.args])\n            ftemplate = self._function_stack[-1].return_type.replace('future', 'make_ready_future')\n            return '%s(%s)' %(ftemplate, args)\n\n        elif fname in self.macros:\n            macro = self.macros[fname]\n            if '%=' in macro:  ## advanced meta programming, captures the name of the variable the macro assigns to.\n                if not self._assign_var_name:\n                    raise RuntimeError('the macro syntax `%=` can only be used as part of an assignment expression')\n                macro = macro.replace('%=', self._assign_var_name)\n\n            args = ','.join([self.visit(arg) for arg in node.args])\n            if '\n%s\n' in macro:\n                return macro % tuple([s.s for s in node.args])\n            elif '%s' in macro:\n                if macro.count('%s')\n1:\n                    args = tuple([self.visit(s) for s in node.args])\n                try:\n                    return macro % args\n                except TypeError as err:\n                    raise RuntimeError('%s\\nMACRO:\\t%s\\nARGS:\\t%s' %(err[0], macro, args))\n\n            else:\n                return '%s(%s)' %(macro,args)\n\n        if self._stack and fname in self._classes and not isinstance(self._stack, ast.Assign):\n            node.is_new_class_instance = True\n\n        is_append = False\n        if fname.endswith('.append'): ## TODO - deprecate append to pushX or make `.append` method reserved by not allowing methods named `append` in visit_ClassDef?\n            is_append = True\n            arr = fname.split('.append')[0]\n\n        if fname.endswith('-\n__exec__'):\n            fname = fname.replace('-\n__exec__', '-\nexec')\n\n        ###########################################\n        if fname == 'macro':\n            if node.keywords:\n                r = []\n                for kw in node.keywords:\n                    r.append('#define %s %s' %(kw.arg, self.visit(kw.value)))\n                return '\\n'.join(r) + '//;'\n            else:\n                return '%s //;' %node.args[0].s\n        elif fname == 'pragma':\n            return '#pragma %s //;' %node.args[0].s\n        elif fname == 'addr':\n            return '\n%s' %self.visit(node.args[0])\n        elif fname.startswith('PyObject_GetAttrString') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_pyobjects:\n            return self.gen_cpy_call(node.func.value.id, node)  ## TODO test this\n        elif fname.startswith('PyObject_GetAttrString(') and fname.endswith(')') and isinstance(node.func, ast.Attribute):\n            return self.gen_cpy_call(fname, node)\n\n        elif fname.endswith('.split') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_strings:\n            splitchar = 'std::string(\n \n)'\n            if len(node.args): splitchar = self.visit(node.args[0])\n            return '__split_string__( %s, %s )' %(node.func.value.id, splitchar)\n        elif fname.endswith('.lower') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_strings:\n            return '__string_lower__(%s)' %node.func.value.id\n        elif fname.endswith('.upper') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_strings:\n            return '__string_upper__(%s)' %node.func.value.id\n\n        elif fname.startswith('nuitka-\n'):\n            fname = fname.split('nuitka-\n')[-1]\n            r = [\n                'GET_STRING_DICT_VALUE(',\n                ' moduledict___main__,',\n                '(Nuitka_StringObject *)\n%s\n )' %fname\n            ]\n            return '\\n'.join(r)\n\n        elif fname.startswith('cpython-\n'):\n            n = fname.split('cpython-\n')[-1]\n            if n == 'initalize':\n                return '__cpython_initalize__()'\n            elif n == 'finalize':\n                return '__cpython_finalize__(%s)' %self.visit(node.args[0])\n            else:\n                c = '__cpython_get__(\n%s\n)' %n\n                return self.gen_cpy_call(c, node)\n\n        elif fname.startswith('nim-\n'):\n            if fname.endswith('main'):\n                return 'PreMain(); NimMain()'\n            #elif fname.endswith('unref'):  ## GC_ref is called from nim code, its not part of the NIM C API?\n            #   return 'GC_unref(%s)' %self.visit(node.args[0])\n            #elif fname.endswith('ref'):\n            #   return 'GC_ref(%s)' %self.visit(node.args[0])\n            else:\n                raise RuntimeError('unknown nim api function')\n\n        elif fname=='jvm':\n            classname = node.args[0].func.id\n            args = [self.visit(arg) for arg in node.args[0].args]\n\n            ## using make_shared is safer and is only a single allocation, but it crashes g++4.7\n            #return 'std::make_shared\n%s\n(%s)'%(classname,','.join(args))\n\n            ## this is slower because it makes two allocations, and if allocation of shared_ptr\n            ## fails, then the object could be leaked.  using this for now because it works with g++4.7\n            if classname in self._jvm_classes:\n                ## Rusthon class that subclass from Java classes (decorated with @jvm)\n                return 'std::shared_ptr\n%s\n((new %s(__javavm__))-\n__init__(%s))'%(classname, classname,','.join(args))\n            else:\n                ## Java class ##\n                args.insert(0, '__javavm__') ## global JavaVM instance\n                if len(args)\n1:\n                    raise RuntimeError('Giws as of feb21.2015, is missing support for constructor arguments')\n                return 'std::shared_ptr\n%s\n(new %s(%s))'%(classname, classname,','.join(args))\n\n\n        elif fname=='jvm-\ncreate':  ## TODO - test multiple vms\n            return '__create_javavm__();'\n        elif fname=='jvm-\nload':\n            if node.args[0].s not in self._java_classpaths:\n                self._java_classpaths.append(node.args[0].s)\n            return ''\n        elif fname=='jvm-\nnamespace':  ## giws squashes the name space from `org.x.y` to `org_x_y`\n            s = node.args[0].s\n            return 'using namespace %s;' %s.replace('.', '_')\n            #ns = []\n            #nspath = s.split('.')\n            #for i,a in enumerate(nspath):\n            #   if i==len(nspath)-1:\n            #       ns.append('::'+a)\n            #   else:\n            #       ns.append(a+'_')\n            #raise SyntaxError(ns)\n        elif fname=='namespace':\n            return 'using namespace %s;' %node.args[0].s\n        elif fname=='weak-\nunwrap':\n            ## this is needed for cases where we do not know if its a weakptr, `self.a.b.c.parent`,\n            ## it is also useful for the user to simply make their code more clear.\n            w = self.visit(node.args[0])\n            lock_name = 'lock'\n            if self.usertypes and 'weakref' in self.usertypes:\n                lock_name = self.usertypes['weakref']['lock']\n            if not w.endswith('.%s()'%lock_name): w += '.%s()' %lock_name\n            return w\n\n        elif fname=='weak-\nvalid':\n            ## this is needed for cases where we do not know if its a weakptr, `self.a.b.c.parent`,\n            ## it is also useful for the user to simply make their code more clear.\n            w = self.visit(node.args[0])\n            if self.usertypes and 'weakref' in self.usertypes:\n                return '%s.%s()' %(w,self.usertypes['weakref']['valid'])\n            else:\n                return '%s != nullptr' %w\n\n        elif fname.endswith('.insert') and fname.split('.insert')[0] in self._known_arrays and len(node.args)\n=2:\n            arr = fname.split('.insert')[0]\n            idx = self.visit(node.args[0])\n            val = self.visit(node.args[1])\n\n            if len(node.args)==2:\n                #if '.' in val and arr == val.split('.')[0] and 'pop' in val:  ## TODO\n                if '-\n' in val and arr == val.split('-\n')[0] and 'pop' in val:\n                    popidx = None\n                    r = []\n                    if val.endswith('pop_back()'):\n                        #popidx = '%s-\nsize()-1' %arr\n                        popidx = '%s-1' %self._known_arrays[arr][1]\n                        r.append('auto __back__ = %s[%s];' %(arr,popidx))\n                        r.extend([  ## move elements forward starting from back\n                            self.indent()+'for (int __i=%s; __i\n%s; __i--) {' %(popidx, idx),\n                            self.indent()+'  %s[__i] = %s[__i-1];' %(arr, arr),\n                            self.indent()+'}'\n                        ])\n                        r.append(self.indent()+'%s[%s] = __back__;' %(arr, idx))\n\n                    else:\n                        popidx = val.split('(')[-1].split(')')[0].strip()\n                        assert popidx == '0' ## TODO other indices\n                        r.append('auto __front__ = %s[%s];' %(arr,popidx))\n                        r.extend([  ## move elements forward starting from insert idx\n                            self.indent()+'for (int __i=1; __i\n=%s; __i++) {' %idx,\n                            self.indent()+'  %s[__i-1] = %s[__i];' %(arr, arr),\n                            self.indent()+'}'\n                        ])\n                        r.append(self.indent()+'%s[%s] = __front__;' %(arr, idx))\n\n\n                    return '\\n'.join(r)\n\n                else:\n                    raise SyntaxError('fixed size stack allocated arrays can not use iterators to insert elements from another array')\n\n            elif len(node.args)==3:\n                end = self.visit(node.args[2])\n                return '%s.insert(%s, %s, %s)' %(arr, idx, val, end)\n\n            else:\n                raise RuntimeError('TODO .insert(...)')\n\n\n        elif fname.endswith('-\ninsert') and fname.split('-\ninsert')[0] in self._known_arrays and len(node.args)\n=2:\n            arr = fname.split('-\ninsert')[0]\n            idx = self.visit(node.args[0])\n            val = self.visit(node.args[1])\n            if len(node.args)==2:\n                #if '-\n' in val and arr == val.split('-\n')[0] and 'pop' in val:\n                #   if val.endswith('pop_back()'):\n                #       popidx = '%s-\nsize()-1' %arr\n                #   else:\n                #       popidx = val.split('(')[-1].split(')')[0]\n\n                if '-\nbegin()' in idx:\n                    return '%s-\ninsert(%s, %s)' %(arr, idx, val)\n                else:\n                    return '%s-\ninsert(%s-\nbegin()+%s, %s)' %(arr, arr, idx, val)\n                #else:\n                #   return '%s-\ninsert(%s+%s, %s)' %(arr, arr, idx, val)\n            elif len(node.args)==3:\n                end = self.visit(node.args[2])\n                return '%s-\ninsert(%s, %s, %s)' %(arr, idx, val, end)\n\n            else:\n                raise RuntimeError('TODO .insert(...)')\n\n        elif fname == 'double' and self._cpp:\n            return '__double__(%s)' %self.visit(node.args[0])\n\n        elif fname == 'clock' and len(node.args)==0:\n            ## note in c++ std::clock returns clock ticks, not time\n            return '__clock__()'\n\n        elif fname == '__asm__':\n            ASM_WRITE_ONLY = '='  ## write constraint\n            ASM_ANY_REG    = 'r'  ## register name: r, eax, ax, al,  ebx, bx, bl\n            ASM_OUT_DEFAULT = ASM_WRITE_ONLY + ASM_ANY_REG\n\n            code = []\n            if self._cpp:\n                code.append('asm')\n            else:\n                # http://doc.rust-lang.org/guide-unsafe.html#inline-assembly\n                code.append('unsafe{ asm!')\n\n            volatile = False\n            alignstack = False\n            outputs = []\n            inputs = []\n            clobber = []\n            asmcode = None\n            for kw in node.keywords:\n                if kw.arg == 'volatile' and kw.value.id.lower()=='true':\n                    volatile = True\n                elif kw.arg == 'alignstack' and kw.value.id.lower()=='true':\n                    alignstack = True\n                elif kw.arg == 'outputs':\n                    write_mode = ASM_OUT_DEFAULT\n                    if isinstance(kw.value, ast.List):\n                        mode = kw.value.elts[0].s\n                        output = kw.value.elts[1].id\n                        outputs.append('\n%s\n (%s)' %(mode, output))\n                    else:\n                        outputs.append('\n%s\n (%s)' %(write_mode, kw.value.id))\n\n                elif kw.arg == 'inputs':\n                    if isinstance(kw.value, ast.List) or isinstance(kw.value, ast.Tuple):\n                        for elt in kw.value.elts:\n                            if isinstance(elt, ast.List):\n                                register = elt.elts[0].s\n                                input = elt.elts[1].id\n                                inputs.append('\n%s\n (%s)' %(register, input))\n                            else:\n                                inputs.append('\n%s\n (%s)' %(ASM_ANY_REG,elt.id))\n                    else:\n                        inputs.append('\n%s\n (%s)' %(ASM_ANY_REG,kw.value.id))\n                elif kw.arg == 'clobber':\n                    if isinstance(kw.value, ast.List) or isinstance(kw.value, ast.Tuple):\n                        clobber.extend( ['\n%s\n' %elt.s for elt in kw.value.elts] )\n                    else:\n                        clobber.extend(\n                            ['\n%s\n'%clob for clob in kw.value.s.split(',') ]\n                        )\n\n                elif kw.arg == 'code':\n                    asmcode = '\n%s\n' %kw.value.s\n\n            if volatile:\n                if self._cpp:\n                    code.append( 'volatile' )\n\n            assert asmcode\n            if not self._cpp:\n                ## rust asm uses llvm as its backend,\n                ## llvm asm syntax is slightly different from regular gcc,\n                ## input arguments in gcc are given as `%N`,\n                ## while in llvm they are given as `$N`\n                asmcode = self._gccasm_to_llvmasm(asmcode)\n\n            code.append( '(' )\n            code.append( asmcode )\n            code.append( ':' )\n            if outputs:\n                code.append( ','.join(outputs) )\n            code.append( ':' )\n            if inputs:\n                code.append( ','.join(inputs) )\n            code.append( ':' )\n            if clobber:\n                code.append( ','.join(clobber) )\n\n            if self._cpp:\n                code.append( ');')\n            else:\n                code.append( ':' )  ## rust options\n                ropts = []\n                if volatile:\n                    ropts.append('\nvolatile\n')\n                if alignstack:\n                    ropts.append('\nalignstack\n')\n\n                code.append( ','.join(ropts) )\n                code.append( '); } // end unsafe' )\n\n\n            return ' '.join( code )\n\n        elif fname == '__let__':\n            vname = None\n            infer_from = None\n            if len(node.args) and isinstance(node.args[0], ast.Name):\n                vname = node.args[0].id\n            elif len(node.args)==2 and isinstance(node.args[0], ast.Call):\n                ## syntax: `let foo(bar) : SomeClass`, translates into c++11 universal constructor call\n                ## used when using classes from external libraries.\n                assert self._cpp\n                if isinstance(node.args[1], ast.Str):\n                    T = node.args[1].s\n                else:\n                    T = self.visit(node.args[1])\n\n                return '%s %s' %(T, self.visit(node.args[0]))\n\n\n            elif len(node.args) and isinstance(node.args[0], ast.Attribute): ## syntax `let self.x:T = y`\n                assert node.args[0].value.id == 'self'\n                T = None\n                if isinstance(node.args[1], ast.Str):\n                    T = node.args[1].s\n                else:\n                    T = self.visit(node.args[1])\n\n                if len(node.args)==2:\n                    #raise SyntaxError(','.join([self.visit(a) for a in node.args]))\n                    if T.startswith('['):\n                        if self._memory[-1]=='HEAP':\n                            x,y = T.split(']')\n                            n = x.split('[')[-1]\n                            return 'this-\n%s = std::make_shared\nstd::vector\n%s\n(%s);' %(node.args[0].attr, y, n)\n\n                        else:\n                            return '/* %s : %s */' %(node.args[0].attr, T)\n\n\n                value = self.visit(node.args[2])\n\n                if isinstance(node.args[2], ast.Dict):\n                    assert T.startswith('__go__map__')\n                    d = node.args[2]\n                    mtypek = self.visit(node.args[1].args[0])\n                    mtypev = self.visit(node.args[1].args[1])\n                    if mtypev.startswith('{') or '{' in mtypev:\n                        raise RuntimeError(mtypev)\n                    value = '(new std::map\n%s, %s\n)' %(mtypek, mtypev)\n                    #raise SyntaxError(value)\n                if self._cpp:\n                    return 'this-\n%s = %s' %(node.args[0].attr, self.visit(node.args[2]))\n                else:\n                    return '%s = %s' %(self.visit(node.args[0]), self.visit(node.args[2]))\n\n            else:\n                assert node.keywords\n                for kw in node.keywords:\n                    if kw.arg=='mutable': continue\n                    else:\n                        vname = kw.arg\n                        infer_from = kw.value  ## TODO need way to infer types for c++ backend\n\n            if self._function_stack:\n                self._known_vars.add( vname )\n                if vname in self._vars:\n                    self._vars.remove( vname )\n                V = 'let'\n            else:\n                V = 'static'\n\n            mutable = False\n            for kw in node.keywords:\n                if kw.arg=='mutable':\n                    if kw.value.id.lower()=='true':\n                        mutable = True\n\n            if len(node.args) == 0:\n                if self._cpp:\n                    return 'auto %s = %s' %(vname, self.visit(infer_from))\n                else:\n                    if mutable:\n                        return '%s mut %s = %s' %(V, vname, self.visit(infer_from))\n                    else:\n                        return '%s %s = %s' %(V, vname, self.visit(infer_from))\n\n            elif len(node.args) == 1:\n                return '%s %s           /* declared - rust maybe able to infer the type */' %(V, node.args[0].id)\n            elif len(node.args) == 2:\n                if self._cpp:\n                    is_array = False\n                    if isinstance(node.args[1], ast.Str):\n                        T = node.args[1].s\n                        if '__go__array__(' in T:\n                            is_array = True\n                            dims = T.count('__go__array__')\n                            atype = T.split('(')[-1]\n                            if not self.is_prim_type(atype):\n                                atype = 'std::shared_ptr\n%s\n' %atype\n\n                            if dims==1:\n                                T = 'std::vector\n%s\n' %atype\n                            else:\n                                raise RuntimeError(T)  ## TODO\n\n                            ## note: if a shared_ptr is created on the stack without\n                            ## std::make_shared it will print as `0`\n                            ## and if not initalized with data, will segfault if push_back is called.\n                            ## return '%s  %s' %(T, node.args[0].id)\n                            return 'auto %s = std::make_shared\n%s\n()' %(node.args[0].id, T)\n\n                        elif T.startswith('[') and ']' in T:\n                            is_array = True\n                            x,y = T.split(']')\n                            alen = x.split('[')[-1].strip()\n\n                            self._known_arrays[node.args[0].id] = (y, alen)\n                            if not len(self._function_stack):\n                                self._global_arrays[node.args[0].id] = (y, alen)\n\n                            if self._memory[-1]=='STACK':\n                                ## note a fixed size C-array non-global `int myarr[N];` will not always\n                                ## allocate all items to zero or null. gcc4.9 bug?\n                                if alen.isdigit():\n                                    alen = int(alen)\n                                    if y in ('int', 'uint'):\n                                        return '%s %s%s] = {%s}' %(y, node.args[0].id, x, ','.join(['0']*alen))\n                                    elif self.is_prim_type(y):\n                                        return '%s %s%s] = {}' %(y, node.args[0].id, x)  ## TODO test if these are all init to null\n                                    elif y in self._classes:\n                                        return '%s %s%s] = {%s}' %(y, node.args[0].id, x, ','.join([y+'(false)']*alen))\n                                    else:\n                                        raise RuntimeError('TODO let...')\n\n                                return '%s %s%s]' %(y, node.args[0].id, x)\n                            else:\n                                if not self.is_prim_type(y):\n                                    y = 'std::shared_ptr\n%s\n' %y\n                                return 'auto %s = std::make_shared\nstd::vector\n%s\n(%s)' %(node.args[0].id, y, alen)\n\n\n                    else:\n                        T = node.args[1].id\n\n                    if self.is_prim_type(T) or T.endswith('*') or T.endswith('\n') or self._memory[-1]=='STACK':\n                        return '%s  %s' %(T, node.args[0].id)\n                    else:\n                        if not self._shared_pointers:\n                            return '%s*  %s' %(T, node.args[0].id)\n                        elif self._unique_ptr:\n                            return 'std::unique_ptr\n%s\n  %s' %(T, node.args[0].id)\n                        else:\n                            return 'std::shared_ptr\n%s\n  %s' %(T, node.args[0].id)\n                else:\n                    varname = node.args[0].id\n                    typename = None\n                    if isinstance(node.args[1], ast.Str):\n                        typename = node.args[1].s\n                    else:\n                        typename = node.args[1].id\n\n                    if mutable:\n                        return '%s mut %s : %s' %(V, varname, typename)\n                    else:\n                        return '%s %s : %s' %(V, varname, typename)\n\n            elif len(node.args) == 3:\n                if self._cpp:\n                    if isinstance(node.args[1], ast.Name):\n                        T = node.args[1].id\n                    else:\n                        T = node.args[1].s\n                    T = T.strip()\n                    if self.is_prim_type(T) or T.endswith('\n') or isinstance(node.args[2], ast.Set):\n                        if T.endswith('\n'):\n                            ## http://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object\n                            ## TODO is using `const T\n` safer?\n                            #T = 'const '+T  ## this also works\n                            ## strip away `\n`\n                            T = T[:-1]\n                        varname = node.args[0].id\n                        if '*' in T:\n                            varname += '[]' * T.count('*')\n                            if T=='const char*':\n                                self._force_cstr = True\n                        data = self.visit(node.args[2])\n                        self._force_cstr = False\n\n                        return '%s  %s = %s' %(T, varname, data)\n                    else:\n                        if self._memory[-1]=='STACK':\n                            value = self.visit(node.args[2])\n                            if value == 'nullptr' and not T.endswith('*'):\n                                value = T + '(false)'  ## special case, construct the class to act like `None`\n                            return '%s  %s = %s' %(T, node.args[0].id, value)\n                        elif not self._shared_pointers:\n                            self._known_pointers[node.args[0].id] = T\n                            if not len(self._function_stack):\n                                self._globals[node.args[0].id] = T + '*'\n                            return '%s*  %s = %s' %(T, node.args[0].id, self.visit(node.args[2]))\n                        elif self._unique_ptr:\n                            return 'std::unique_ptr\n%s\n  %s = %s' %(T, node.args[0].id, self.visit(node.args[2]))\n                        else:\n                            return 'std::shared_ptr\n%s\n  %s = %s' %(T, node.args[0].id, self.visit(node.args[2]))\n                else:  ## rust\n                    if mutable:\n                        return '%s mut %s : %s = %s' %(V, node.args[0].id, node.args[1].s, self.visit(node.args[2]))\n                    else:\n                        return '%s %s : %s = %s' %(V, node.args[0].id, node.args[1].s, self.visit(node.args[2]))\n            else:\n                raise SyntaxError('TODO __let__ %s' %len(node.args))\n\n        elif fname == '__let__' and isinstance(node.args[0], ast.Attribute):\n            if isinstance(node.args[0].value, ast.Name) and node.args[0].value.id=='self':\n                if self._cpp:\n                    if self._memory[-1]=='STACK':\n                        return 'this.%s = %s' %(node.args[0].attr, self.visit(node.args[-1]))\n                    else:\n                        return 'this-\n%s = %s' %(node.args[0].attr, self.visit(node.args[-1]))\n                else:\n                    return 'self.%s = %s' %(node.args[0].attr, self.visit(node.args[-1]))\n\n        elif fname=='str' and not self._cpp:\n            if self._cpp:\n                #return 'static_cast\nstd::ostringstream*\n( \n(std::ostringstream() \n %s) )-\nstr()' %self.visit(node.args[0])\n                return 'std::to_string(%s)' %self.visit(node.args[0])  ## only works with number types\n            else:\n                return '%s.to_string()' %self.visit(node.args[0])\n\n        elif fname == 'range':\n            assert len(node.args)\n            if self._rust:  ## TODO - some syntax for mutable/immutable range\n                fname = '\nmut ' + fname  ## default to mutable\n                fname += str(len(node.args))\n            else:\n                assert self._cpp\n                fname += str(len(node.args))\n                if self._memory[-1]=='STACK':\n                    fname = '__%s__' %fname\n\n        elif fname == 'len':\n            if self._cpp:\n                arg = self.visit(node.args[0])\n                if arg in self._known_strings:\n                    if self.usertypes and 'string' in self.usertypes:\n                        return '%s.%s()' %(arg, self.usertypes['string']['len'])\n                    else:\n                        return '%s.size()' %arg\n                elif arg.startswith('PyObject_GetAttrString(') and arg.endswith(')'):\n                    return '(long)PySequence_Length(%s)' %arg\n                elif self._memory[-1]=='STACK':\n                    if arg in self._known_arrays and isinstance(self._known_arrays[arg], tuple):\n                        return self._known_arrays[arg][1]\n                    elif arg in self._known_pointers:\n                        return '%s-\nsize()' %arg\n                    else:\n                        return '%s.size()' %arg\n                elif self.usertypes and 'vector' in self.usertypes:\n                    return '%s-\n%s()' %(arg, self.usertypes['vector']['len'])\n                else:\n                    return '%s-\nsize()' %arg\n            else:\n                return '%s.borrow().len()' %self.visit(node.args[0])\n\n        elif fname == 'float':\n            if self._cpp or self._rust:\n                return '__float__(%s)'%self.visit(node.args[0])\n            else:\n                raise SyntaxError(\nTODO float builtin\n)\n\n        elif fname == '__open__':\n            if self._cpp:\n                if len(node.args) == 2:\n                    return '__open__(%s, %s)' % (self.visit(node.args[0]), self.visit(node.args[1]))\n                else:\n                    return '__open__(%s, std::string(\nrb\n))' % self.visit(node.args[0])\n\n            else:\n                return 'File::open_mode( \nPath::new(%s.to_string()), Open, Read )' %self.visit(node.args[0])\n\n        elif fname == '__arg_array__':\n            assert len(node.args)==1\n            T = self.parse_go_style_arg(node.args[0])\n            if self._rust:\n                if self.is_prim_type(T):\n                    #return '\nmut Vec\n%s\n' %T\n                    return 'Rc\nRefCell\n Vec\n%s\n \n' %T\n                else:\n                    #return '\nmut Vec\nmut %s\n' %T  ## old ref style\n                    return 'Rc\nRefCell\n Vec\nRc\nRefCell\n%s\n \n' %T\n\n            elif self._cpp:\n                if self.is_prim_type(T):\n                    if not self._shared_pointers:\n                        return 'std::vector\n%s\n*' %T\n                    elif self._unique_ptr:\n                        return 'std::unique_ptr\nstd::vector\n%s\n' %T\n                    else:\n                        return 'std::shared_ptr\nstd::vector\n%s\n' %T\n                else:\n                    if not self._shared_pointers:\n                        return 'std::vector\n%s*\n*' %T\n                    elif self._unique_ptr:\n                        return 'std::unique_ptr\nstd::vector\n std::unique_ptr\n%s\n \n' %T\n                    else:\n                        return 'std::shared_ptr\nstd::vector\n std::shared_ptr\n%s\n \n' %T\n            else:\n                raise RuntimeError('TODO generic arg array')\n\n        elif fname == '__arg_map__':\n            parse = node.args[0].s\n            assert parse.startswith('map[')\n            key_type = parse.split('[')[-1].split(']')[0]\n            value_type = parse.split(']')[-1]\n            if key_type=='string': key_type = 'std::string'\n            if value_type=='string': value_type = 'std::string'\n            return 'std::shared_ptr\nstd::map\n%s, %s\n' %(key_type, value_type)\n\n\n        if node.args:\n            #args = [self.visit(e) for e in node.args]\n            #args = ', '.join([e for e in args if e])\n            args = []\n            for e in node.args:\n                if self._rust and isinstance(e, ast.Name) and e.id in self._known_arrays:\n                    args.append( e.id+'.clone()' )  ## automatically clone known array Rc box\n                elif isinstance(e, ast.Call) and isinstance(e.func, ast.Attribute) and isinstance(e.func.value, ast.Name) and e.func.value.id in self._known_arrays and e.func.attr=='clone':\n                    if self._rust:\n                        args.append( e.func.value.id+'.clone()' )   ## user called clone()\n                    else:\n                        args.append( e.func.value.id )              ## skip clone() for c++ backend\n                else:\n                    args.append( self.visit(e) )\n\n            args = ', '.join(args)\n\n        else:\n            args = ''\n\n        haskwargs = False\n        if node.keywords:\n            haskwargs = True\n            if args: args += ','\n\n            if self._rust:\n                raise RuntimeError( self.format_error('TODO calling a function named params for rust backend') )\n            elif self._cpp:\n                ## In the future we can easily optimize this away on plain functions,\n                ## because it is simple to lookup the function here, and see the order\n                ## of the named params, and then reorder the args here to bypass\n                ## creating a new `_KwArgs_` instance.\n                args += '(new _KwArgs_())'\n                for kw in node.keywords:\n                    args += '-\n%s(%s)' %(kw.arg,self.visit(kw.value))\n            else:\n                raise RuntimeError('TODO named params for some backend')\n\n        if node.starargs:\n            if args: args += ','\n            if self._cpp:\n                args += '(*%s)' %self.visit(node.starargs)\n            else:\n                args += '*%s...' %self.visit(node.starargs)\n\n\n        if hasattr(node, 'is_new_class_instance') and self._rust:\n            return 'Rc::new(RefCell::new( %s::new(%s) ))' % (fname, args)\n\n        elif self._cpp and fname in self._classes:\n            ## create class instance - new clean style - TODO deprecate all the old _ref_hacks ##\n            prefix = ''\n            if self.usertypes and 'shared' in self.usertypes:\n                prefix = self.usertypes['shared']['template'] % fname\n\n            elif self._memory[-1]=='STACK':\n                if self._classes[fname]._requires_init:\n                    return '%s().__init__(%s)' %(fname,args)\n                else:\n                    return '%s()' %fname\n\n            elif self._shared_pointers:\n                prefix = 'std::shared_ptr\n%s\n' %fname\n            elif self._unique_ptr:\n                prefix = 'std::unique_ptr\n%s\n' %fname\n\n            #########################################\n            if self._classes[fname]._requires_init:\n                if not isinstance(self._stack[-2], ast.Assign) and self._memory[-1]=='HEAP':\n                    if isinstance(self._stack[-2], ast.ListComp):\n                        return '%s((new %s())-\n__init__(%s))' %(prefix,fname,args)\n\n                    #elif self._assign_node:\n                    #   argname = '%s_%s' %(fname, int(id(node)))\n                    #   pre = 'auto %s = %s(new %s()); %s-\n__init__(%s);' %(argname,prefix,fname, argname,args)\n                    #   if not self._assign_pre:\n                    #       self._assign_pre.append(pre)\n                    #   elif pre not in self._assign_pre:\n                    #       self._assign_pre.append(pre)\n                    #   return argname\n                    #elif isinstance(self._stack[-2], ast.Call):\n                    #   print 'WARNING: object created without assignment to a variable'\n                    #   print fname\n                    #   print args\n                    #   return '%s((new %s())-\n__init__(%s))' %(prefix,fname,args)\n                    #elif isinstance(self._stack[-2], ast.Expr):\n                    #   argname = '%s_%s' %(fname, int(id(node)))\n                    #   pre = 'auto %s = %s(new %s()); %s-\n__init__(%s);' %(argname,prefix,fname, argname,args)\n                    #   return pre\n                    #elif isinstance(self._stack[-2], ast.Return):\n                    #   pass\n                    #else:\n                    #   raise SyntaxError(self.format_error('heap mode requires objects are assigned to variables on initialization: %s' %self._stack[-2]))\n\n                    #return '%s((new %s())-\n__init__(%s))' %(prefix,fname,args)\n\n                    ## wrap in lambda ##\n                    return '[\n](){auto _ = %s(new %s()); _-\n__init__(%s); return _;}()' %(prefix,fname,args)\n\n\n                else:\n                    #return '%s((new %s())-\n__init__(%s))' %(prefix,fname,args)\n                    return '[\n](){auto _ = %s(new %s()); _-\n__init__(%s); return _;}()' %(prefix,fname,args)\n\n            else:\n                return '%s(new %s())' %(prefix,fname)\n        else:\n            return '%s(%s)' % (fname, args)\n\n\n\n\nBinOp\n\n\nExtra syntax is supported by \ntypedpython.md\n using \n and special names as a way of encoding syntax that \nregular Python has no support for.\n\n\n    def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n        try:\n            right = self.visit(node.right)\n        except GenerateListComp as err:\n            if isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id=='__go__array__':\n                node.right._comp_type = node.left.args[0].id\n                node.right._comp_dims = 1\n                raise err\n            elif isinstance(node.left, ast.BinOp) and isinstance(node.left.left, ast.Name) and node.left.left.id=='__go__array__':\n                node.right._comp_type = node.left.right.args[0].id\n                node.right._comp_dims = 2\n                raise err\n            else:\n                print node.left\n                print node.right\n                raise SyntaxError(self.format_error(err))\n\n        if op == '\n' and left == '__new__':\n            if self._cpp:\n                if isinstance(node.right, ast.Call) and isinstance(node.right.func, ast.Name):\n                    classname = node.right.func.id\n                    if classname in self._classes:\n                        if node.right.args:\n                            args = ','.join([self.visit(arg) for arg in node.right.args])\n                            return '(new %s)-\n__init__(%s)' %(classname, args)\n                        else:\n                            return '(new %s)-\n__init__()' %classname\n                    else:\n                        if node.right.args:\n                            args = ','.join([self.visit(arg) for arg in node.right.args])\n                            return '(new %s(%s))' %(classname, args)\n                        else:\n                            return '(new %s)' %classname\n\n                else:\n                    #raise SyntaxError(self.format_error(self.visit(node.right)))\n                    return '(new %s)' %self.visit(node.right)\n\n            else:\n                return ' new %s' %right\n\n        elif op == '\n':\n            go_hacks = ('__go__array__', '__go__arrayfixed__', '__go__map__', '__go__func__')\n\n            if isinstance(node.left, ast.Attribute) and node.left.attr=='__doubledot__':  ## this style is deprecated\n                if isinstance(node.right, ast.Call):\n                    return self.gen_cpy_call(self.visit(node.left.value), node.right)\n                    r = [\n                        'PyObject_Call(',\n                        '   PyObject_GetAttrString(%s,\n%s\n),' %(self.visit(node.left.value), node.right.func.id),\n                        '   Py_BuildValue(\n()\n),',\n                        '   NULL',\n                        ')'\n                    ]\n                    return '\\n'.join(r)\n\n                elif isinstance(node.right, ast.Name):\n                    return 'PyObject_GetAttrString(%s,\n%s\n)' %(self.visit(node.left.value), node.right.id)\n                elif isinstance(node.right, ast.Attribute) and node.right.attr=='__doubledot__':\n                    return 'PyObject_GetAttrString(%s,\n%s\n)' %(self.visit(node.left.value), self.visit(node.right.value))\n                else:\n                    raise SyntaxError(self.format_error('bad use of -\n'))\n\n            elif left in ('__go__receive__', '__go__send__'):\n                self._has_channels = True\n                if self._cpp:\n                    ## cpp-channel API\n                    return '%s.recv()' %right\n                elif self._rust:\n                    return '%s.recv().unwrap()' %right\n\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id in go_hacks:\n                if node.left.func.id == '__go__func__':\n                    raise SyntaxError('TODO - go.func')\n                elif node.left.func.id == '__go__map__':\n                    key_type = self.visit(node.left.args[0])\n                    value_type = self.visit(node.left.args[1])\n                    value_vec  = None\n                    if isinstance(node.left.args[0], ast.Str):\n                        key_type = node.left.args[0].s\n                        if key_type.startswith('['):\n                            raise SyntaxError(self.format_error('dictionary keys can not be a vector type'))\n\n                    if isinstance(node.left.args[1], ast.Str):\n                        value_type = node.left.args[1].s\n                        if value_type.startswith('[]'):\n                            value_vec = value_type.split(']')[-1]\n                            value_type = 'std::vector\n%s\n*' % value_vec\n                    elif isinstance(node.left.args[1], ast.Tuple):\n                        tupletype = []\n                        for telt in node.left.args[1].elts:\n                            if isinstance(telt, ast.Str):\n                                v = telt.s\n                                if v.startswith('\n') and v.endswith('\n'):\n                                    v = v[1:-1]\n                            else:\n                                v = self.visit(telt)\n                            if v.startswith('[]'):\n                                t  = v.split(']')[-1]\n                                if self._memory[-1]=='STACK':\n                                    v = 'std::vector\n%s\n' %t\n                                else:\n                                    v = 'std::vector\n%s\n*' %t\n\n                            tupletype.append(v)\n                        if self._memory[-1]=='STACK':\n                            value_type = 'std::tuple\n%s\n' %','.join(tupletype)\n                        else:\n                            value_type = 'std::shared_ptr\nstd::tuple\n%s\n' %','.join(tupletype)\n                        #raise RuntimeError(value_type)\n\n                    #########################\n                    if key_type == 'string':\n                        key_type = 'std::string'\n\n                    if isinstance(node.right, ast.Dict):\n                        items = []\n                        for i in range( len(node.right.keys) ):\n                            k = self.visit(node.right.keys[i])\n                            v = self.visit(node.right.values[i])\n                            if v.startswith('[') and v.endswith(']'):\n                                v = ('new std::vector\n%s\n{'%value_vec) + v[1:-1] + '}'\n                            elif isinstance(node.right.values[i], ast.Tuple): #elif v.startswith('{') and v.endswith('}'):\n                                targs = []\n                                tuptargs = []\n                                for ti,te in enumerate(node.right.values[i].elts):\n                                    tt = tupletype[ti]\n                                    tv = self.visit(te)\n                                    if tv.startswith('[') and tv.endswith(']'):\n                                        assert tt.startswith('std::vector')\n                                        if tt.endswith('*'):\n                                            tv = '(new %s{%s})' %(tt[:-1], tv[1:-1])\n                                        else:\n                                            tv = '%s{%s}' %(tt, tv[1:-1])\n                                    targs.append(tv)\n\n                                if self._memory[-1]=='STACK':\n                                    v = 'std::make_tuple(%s)' %','.join(targs)\n                                else:\n                                    v = 'std::make_shared\nstd::tuple\n%s\n(std::make_tuple(%s))' %(','.join(tupletype), ','.join(targs))\n\n                            items.append('{%s, %s}' %(k,v))\n\n                        right = '{%s}' %'\\n,'.join(items)\n\n                    if self._memory[-1]=='STACK':\n                        return 'std::map\n%s, %s\n%s' %(key_type, value_type, right)\n                    else:\n                        map_type = 'std::map\n%s,%s\n' %(key_type, value_type)\n                        return 'std::shared_ptr\n%s\n(new %s%s)' %(map_type, map_type, right)\n                else:\n                    if isinstance(node.right, ast.Name):\n                        raise SyntaxError(node.right.id)\n\n                    right = []\n                    for elt in node.right.elts:\n                        if isinstance(elt, ast.Num) and self._rust:\n                            right.append( str(elt.n)+'i64' )\n                        else:\n                            right.append( self.visit(elt) )\n\n                    rargs = right[:]\n\n                    if self._rust:\n                        right = '(%s)' %','.join(right)\n                    elif self._cpp:\n                        right = '{%s}' %','.join(right)\n\n                    if node.left.func.id == '__go__array__':\n                        T = self.visit(node.left.args[0])\n                        if self._cpp:\n                            return ('std::vector\n%s\n'%T, rargs)   ## note special case, returns a tuple.\n\n                        elif self._rust:\n                            #return '\nmut vec!%s' %right\n                            return 'Rc::new(RefCell::new(vec!%s))' %right\n\n                        else:\n                            raise RuntimeError('invalid backend')\n\n                    elif node.left.func.id == '__go__arrayfixed__':\n                        asize = self.visit(node.left.args[0])\n                        atype = self.visit(node.left.args[1])\n                        isprim = self.is_prim_type(atype)\n                        if self._cpp:\n                            return ('std::vector\n%s\n'%atype, asize, rargs) ## note special case, returns a tuple.\n                        elif self._rust:\n                            #return '\nvec!%s' %right\n                            return 'Rc::new(RefCell::new(vec!%s))' %right\n                        else:\n                            raise RuntimeError('invalid backend')\n\n\n            elif isinstance(node.left, ast.Name) and node.left.id=='__go__array__':\n                if self._rust:\n                    raise RuntimeError('TODO array pointer')\n                    return '\nmut Vec\n%s\n' %self.visit(node.right)  ## TODO - test this\n                elif self._cpp:\n                    if not isinstance(node.right,ast.Call):\n                        raise RuntimeError('TODO mdarrays')\n\n                    mdtype = self.visit(node.right.args[0])\n                    if not self._shared_pointers:\n                        return 'std::vector\nstd::vector\n%s\n*\n*'%mdtype\n                    elif self._unique_ptr:\n                        return 'std::unique_ptr\nstd::vector\n std::unique_ptr\nstd::vector\n%s\n \n'%mdtype\n                    else:\n                        return 'std::shared_ptr\nstd::vector\n std::shared_ptr\nstd::vector\n%s\n \n'%mdtype\n                else:\n                    raise RuntimeError('invalid backend')\n\n            elif isinstance(node.right, ast.Name) and node.right.id=='__as__':\n                if self._cpp:\n                    return self.visit(node.left)\n                else:\n                    return '%s as ' %self.visit(node.left)\n\n            elif isinstance(node.left, ast.BinOp) and isinstance(node.left.right, ast.Name) and node.left.right.id=='__as__':\n                #cast_to = right\n                cast_to = self.visit(node.right)\n                if isinstance(node.right, ast.Str):\n                    cast_to = node.right.s\n\n                if self._rust:\n                    return '%s %s' %(self.visit(node.left), cast_to)\n                else:\n                    ptr = self.visit(node.left.left)\n                    if cast_to in 'pystring pystr pyint pyi32 pylong pyi64 pyfloat pydouble pyf32 pyf64 pybool'.split():\n                        if cast_to=='pystring' or cast_to=='pystr':\n                            return 'PyString_FromString(%s.c_str())' %ptr\n                        elif cast_to in 'pyint pyi32 pylong pyi64'.split():\n                            return 'PyInt_FromLong(%s)' %ptr\n                        elif cast_to in 'pyfloat pyf32'.split():\n                            return 'PyFloat_FromDouble(%s)' %ptr\n                        else:\n                            raise RuntimeError('TODO as type: %s'%cast_to)\n\n                    elif self.is_prim_type(cast_to):\n                        if type(ptr) is tuple: ## this is probably a bug\n                            ptr = ptr[0]\n                        if ptr.startswith('PyObject_GetAttrString') or ptr.startswith('PyObject_Call'):\n                            if cast_to == 'int':\n                                return 'static_cast\n%s\n(PyInt_AS_LONG(%s))' %(cast_to, ptr)\n                            elif cast_to in ('float','f32'):\n                                return 'static_cast\n%s\n(PyFloat_AsDouble(%s))' %(cast_to, ptr)\n                            elif cast_to in ('double','f64'):\n                                return 'PyFloat_AsDouble(%s)' %ptr\n                            elif cast_to == 'string':\n                                return 'std::string(PyString_AS_STRING(%s))' %ptr\n                            elif cast_to == 'bool':\n                                return '(%s==Py_True)' %ptr\n                            else:\n                                raise RuntimeError('TODO other cast to types for cpython')\n                        else:\n                            return 'static_cast\n%s\n(%s)' %(cast_to, self.visit(node.left.left))\n                    elif self._memory[-1]=='STACK':\n                        cast_from = self.visit(node.left.left)\n                        if isinstance(node.left.left, ast.Str):  ## allow quoted cast to with `as`\n                            cast_from = node.left.left.s\n\n                        if cast_from in self._known_refs:\n                            raise RuntimeError(cast_from)\n                        if self._function_stack:\n                            fnode = self._function_stack[-1]\n                            if fnode.return_type==cast_to:  ## TODO check is node above is ast.Return\n                                return 'static_cast\n%s\n(%s)' %(cast_to, cast_from)\n\n                        return 'static_cast\n%s\n(%s)' %(cast_to, self.visit(node.left.left))\n\n                    elif self._polymorphic:\n                        return 'std::dynamic_pointer_cast\n%s\n(%s)' %(cast_to, self.visit(node.left.left))\n                    else:\n                        return 'std::static_pointer_cast\n%s\n(%s)' %(cast_to, self.visit(node.left.left))\n\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id=='inline':\n                return '%s%s' %(node.left.args[0].s, right)\n            else:\n                ## TODO this is hackish\n                if type(left) is tuple:\n                    raise RuntimeError(left)\n                atype = left.split('\n')[-1].split('\n')[0]\n                if isinstance(node.right, ast.Tuple):\n                    r = ['new std::vector\n%s\n %s' %(atype, self.visit(elt)) for elt in node.right.elts]\n                    right = '{%s}' %','.join(r)\n                return (left, right)  ## special case for new arrays\n\n\n        if left in self._typed_vars and self._typed_vars[left] == 'numpy.float32':  ## deprecated\n            left += '[_id_]'\n        if right in self._typed_vars and self._typed_vars[right] == 'numpy.float32':  ## deprecated\n            right += '[_id_]'\n\n        #if op=='\n':\n        #   #raise SyntaxError(type(node.left))\n        #   raise SyntaxError(left+right)\n        if left in self._known_instances:\n            left = '*'+left\n\n        return '(%s %s %s)' % (left, op, right)\n\n    def visit_ListComp(self, node):\n        #raise RuntimeError('list comps are only generated from the parent node')\n        raise GenerateListComp(node)\n\n\n\n\n\nReturn\n\n\nTODO remove GenerateTypeAssert, go leftover.\nTODO tuple return for c++\n\n\n\n    #def visit_Num(self, node):\n    #   return node.n\n\n    def visit_Raise(self, node):\n        if self._rust:\n            return 'panic!(\n%s\n);'  % self.visit(node.type)\n        elif self._cpp:\n            if isinstance(node.type, ast.Call) and node.type.keywords:\n                self._has_rebuild = True\n                args = []\n                for k in node.type.keywords:\n                    args.append( self.visit(k.value) + ' /*%s*/'%k.arg )\n                return '__request_rebuild( %s );' %','.join(args)\n            else:\n                T = self.visit(node.type)\n                return 'throw %s;' % T\n        else:\n            raise RuntimeError('unknown backend')\n\n\n    def visit_Return(self, node):\n        assert not self._cpp  ## cpptranslator.md overrides this\n        if isinstance(node.value, ast.Tuple):\n            return 'return %s;' % ', '.join(map(self.visit, node.value.elts))\n        elif node.value:\n            v = self.visit(node.value)\n            return 'return %s;' % v\n        return 'return;'\n\n\n\n\nLambda Functions\n\n\nrust lambda\nc++11 lambda\n\n\nLambda functions have a different type syntax from normal functions and methods.\nRegular functions and methods type their arguments with Python3 annotation syntax,\n\ndef f( a:int ):\n\n\nLambda functions type their arguments using the keyword default value,\n\nlambda a=int:\n\n\n\n    def visit_Lambda(self, node):\n        args = [self.visit(a) for a in node.args.args]\n        if args and args[0]=='__INLINE_FUNCTION__':\n            raise SyntaxError('TODO inline lambda/function hack')\n        elif self._cpp:\n            assert len(node.args.args)==len(node.args.defaults)\n            args = []\n            for i,a in enumerate(node.args.args):\n                T = node.args.defaults[i].s\n                if not self.is_prim_type(T): T = 'std::shared_ptr\n%s\n' %T\n                s = '%s  %s' %(T, self.visit(a))\n                args.append( s )\n            ## TODO support multiline lambda, and return the last line\n            return '[\n](%s){ return %s; }' %(','.join(args), self.visit(node.body))\n        else:\n            return '|%s| %s ' %(','.join(args), self.visit(node.body))\n\n\n\n\n\nFunction/Method\n\n\nnote: functions defined in \nwith extern(abi=\"C\"):\n are \ndeclare_only\n their bodies are skipped.\noperator overloading is implemented here for c++\nTODO clean up go stuff.\n\n\n\n    def _visit_function(self, node):\n        func_pre = []\n        out = []\n\n        is_declare = hasattr(node, 'declare_only') and node.declare_only  ## see pythonjs.py visit_With\n        is_closure = False\n        node.is_abstract = False\n        node.func_header = None\n        node.func_args = []\n        node.func_body = []\n\n        if self._function_stack[0] is node:\n            self._global_functions[node.name] = node\n            self._vars = set()\n            self._known_vars = set()\n            self._known_instances = dict()\n            self._known_arrays    = dict()\n            self._known_arrays.update( self._global_arrays )\n            self._known_strings   = set()\n            self._known_pyobjects = dict()\n            self._known_refs      = dict()\n            self._known_refs.update( self._global_refs )\n            self._known_pointers  = dict()\n            self._known_tuples    = dict()\n            self._known_tuples.update( self._global_tuples )\n\n        elif len(self._function_stack) \n 1:\n            ## do not clear self._known_* inside of closures ##\n            is_closure = True\n\n        comments = []\n        for b in node.body:\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Str):\n                comments.append( b.value.s )\n        if comments:\n            out.append('/**')\n            for line in comments[0].splitlines():\n                out.append(' * '+line)\n            out.append(' */')\n\n\n        args_typedefs = {}\n        chan_args_typedefs = {}\n        generics = set()\n        args_generics = dict()\n        args_super_classes = {}\n        func_pointers = set()\n        arrays = dict()\n        operator = None\n        if node.name in ('__getitem__', '__setitem__'):  ## TODO support setitem, return a proxy with `=` overloaded?\n            operator = '[]'\n        elif node.name == '__unwrap__':\n            operator = '-\n'\n        elif node.name == '__copy__':\n            operator = '='\n        elif node.name == '__call__':\n            operator = '()'\n        elif node.name == '__add__':\n            operator = '+'\n        elif node.name == '__iadd__':\n            operator = '+='\n        elif node.name == '__sub__':\n            operator = '-'\n        elif node.name == '__isub__':\n            operator = '-='\n        elif node.name == '__mul__':\n            operator = '*'\n        elif node.name == '__imul__':\n            operator = '*='\n        elif node.name == '__div__':\n            operator = '/'\n        elif node.name == '__idiv__':\n            operator = '/='\n\n\n        options = {'getter':False, 'setter':False, 'returns':None, 'returns_self':False, 'generic_base_class':None, 'classmethod':False}\n\n        virtualoverride = False\n        extern = False\n\n        for decor in node.decorator_list:\n            self._visit_decorator(\n                decor,\n                node=node,\n                options=options,\n                args_typedefs=args_typedefs,\n                chan_args_typedefs=chan_args_typedefs,\n                generics=generics,\n                args_generics=args_generics,\n                func_pointers=func_pointers,\n                arrays = arrays,\n                args_super_classes=args_super_classes,\n            )\n\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'expression':\n                assert len(decor.args)==1\n                node.name = self.visit(decor.args[0])\n            elif isinstance(decor, ast.Name) and decor.id=='jvm':\n                raise RuntimeError('TODO @jvm for function')\n            elif isinstance(decor, ast.Name) and decor.id=='virtualoverride':\n                virtualoverride = True\n            elif isinstance(decor, ast.Name) and decor.id=='extern':\n                extern = True\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'macro':\n                #out.append(decor.args[0].s)\n                if self._cpp:\n                    self._cpp_class_header.append(decor.args[0].s)\n            elif isinstance(decor, ast.Name) and decor.id=='abstractmethod':\n                ## TODO: virtual function c++\n                assert self._cpp\n                out.append('/* abstractmethod: %s */' %node.name)\n                node.is_abstract = True\n            elif isinstance(decor, ast.Attribute) and decor.attr=='safe':  ## GCC STM\n                func_pre.append('__attribute__((transaction_safe))')\n            elif isinstance(decor, ast.Attribute) and decor.attr=='pure':  ## GCC STM\n                func_pre.append('__attribute__((transaction_pure))')\n\n        for name in arrays:\n            arrtype = args_typedefs[name]#arrays[ name ]\n            if '[' in arrtype:\n                # C-style\n                if arrtype.endswith(']'):\n                    raise RuntimeError(arrtype)\n                else:\n                    raise RuntimeError(arrtype+'!!!')\n\n            self._known_arrays[ name ] = arrtype\n\n        for name in args_typedefs:\n            if args_typedefs[name]=='string':\n                self._known_strings.add(name)\n            elif args_typedefs[name].endswith('\n'):\n                self._known_refs[name] = args_typedefs[name]\n            elif args_typedefs[name].endswith('*'):\n                self._known_instances[name]= args_typedefs[name]\n                self._known_pointers[name] = args_typedefs[name]\n\n\n        node.returns_self = returns_self = options['returns_self']\n        return_type = options['returns']\n        generic_base_class = options['generic_base_class']\n        #if self._cpp and return_type and return_type.startswith('tuple('):\n        #   raise RuntimeError(return_type)\n\n        if returns_self and self._cpp:\n            return_type = self._class_stack[-1].name\n\n        node.func_returns = return_type\n\n        is_delete = node.name == '__del__'\n        is_init = node.name == '__init__'\n        is_main = node.name == 'main'\n        if is_main and self._cpp:  ## g++ requires main returns an integer\n            return_type = 'int'\n        elif is_init and self._cpp:\n            if self._memory[-1]=='STACK':\n                return_type = '%s' %self._class_stack[-1].name\n            else:\n                return_type = '%s*' %self._class_stack[-1].name\n\n        elif return_type and not self.is_prim_type(return_type):\n            if self._cpp:\n                if 'returns_array' in options and options['returns_array']:\n                    pass\n                else:\n                    if return_type.endswith('\n') or return_type.endswith('*') or return_type.endswith('\n') or self._memory[-1]=='STACK':\n                        pass\n                    elif self.usertypes and 'shared' in self.usertypes:\n                        return_type = self.usertypes['shared']['template'] % return_type\n                    elif not self._shared_pointers:\n                        return_type = '%s*' %return_type\n                        #return_type = '%s' %return_type  ## return copy of object\n\n                    elif self._unique_ptr:\n                        return_type = 'std::unique_ptr\n%s\n' %return_type\n                    else:\n                        return_type = 'std::shared_ptr\n%s\n' %return_type\n            else:\n                if return_type == 'self':  ## Rust 1.2 can not return keyword `self`\n                    return_type = self._class_stack[-1].name\n\n                return_type = 'Rc\nRefCell\n%s\n' %return_type\n\n        if return_type == 'string':\n            if self._cpp:\n                if self.usertypes and 'string' in self.usertypes:\n                    return_type = self.usertypes['string']['type']\n                else:\n                    return_type = 'std::string'\n            elif self._rust:\n                return_type = 'String'\n\n        node.return_type = return_type\n        node._arg_names = args_names = []\n        args = []\n        oargs = []\n        offset = len(node.args.args) - len(node.args.defaults)\n        varargs = False\n        varargs_name = None\n        is_method = False\n        args_gens_indices = []\n        closures = []\n        alt_versions = []  ## list of ([args], [body])\n        if args_super_classes:\n            alt_versions.append( ([],[]) )\n\n        has_stdmove = False\n        stdmoveargs  =[]\n\n        for i, arg in enumerate(node.args.args):\n            arg_name = arg.id\n            dindex = i - offset\n            stdmove = False\n\n            if arg_name not in args_typedefs.keys()+chan_args_typedefs.keys():\n                if arg_name=='self':\n                    assert i==0\n                    is_method = True\n                    continue\n                elif dindex \n= 0 and node.args.defaults and self.visit(node.args.defaults[dindex]).startswith('move('):\n                    stdmove = True\n                    has_stdmove = True\n                    #fails in c++11#a = 'auto %s = std::%s' %(arg_name, self.visit(node.args.defaults[dindex]))\n                    a = '%s = std::%s' %(arg_name, self.visit(node.args.defaults[dindex]))\n                elif self._cpp:\n                    args_typedefs[arg_name]='auto'  ## c++14\n                else:\n                    err =[\n                        '- - - - - - - - - - - - - - - - - -',\n                        'error in function: %s' %node.name,\n                        'missing typedef: %s' %arg.id,\n                        '- - - - - - - - - - - - - - - - - -',\n                    ]\n                    raise SyntaxError( self.format_error('\\n'.join(err)) )\n\n            if arg_name in args_typedefs:\n                arg_type = args_typedefs[arg_name]\n                if self._cpp:\n                    if args_super_classes:\n                        altargs, altbody = alt_versions[0]\n                        if arg_name in args_super_classes:\n                            if is_method:  ## inlined wrapper methods\n                                altargs.append(\n                                    'std::shared_ptr\n%s\n %s' %(args_super_classes[arg_name][0], arg_name)\n                                )\n                                altbody.append('std::static_pointer_cast\n%s\n(%s),' %(arg_type.split('\n')[-1].split('\n')[0], arg_name))\n                            else:  ## fully regenerated function\n                                altargs.append(\n                                    'std::shared_ptr\n%s\n __%s' %(args_super_classes[arg_name][0], arg_name)\n                                )\n                                altbody.append('auto %s = std::static_pointer_cast\n%s\n(__%s);' %(arg_name, arg_type.split('\n')[-1].split('\n')[0], arg_name))\n                        else:\n                            altargs.append('%s %s' %(arg_type, arg_name))\n                            altbody.append(arg_name+',')\n\n                    ## TODO better way to guess if an untyped param is a pointer\n                    #if arg_type=='auto':\n                    #   self._known_instances[arg_name]='auto'\n\n                    ## rule above assumes anything marked with `auto` should not used __shared__ wrapper and directly use `a-\nb`\n                    if arg_type in ('string', 'string*', 'string\n', 'string\n'):\n                        if self.usertypes and 'string' in self.usertypes:\n                            if arg_type.endswith('\n'):\n                                arg_type = self.usertypes['string']['type'] + '\n'\n                            elif arg_type.endswith('\n'):\n                                arg_type = self.usertypes['string']['type'] + '\n'\n                            elif arg_type.endswith('*'):\n                                arg_type = self.usertypes['string']['type'] + '*'\n                            else:\n                                arg_type = self.usertypes['string']['type']\n                        else:\n                            ## standard string type in c++ std::string\n                            arg_type = arg_type.replace('string', 'std::string')\n\n                    if 'std::' in arg_type and arg_type.endswith('\n') and ('shared_ptr' in arg_type or 'unique_ptr' in arg_type):\n                        if arg_name in self._known_instances:\n                            print 'nested lambda?'\n                        self._known_instances[arg_name] = arg_type\n\n\n                    if arg_name in func_pointers:\n                        ## note C has funky function pointer syntax, where the arg name is in the middle\n                        ## of the type, the arg name gets put there when parsing above.\n                        a = arg_type\n                    elif arg_type.endswith(']'):\n                        atype,alen = arg_type.split('[')\n                        self._known_arrays[arg_name] = (atype, alen[:-1])\n                        a = '%s %s[%s' %(atype, arg_name, alen)\n                    else:\n                        a = '%s %s' %(arg_type, arg_name)\n\n                    if generics and arg_name in args_generics.keys():\n                        args_gens_indices.append(i)\n\n                    if arg_type.endswith('*'):\n                        self._known_pointers[arg_name] = arg_type  ## TODO, strip star?\n\n                elif self._rust:  ## standard string type in rust `String`\n                    if arg_type == 'string': arg_type = 'String'  \n                    if '|' in arg_type:\n                        x,y,z = arg_type.split('|')\n                        arg_type = '__functype__%s'%len(closures)\n                        closures.append('%s:Fn(%s) %s' %('__functype__%s'%len(closures), y,z))\n\n                    a = '%s:%s' %(arg_name, arg_type)\n\n\n            elif arg_name in chan_args_typedefs:\n                arg_type = chan_args_typedefs[arg_name]\n                is_sender = False\n                is_recver = False\n                if arg_type.startswith('Sender\n'):\n                    arg_type = arg_type[ len('Sender\n') : -1 ]\n                    is_sender = True\n                elif arg_type.startswith('Receiver\n'):\n                    arg_type = arg_type[ len('Receiver\n') : -1 ]\n                    is_recver = True\n\n\n                if self._cpp:\n                    ## cpp-channel API is both input and output like Go.\n                    if self.is_prim_type(arg_type):\n                        a = 'cpp::channel\n%s\n  %s' %(arg_type, arg_name)\n                    else:\n                        a = 'cpp::channel\n%s*\n  %s' %(arg_type, arg_name)\n                elif self._rust:\n                    ## allow go-style `chan` keyword with Rust backend,\n                    ## defaults to Sender\nT\n, because its assumed that sending channels\n                    ## will be the ones most often passed around.\n                    ## the user can use rust style typing `def f(x:X\nt\n):` in function defs\n                    ## to type a function argument as `Reveiver\nt\n`\n\n                    if is_recver:\n                        a = '%s : Receiver\n%s\n' %(arg_name, arg_type)\n                    else:\n                        a = '%s : Sender\n%s\n' %(arg_name, arg_type)\n\n                else:\n                    raise RuntimeError('TODO chan for backend')\n\n\n            if dindex \n= 0 and node.args.defaults and not stdmove:\n                default_value = self.visit( node.args.defaults[dindex] )\n                ## because _KwArgs_ class has argument types that refer to user defined\n                ## classes (that are forward declared), only pointers or std::shared_ptr\n                ## can be used as their type, otherwise g++ will fail with this error:\n                ## error: \u2018MyClass\u2019 has incomplete type\n                if not self.is_prim_type(arg_type):\n                    if not arg_type.endswith('*') and not arg_type.endswith('\n') and not arg_type.endswith('\n') and not arg_type.startswith('std::'):\n                        assert self._memory[-1]=='STACK'\n                        arg_type += '*'\n                        args_typedefs[arg_name] = arg_type\n\n                self._kwargs_type_[ arg_name ] = arg_type\n                oargs.append( (arg_name, default_value) )\n            elif stdmove:\n                stdmoveargs.append(a)\n            else:\n                args.append( a )\n                node._arg_names.append( arg_name )\n\n        ##############################################\n        if args_super_classes:\n            if is_method:\n                altargs, altbody = alt_versions[0]\n                altbody.insert(0,'{ return %s('%node.name)\n                if altbody[-1][-1]==',':\n                    altbody[-1] = altbody[-1][:-1]\n                altbody[-1] += ');}'\n            else:\n                ## there is a bug in gcc4.9 where a static_pointer_cast of a shared pointer\n                ## can cause a segfault in the generated wrapper functions.\n                ## note: the wrappers work with methods, see above.\n                altbody.insert(0,'{')\n\n                for b in node.body:\n                    altbody.append(self.indent()+self.visit(b))\n                altbody.append('}')\n\n        if oargs:\n            node._arg_names.append( '__kwargs' )\n            if self._cpp:\n                args.append( '_KwArgs_*  __kwargs')\n            elif self._rust:\n                raise SyntaxError( self.format_error('TODO named keyword parameters') )\n            else:\n                raise SyntaxError('TODO kwargs for some backend')\n\n        starargs = None\n        if node.args.vararg:\n            if self._cpp: raise RuntimeError('TODO *args for c++')\n            starargs = node.args.vararg\n            assert starargs in args_typedefs\n            args.append( '__vargs__ : Vec\n%s\n' %args_typedefs[starargs])\n            node._arg_names.append( starargs )\n\n        #prefix = '__attribute__((visibility(\ndefault\n))) '  ## this fails to force functions to be available to ctypes in CPython.\n        prefix = ''\n        if func_pre:\n            prefix +=  ' '.join(func_pre) + ' '\n\n        if options['classmethod']:\n            prefix += 'static '\n            if args and 'object ' in args[0]:  ## classmethods output from java2python produces `cls:object`\n                args = args[1:]\n        if extern:\n            prefix += 'extern '\n            is_declare = True\n\n        if virtualoverride:\n            is_method = True\n\n        fname = node.name\n        if operator:\n            fname = 'operator ' + operator\n\n        #if self._cpp:\n        #   for arg in args:\n        #       if arg.startswith('string '):\n        #           raise RuntimeError(args)  ## should never happen\n\n        node._args_signature = ','.join(args)\n        ####\n        if is_method:\n            assert self._class_stack\n            method = '(self *%s)  ' %self._class_stack[-1].name\n        else:\n            method = ''\n\n        clonames = ','.join(['__functype__%s'%ci for ci in range(len(closures))])\n\n\n        if is_closure:\n            if self._rust and closures:\n                raise SyntaxError('TODO: rust syntax for a lambda function that takes function pointers as arguments')\n\n            if return_type:\n                if self._rust:\n                    out.append( 'let %s = |%s| -\n %s {\\n' % (node.name, ', '.join(args), return_type) )\n                elif self._cpp:\n                    if has_stdmove:\n                        out.append( 'auto %s = [%s](%s) -\n %s {\\n' % (node.name, ', '.join(stdmoveargs), ', '.join(args), return_type) )\n                    else:\n                        out.append( 'auto %s = [\n](%s) -\n %s {\\n' % (node.name, ', '.join(args), return_type) )\n            else:\n                if self._rust:\n                    out.append( 'let %s = |%s| {\\n' % (node.name, ', '.join(args)) )\n                elif self._cpp:\n                    if has_stdmove:\n                        out.append( 'auto %s = [%s](%s) {\\n' % (node.name,', '.join(stdmoveargs), ', '.join(args)) )\n                    else:\n                        out.append( 'auto %s = [\n](%s) {\\n' % (node.name, ', '.join(args)) )\n\n        else:\n            if return_type:\n                if self._cpp: ## c++ ##\n                    if is_method or options['classmethod']:\n                        classname = self._class_stack[-1].name\n                        sig = '%s %s::%s(%s)' % (return_type, classname, fname, ', '.join(args))\n\n                        if self._noexcept:\n                            out.append( self.indent() + '%s noexcept {\\n' % sig )\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n                            self._cpp_class_header.append(sig + ' noexcept;')\n                        else:\n                            out.append( self.indent() + '%s {\\n' % sig )\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n\n                            if virtualoverride:\n                                sig = 'virtual %s override' %sig\n\n                            self._cpp_class_header.append(sig + ';')\n\n                            if alt_versions:\n                                assert args_super_classes\n                                for av in alt_versions:\n                                    altargs, altbody = av\n                                    asig = 'inline %s %s(%s)' % (return_type, fname, ', '.join(altargs))\n                                    self._cpp_class_header.append( asig + '\\n'.join(altbody))\n\n                            if node.args.defaults:\n                                if len(args)==1:  ## all args have defaults, generate plain version with no defaults ##\n                                    okwargs = ['(new _KwArgs_)']\n                                    args = []\n                                    for oarg in oargs:\n                                        oname = oarg[0]\n                                        T = args_typedefs[oname]\n                                        if T=='string':\n                                            T = 'std::string'\n                                        args.append('%s %s' %(T, oname))\n                                        okwargs.append('%s(%s)' %(oname,oname))\n\n                                    okwargs = '-\n'.join(okwargs)\n                                    osig = '%s%s %s(%s) { return this-\n%s(%s); }' % (prefix,return_type, fname, ','.join(args), fname, okwargs)\n                                    self._cpp_class_header.append(osig)\n\n                    else:  ## regular function\n                        if self._noexcept:\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n                            out.append( self.indent() + '%s noexcept {\\n' % sig )\n                            if not is_main: self._cheader.append( sig + ' noexcept;' )\n                        else:\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n                            out.append( self.indent() + '%s {\\n' % sig )\n                            if not is_main:\n                                self._cheader.append( sig + ';' )\n                                if alt_versions:\n                                    assert args_super_classes\n                                    for av in alt_versions:\n                                        altargs, altbody = av\n                                        asig = '%s %s(%s)' % (return_type, fname, ', '.join(altargs))\n                                        out.insert(0, asig + '\\n'.join(altbody))\n\n                else:  ## rust ##\n                    if is_method:\n                        self._rust_trait.append('fn %s(\nmut self, %s) -\n %s;' %(node.name, ', '.join(args), return_type) )\n                        if closures:\n                            out.append( self.indent() + 'fn %s\n%s\n(\nmut self, %s) -\n %s' % (node.name, clonames, ', '.join(args), return_type) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n\n                        else:\n                            out.append( self.indent() + 'fn %s(\nmut self, %s) -\n %s {' % (node.name, ', '.join(args), return_type) )\n\n                    else:\n                        if closures:\n                            out.append( self.indent() + 'fn %s\n%s\n(%s) -\n %s' % (node.name, clonames, ', '.join(args), return_type) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n                        else:\n                            out.append( self.indent() + 'fn %s(%s) -\n %s {' % (node.name, ', '.join(args), return_type) )\n\n            else:  ## function with no return type, `auto` can be used in c++14 to find the return type.\n\n                if self._cpp: ## c++ ##\n                    if is_method or options['classmethod']:\n                        classname = self._class_stack[-1].name\n                        if is_delete:\n                            sig = '%s::~%s()' %(classname, classname)\n                            if self._noexcept:\n                                out.append( self.indent() + '%s noexcept {\\n' % sig  )\n                                sig = '~%s()' %classname\n                                self._cpp_class_header.append(sig + ';')\n                            else:\n                                out.append( self.indent() + '%s {\\n' % sig  )\n                                sig = '~%s()' %classname\n                                self._cpp_class_header.append(sig + ';')\n\n                        else:\n                            sig = 'auto %s::%s(%s)' %(classname, fname, ', '.join(args))\n                            if self._noexcept:\n                                out.append( self.indent() + '%s noexcept {\\n' % sig  )\n                                sig = '%sauto %s(%s)' % (prefix,fname, ', '.join(args))\n                                self._cpp_class_header.append(sig + ' noexcept;')\n                            else:\n                                out.append( self.indent() + '%s {\\n' % sig  )\n                                sig = '%sauto %s(%s)' % (prefix,fname, ', '.join(args))\n\n                                if virtualoverride:\n                                    sig = 'virtual %s override' %sig\n\n                                self._cpp_class_header.append(sig + ';')\n                    else:\n                        if self._noexcept:\n                            sig = '%sauto %s(%s)' %(prefix, fname, ', '.join(args))\n                            out.append( self.indent() + '%s noexcept {\\n' % sig  )\n                            if not is_main: self._cheader.append( sig + ' noexcept;' )\n                        else:\n                            sig = '%sauto %s(%s)' %(prefix, fname, ', '.join(args))\n                            out.append( self.indent() + '%s {\\n' % sig  )\n                            if not is_main: self._cheader.append( sig + ';' )\n\n                else:         ## rust ##\n                    if is_method:\n                        self._rust_trait.append('fn %s(\nmut self, %s);' %(node.name, ', '.join(args)) )\n                        if closures:\n                            out.append( self.indent() + 'fn %s\n%s\n(\nmut self, %s) ' % (node.name, clonames, ', '.join(args)) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n                        else:\n                            out.append( self.indent() + 'fn %s(\nmut self, %s) {' % (node.name, ', '.join(args)) )\n\n                    else:\n                        if closures:\n                            out.append( self.indent() + 'fn %s\n%s\n(%s)' % (node.name, clonames, ', '.join(args)) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n                        else:\n                            out.append( self.indent() + 'fn %s(%s) {' % (node.name, ', '.join(args)) )\n\n        self.push()\n\n        if oargs:\n            for n,v in oargs:\n                if self._cpp:\n                    T = args_typedefs[n]\n                    if T=='string':\n                        T = 'std::string'\n                    ## in stack mode the user must explicitly pass a pointer\n                    ## when using keyword arguments and object instances.\n                    ## (in heap mode this is not required)\n                    if n in self._kwargs_type_ and self._memory[-1]=='STACK':\n                        T = self._kwargs_type_[n]\n\n                    out.append(self.indent() + '%s  %s = %s;' %(T,n,v))\n                    out.append(self.indent() + 'if (__kwargs-\n__use__%s == true) {' %n )\n                    out.append(self.indent() +  '  %s = __kwargs-\n_%s_;' %(n,n))\n                    out.append(self.indent() + '}')\n\n                else:\n                    out.append(self.indent() + 'let mut %s = %s;' %(n,v))\n                    out.append(self.indent() + 'if (__kwargs.__use__%s == true) {' %n )\n                    out.append(self.indent() +  '  %s = __kwargs.%s;' %(n,n))\n                    out.append(self.indent() + '}')\n\n            if self._cpp:\n                ## TODO free __kwargs\n                pass\n\n        if starargs:\n            out.append(self.indent() + 'let %s = \n__vargs__;' %starargs)\n\n        if self._cpp:\n            for b in node.body:\n                out.append(self.indent()+self.visit(b))\n\n        else:  ## the rust backend requires this?\n            body = node.body[:]\n            body.reverse()\n            self.generate_generic_branches( body, out, self._vars, self._known_vars )\n\n\n        self._scope_stack = []\n\n        if self._threads:\n            assert self._cpp\n            while self._threads:\n                threadname = self._threads.pop()\n                out.append(self.indent()+'if (%s.joinable()) %s.join();' %(threadname,threadname))\n\n        if is_main and self._cpp:\n            if self._has_jvm:\n                out.append('std::cout \n \nprogram exit - DestroyJavaVM\n \nstd::endl;')\n                out.append(self.indent()+'__javavm__-\nDestroyJavaVM();')\n                out.append('std::cout \n \nJavaVM shutdown ok.\n \nstd::endl;')  ## jvm crashes here TODO fixme.\n                #out.append('delete __javavm__;')  ## invalid pointer - segfault.\n            out.append( self.indent() + 'return 0;' )\n        if is_init and self._cpp:\n            if self._memory[-1]=='STACK':\n                out.append( self.indent() + 'return *this;' )\n            else:\n                out.append( self.indent() + 'return this;' )\n\n            #if not self._shared_pointers:\n            #   out.append( self.indent() + 'return this;' )\n            #else:\n            #   #out.append( self.indent() + 'return std::make_shared\n%s\n(this);' %self._class_stack[-1].name )  ## crashes GCC\n            #   out.append( self.indent() + 'return nullptr;' )  ## the exe with PGO will crash if nothing returns\n\n        if len(self._known_arrays.keys()):\n            out.append( self.indent()+'/* arrays:')\n            for arrname in self._known_arrays:\n                arrtype = self._known_arrays[arrname]\n                out.append(self.indent()+'  %s : %s' %(arrname, arrtype))\n            out.append('*/')\n\n        self.pull()\n        if (self._rust or self._cpp) and is_closure:\n            out.append( self.indent()+'};' )\n        else:\n            if is_declare:\n                return out[0].replace('{', ';')\n            else:\n                out.append( self.indent()+'}' )\n\n        node.func_body = out[:]\n\n        if generics and self._cpp:\n            overloads = []\n            gclasses = set(args_generics.values())\n            for gclass in gclasses:\n\n                for subclass in generics:\n                    for i,line in enumerate(out):\n                        if i==0: line = line.replace('\n%s\n'%gclass, '\n%s\n'%subclass)\n                        overloads.append(line)\n\n                if len(args_generics.keys()) \n 1:\n                    len_gargs = len(args_generics.keys())\n                    len_gsubs = len(generics)\n                    gsigs = []\n\n                    p = list(generics)\n                    p.append( generic_base_class )\n                    while len(p) \n len_gargs:\n                        p.append( generic_base_class )\n                    gcombos = set( itertools.permutations(p) )\n                    if len(gcombos) \n 16:  ## TODO fix bug that makes this explode\n                        for combo in gcombos:\n                            combo = list(combo)\n                            combo.reverse()\n                            gargs = []\n                            for idx, arg in enumerate(args):\n                                if idx in args_gens_indices:\n                                    gargs.append(\n                                        arg.replace('\n%s\n'%gclass, '\n%s\n'%combo.pop())\n                                    )\n                                else:\n                                    gargs.append( arg )\n\n                        sig = '%s %s(%s)' % (return_type, node.name, ', '.join(gargs))\n                        gsigs.append( sig )\n\n                    for sig in gsigs:\n                        overloads.append('%s {' %sig)\n                        for line in out[1:]:\n                            overloads.append(line)\n\n\n            out.extend(overloads)\n\n        return '\\n'.join(out)\n\n    def _hack_return(self, v, return_type, gname, gt, node):\n        ## TODO - fix - this breaks easily\n        raise RuntimeError('hack return deprecated')\n        if v.strip().startswith('return ') and '*'+gt != return_type:\n            if gname in v and v.strip() != 'return self':\n                if '(' not in v:\n                    v += '.(%s)' %return_type\n                    v = v.replace(gname, '__gen__')\n                    self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n        return v\n\n\n\n\n\ngenerate_generic_branches\n\n\nTODO, this is a left over from the Go backend,\nit is a nice hack that generates a branch in the caller for methods that return different types,\nthis could also come in handy with the rust and c++ backends.\n\n\n\n    def generate_generic_branches(self, body, out, force_vars, force_used_vars):\n        #out.append('/* GenerateGeneric */')\n        #out.append('/*vars: %s*/' %self._vars)\n        #out.append('/*used: %s*/' %self._known_vars)\n\n        #force_vars, force_used_vars = self._scope_stack[-1]\n        self._vars = set(force_vars)\n        self._known_vars = set(force_used_vars)\n\n        #out.append('/*force vars: %s*/' %force_vars)\n        #out.append('/*force used: %s*/' %force_used_vars)\n\n        prev_vars = None\n        prev_used = None\n        vars = None\n        used = None\n\n        vars = set(self._vars)\n        used = set(self._known_vars)\n\n        #out.append('/*Sstack len: %s*/' %len(self._scope_stack))\n        #if self._scope_stack:\n        #   out.append('/*stack: %s - %s*/' %self._scope_stack[-1])\n        #   out.append('/*STAK: %s */' %self._scope_stack)\n\n\n        while len(body):\n            prev_vars = vars\n            prev_used = used\n\n            b = body.pop()\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Str):  ## skip doc strings here\n                continue\n\n            try:\n                v = self.visit(b)\n                if v: out.append( self.indent() + v )\n            except GenerateGenericSwitch as err:\n                self._scope_stack.append( (set(self._vars), set(self._known_vars)))\n\n                #out.append('/*         GenerateGenericSwitch */')\n                #out.append('/* vars: %s*/' %self._vars)\n                #out.append('/* used: %s*/' %self._known_vars)\n                #out.append('/* prev vars: %s*/' %prev_vars)\n                #out.append('/* prev used: %s*/' %prev_used)\n                #out.append('/* stack: %s - %s*/' %self._scope_stack[-1])\n                #out.append('/* stack len: %s*/' %len(self._scope_stack))\n                #out.append('/* stack: %s*/' %self._scope_stack)\n\n                G = err[0]\n                if 'target' not in G:\n                    if isinstance(b, ast.Assign):\n                        G['target'] = self.visit(b.targets[0])\n                    else:\n                        raise SyntaxError('no target to generate generic switch')\n\n\n                out.append(self.indent()+'__subclass__ := %s' %G['value'])\n                out.append(self.indent()+'switch __subclass__.__class__ {')\n                self.push()\n\n                subclasses = self.get_subclasses( G['class'] )\n                for sub in subclasses:\n                    out.append(self.indent()+'case \n%s\n:' %sub)\n                    self.push()\n                    #out.append(self.indent()+'%s := __subclass__.(*%s)' %(G['target'], sub)) ## error not an interface\n                    #out.append(self.indent()+'%s := %s(*__subclass__)' %(G['target'], sub))\n                    out.append(self.indent()+'__addr := %s(*__subclass__)' %sub)\n                    out.append(self.indent()+'%s := \n__addr' %G['target'])\n\n                    pv, pu = self._scope_stack[-1]\n                    self.generate_generic_branches( body[:], out, pv, pu )\n\n                    self.pull()\n                self._scope_stack.pop()\n\n                self.pull()\n                out.append(self.indent()+'}')\n                return\n\n\n    def _visit_call_helper_var(self, node):\n        args = [ self.visit(a) for a in node.args ]\n        #if args:\n        #   out.append( 'var ' + ','.join(args) )\n        if node.keywords:\n            for key in node.keywords:\n                args.append( key.arg )\n\n        for name in args:\n            if name not in self._vars:\n                self._vars.add( name )\n\n        #out = []\n        #for v in args:\n        #   out.append( self.indent() + 'var ' + v + ' int')\n\n        #return '\\n'.join(out)\n        return ''\n\n\n\n    def visit_Break(self, node):\n        if len(self._match_stack) and not self._cpp:\n            return ''\n        else:\n            return 'break;'\n\n\n\n\n\nAugmented Assignment \n+=\n\n\n\n    def visit_AugAssign(self, node):\n        ## n++ and n-- are slightly faster than n+=1 and n-=1\n        target = self.visit(node.target)\n        op = self.visit(node.op)\n        value = self.visit(node.value)\n\n        if target in self._known_instances:\n            target = '*'+target\n\n        if isinstance(node.target, ast.Name) and op=='+' and node.target.id in self._known_strings and not self._cpp:\n            return '%s.push_str(%s.as_slice());' %(target, value)\n\n        if self._cpp and op=='+' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s ++;' %target\n        elif self._cpp and op=='-' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s --;' %target\n        else:\n            a = '%s %s= %s;' %(target, op, value)\n        return a\n\n\n\n\n\nAttribute \n.\n\n\nTODO deprecate \n-\n or use for something else.\nAlso swaps \n.\n for c++ namespace \n::\n by checking if the value is a Name and the name is one of the known classes.\n\n\n\n    def visit_Attribute(self, node):\n        parent_node = self._stack[-2]\n        name = self.visit(node.value)\n        fname = None\n        if isinstance(node.value, ast.Call):\n            fname = self.visit(node.value.func)\n\n        attr = node.attr\n        if attr=='__finally__':\n            attr = 'finally'\n        #############################\n        if attr == '__doublecolon__':\n            return '%s::' %name\n        elif attr == '__right_arrow__':\n            return '%s-\n' %name\n        elif attr == '__doubledot__':\n            return 'PyObject_GetAttrString(%s,' %name\n        elif name.endswith('-\n') or name.endswith('::'):\n            return '%s%s' %(name,attr)\n        elif name in ('self','this') and self._cpp and self._class_stack:\n            if attr in self._class_stack[-1]._weak_members:\n                if len(self._stack)\n2:\n                    assert self._stack[-1] is node\n                    if isinstance(self._stack[-2], ast.Assign):\n                        for target in self._stack[-2].targets:\n                            if target is node:\n                                return 'this-\n%s' %attr\n                if self.usertypes and 'weakref' in self.usertypes:\n                    return 'this-\n%s.%s()' %(attr, self.usertypes['weakref']['lock'])\n                else:\n                    return 'this-\n%s.lock()' %attr\n            elif self._memory[-1]=='STACK':\n                #return 'this.%s' %attr  ## will not work\n                #return '%s' %attr  ## compiles but, but has invalid addresses at runtime\n                return '(*this).%s' %attr ## deref each time\n\n            else:\n                return 'this-\n%s' %attr\n\n        elif name in self._rename_hacks and not isinstance(parent_node, ast.Attribute):\n            if self._memory[-1]=='STACK':\n                return '_cast_%s.%s' %(name.replace('-\n', '_'), attr)\n            else:\n                return '_cast_%s-\n%s' %(name.replace('-\n', '_'), attr)\n\n        elif name.startswith('nuitka-\n') and not isinstance(parent_node, ast.Attribute):\n            assert attr in ('module', 'moduledict')\n            raise RuntimeError('TODO')\n\n        elif name.startswith('cpython-\n') and not isinstance(parent_node, ast.Attribute):\n            raise RuntimeError(attr)\n\n        elif self._cpp and (name in self._known_pyobjects) and not isinstance(parent_node, ast.Attribute):\n            return 'PyObject_GetAttrString(%s,\n%s\n)' %(name, attr)\n\n        elif self._cpp and name in self._globals and self._globals[name].endswith('*'):\n            return '%s-\n%s' %(name, attr)\n\n        elif self._cpp and name in self._known_pointers:\n            if name in self._known_arrays and attr=='append':\n                return '%s-\npush_back' %name\n            else:\n                return '%s-\n%s' %(name, attr)\n\n        elif (name in self._known_instances or name in self._known_arrays) and not isinstance(parent_node, ast.Attribute):\n            if self._cpp:\n                ## TODO - attribute lookup stack to make this safe for `a.x.y`\n                ## from the known instance need to check its class type, for any\n                ## subobjects and deference pointers as required. `a-\nx-\ny`\n                ## TODO - the user still needs a syntax to use `-\n` for working with\n                ## external C++ libraries where the variable may or may not be a pointer.\n                ## note: `arr.insert(index,value)` is implemented in visit_call_helper\n                if attr=='append' and name in self._known_arrays:\n                    if self.usertypes and 'vector' in self.usertypes:\n                        return '%s-\n%s' %(name, self.usertypes['vector']['append'])\n                    elif name in self._known_pointers:\n                        return '%s-\npush_back' %name\n                    elif self._memory[-1]=='STACK':\n                        return '%s.push_back' %name\n                    else:\n                        return '%s-\npush_back' %name\n                elif attr=='pop' and name in self._known_arrays:\n                    ## pop_back in c++ returns void, so this only works when `arr.pop()` is not used,\n                    ## in the case where the return is assigned `a=arr.pop()`, the workaround is done in visit_Assign, TODO `f(arr.pop())`\n                    if self.usertypes and 'vector' in self.usertypes:\n                        return '%s-\n%s' %(name, self.usertypes['vector']['pop'])\n                    else:\n                        return '%s-\npop_back' %name\n\n                elif self._memory[-1]=='STACK':  ## TODO self._instances_on_stack\n                    return '%s.%s' % (name, attr)\n                else:\n                    return '%s-\n%s' % (name, attr)\n                    #return 'pointer(%s)-\n%s' % (name, attr)\n\n            else:  ## rust\n                ## note: this conflicts with the new Rust unstable API,\n                ## where the `append` method acts like Pythons `extend` (but moves the contents)\n                ## depending on how the Rust API develops, this may have to be deprecated,\n                ## or a user option to control if known arrays that call `append` should be\n                ## translated into `push`.\n                ## note: as a workaround known arrays could have special method `merge`,\n                ## that would be translated into `append`, while this would be more python,\n                ## it breaks human readablity of the translation, and makes debugging harder,\n                ## because the user has to be aware of this special case.\n                if attr=='append' and name in self._known_arrays:\n                    attr = 'push'\n\n                return '%s.borrow_mut().%s' % (name, attr)\n\n        elif (name in self._known_strings) and not isinstance(parent_node, ast.Attribute):\n            ## allows direct use of c++ std::string properties and methods like: at, erase, replace, swap, pop_back, etc..\n            return '%s.%s' %(name,attr)\n        elif isinstance(node.value, ast.Str):\n            return '%s.%s' %(name,attr)\n        elif self._cpp:\n            if name in self._classes and not isinstance(parent_node, ast.Attribute):\n                return '%s::%s' % (name, attr)\n            elif name.endswith(',') and name.startswith('PyObject_GetAttrString('):\n                return '%s\n%s\n)' %(name, attr)\n            else:\n                if name in 'jvm nim cpython nuitka weak'.split():\n                    return '%s-\n%s' % (name, attr)\n                elif name in self._known_refs or self._memory[-1]=='STACK':\n                    return '%s.%s' % (name, attr)\n                elif name in self._known_instances:  ## user can use std::move to capture these in lambdas for STACK memory mode.\n                    return '%s-\n%s' % (name, attr)\n                elif fname in self._global_functions and fname not in self._known_vars:\n                    return '%s.%s' % (name, attr)\n                #elif self._shared_pointers:\n                #   return '__shared__(%s)-\n%s' % (name, attr)\n                #else:\n                #   return '__pointer__(%s)-\n%s' % (name, attr)\n                else:\n                    return '%s-\n%s' % (name, attr)\n\n        else:\n            return '%s.%s' % (name, attr)\n\n\n\n\nList Comp\n\n\n\n    def _listcomp_helper(self, node, target=None, type=None, size=None, dimensions=1):\n        if not target: target = node._comp_type\n        assert target\n        assert type\n        isprim = self.is_prim_type(type)\n        slice_hack = False\n        self._known_arrays[target] = type\n\n        gen = node.generators[0]\n        try:\n            a = self.visit(node.elt)\n        except GenerateSlice as error:  ## special c++ case for slice syntax\n            assert self._cpp\n            msg = error[0]\n            a = '_slice_'\n            slice_hack = self._gen_slice(\n                a,\n                value=msg['value'],\n                lower=msg['lower'],\n                upper=msg['upper'],\n                step =msg['step'],\n            )\n\n\n\n        b = self.visit(gen.target)\n        c = self.visit(gen.iter)\n        range_n = []\n        if isinstance(gen.iter, ast.Call) and isinstance(gen.iter.func, ast.Name):\n            if gen.iter.func.id == 'range':\n                if len(gen.iter.args) == 1:\n                    range_n.append( self.visit(gen.iter.args[0]) )\n                elif len(gen.iter.args) == 2:\n                    range_n.append( self.visit(gen.iter.args[0]) )\n                    range_n.append( self.visit(gen.iter.args[1]) )\n                elif len(gen.iter.args) == 3:\n                    range_n.append( self.visit(gen.iter.args[0]) )\n                    range_n.append( self.visit(gen.iter.args[1]) )\n                    range_n.append( self.visit(gen.iter.args[2]) )\n\n        out = []\n        compname = target\n        if self._memory[-1]=='HEAP':\n            compname = '_comp_%s' %target\n\n        if self._rust:\n            if range_n:\n                if len(range_n)==1:\n                    #c = 'range(0u,%su)' %range_n[0]\n                    c = '0u32..%su32' %range_n[0]\n                elif len(range_n)==2:\n                    #c = 'range(%su,%su)' %( range_n[0], range_n[1] )\n                    c = '%su32..%su32' %( range_n[0], range_n[1] )\n                else:\n                    raise SyntaxError('TODO list comp range(low,high,step)')\n\n            mutref = False\n            if isprim:\n                out.append('let mut %s : Vec\n%s\n = Vec::new();' %(compname,type))\n            else:\n                mutref = True\n                #out.append('let mut %s : Vec\nmut %s\n = Vec::new();' %(compname,type))  ## ref style\n                out.append('let mut %s : Vec\n Rc\nRefCell\n%s\n \n = Vec::new();' %(compname,type))\n\n            if range_n:\n                ## in rust the range builtin returns ...\n                out.append('for %s in %s {' %(b, c))\n                out.append('    %s.push(%s as %s);' %(compname, a, type))\n            else:\n                out.append('for \n%s in %s.iter() {' %(b, c))\n                if mutref:\n                    #out.append('   %s.push(\nmut %s);' %(compname, a))\n                    out.append('    %s.push(%s);' %(compname, a))\n                else:\n                    out.append('    %s.push(%s);' %(compname, a))\n\n            out.append('}')\n\n            #out.append('let mut %s = \n%s;' %(target, compname))\n            if mutref:\n                out.append('let %s : Rc\nRefCell\n Vec\nRc\nRefCell\n%s\n \n = Rc::new(RefCell::new(%s));' %(target, type, compname))\n            else:\n                out.append('let %s : Rc\nRefCell\n Vec\n%s\n \n = Rc::new(RefCell::new(%s));' %(target, type, compname))\n\n            self._known_arrays[target] = type\n            #out.append('drop(%s);' %compname)  ## release from scope, not required because the Rc/RefCell moves it.\n\n\n        elif self._cpp:\n            vectype    = None\n            subvectype = None\n            if isprim:\n                subvectype = 'std::vector\n%s\n' %type\n                #out.append('std::vector\n%s\n %s;' %(type,compname))\n            else:\n                if self._memory[-1]=='STACK':\n                    subvectype = 'std::vector\n%s\n' %type\n                elif not self._shared_pointers:\n                    subvectype = 'std::vector\n%s*\n' %type\n                elif self._unique_ptr:\n                    subvectype = 'std::vector\nstd::unique_ptr\n%s\n' %type\n                else:\n                    subvectype = 'std::vector\nstd::shared_ptr\n%s\n' %type\n\n            if dimensions == 1:\n                vectype = subvectype\n            elif dimensions == 2:\n                if self._memory[-1]=='STACK':\n                    vectype = 'std::vector\n%s\n' %subvectype\n                elif not self._shared_pointers:\n                    vectype = 'std::vector\n%s*\n' %subvectype\n                elif self._unique_ptr:\n                    vectype = 'std::vector\nstd::unique_ptr\n %s \n' %subvectype\n                else:\n                    vectype = 'std::vector\nstd::shared_ptr\n %s \n' %subvectype\n            else:\n                raise SyntaxError('TODO other dimensions')\n\n            out.append('%s %s; /*comprehension*/' %(vectype,compname))\n\n\n            if range_n:\n                if len(range_n)==1:\n                    out.append(self.indent()+'for (int %s=0; %s\n%s; %s++) {' %(b, b, range_n[0], b))\n\n                elif len(range_n)==2:\n                    out.append(self.indent()+'for (int %s=%s; %s\n%s; %s++) {' %(b, range_n[0], b, range_n[1], b))\n\n            else:\n                out.append(self.indent()+'for (auto \n%s: %s) {' %(b, c))\n\n            if slice_hack:\n                out.append( slice_hack )\n\n            if isprim:\n                out.append(self.indent()+'  %s.push_back(%s);' %(compname, a))\n            else:\n                assert type in self._classes\n                if False:\n                    tmp = '_tmp_'\n                    constructor_args = a.strip()[ len(type)+1 :-1] ## strip to just args\n                    r = '%s  _ref_%s = %s{};' %(type, tmp, type)\n                    if constructor_args:\n                        r += '_ref_%s.__init__(%s);\\n' %(tmp, constructor_args)\n\n                    if not self._shared_pointers:\n                        r += '%s* %s = \n_ref_%s;' %(type, tmp, tmp)\n                    elif self._unique_ptr:\n                        r += 'std::unique_ptr\n%s\n %s = std::make_unique\n%s\n(_ref_%s);' %(type, tmp, type, tmp)\n                    else:\n                        r += 'std::shared_ptr\n%s\n %s = std::make_shared\n%s\n(_ref_%s);' %(type, tmp, type, tmp)\n                    out.append( r )\n                    out.append('    %s.push_back(%s);' %(compname, tmp))\n\n                out.append(self.indent()+'  %s.push_back(%s);' %(compname, a))\n\n\n            out.append(self.indent()+'}')  ## end comp for loop\n\n\n            ## TODO vector.resize if size is given\n            if self._memory[-1]=='STACK':\n                #out.append(self.indent()+'auto %s = %s;' %(target, compname))\n                pass\n            elif not self._shared_pointers:\n                out.append(self.indent()+'auto %s = \n%s;' %(target, compname))\n            elif self._unique_ptr:\n                out.append(self.indent()+'auto %s = std::make_unique\n%s\n(%s);' %(target, vectype, compname))\n            else:\n                out.append(self.indent()+'auto %s = std::make_shared\n%s\n(%s);' %(target, vectype, compname))\n\n        else:\n            raise RuntimeError('TODO list comp for some backend')\n\n        return '\\n'.join(out)\n\n\n\n\n\nAssignment\n\n\nimplemented for rust and c++\n\n\nAssignment to some variable, tracks assignments to local variables for arrays, objects, and strings,\nbecause they need some special handling in other places.\n\n\n\n\n    def visit_Assign(self, node):\n        self._catch_assignment = False\n        self._assign_node = node\n        self._assign_pre  = []\n        res = self._visit_assign(node)\n        self._assign_node = None\n        if self._assign_pre:\n            self._assign_pre.append(res)\n            res = '\\n'.join(self._assign_pre) \n            self._assign_pre  = []\n        return res\n\n    def _visit_assign(self, node):\n        result = []  ## for arrays of arrays with list comps\n        value  = None\n        comptarget = None  ## if there was a comp, then use result and comptarget\n\n        if isinstance(node.targets[0], ast.Name) and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='range':\n            self._known_arrays[node.targets[0].id] = 'int'\n            #if len(node.value.args)==1:\n            #   alen = self.visit(node.value.args[0])\n            #   self._known_arrays[node.targets[0].id] = ('int', alen)\n            #   if not len(self._function_stack):\n            #       self._global_arrays[node.targets[0].id] = ('int', alen)\n            if not len(self._function_stack):\n                self._global_arrays[node.targets[0].id] = 'int'\n                if self._memory[-1]=='STACK':\n                    ## note: __range#__ returns a copy of std::vector\nT\n\n                    ## TODO `range(start,stop,step, fixed=True/False)\n                    self._global_refs[node.targets[0].id] = 'std::vector\nint\n'\n\n        #######################\n        if isinstance(node.targets[0], ast.Tuple):\n            if len(node.targets) \n 1: raise NotImplementedError('TODO')\n            elts = [self.visit(e) for e in node.targets[0].elts]\n            target = '(%s)' % ','.join(elts)  ## this works in rust, not c++\n            assert not self._cpp\n        elif isinstance(node.targets[0], ast.Name) and node.targets[0].id in self._known_arrays and isinstance(self._known_arrays[node.targets[0].id], tuple):\n            target = self.visit(node.targets[0])\n            value = None\n            if isinstance(node.value, ast.Subscript):\n                if isinstance(node.value.slice, ast.Slice):\n                    if not node.value.slice.lower and not node.value.slice.upper and not node.value.slice.step:\n                        value = self.visit(node.value.value)\n                    else:\n                        raise SyntaxError(self.format_error('invalid slice assignment to a fixed size array'))\n                else:\n                    raise SyntaxError(self.format_error('invalid assignment to a fixed size array'))\n\n            if value is None:\n                value = self.visit(node.value)\n\n            atype, fixed_size = self._known_arrays[target]\n\n            if '(' in value and ')' in value:  ## do not unroll from a function call\n                if not self._function_stack:  ## global\n                    self._globals[ target ] = (atype, fixed_size)\n                    return 'auto %s = %s; /*global fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n\n                elif target in self._vars:\n                    ## first assignment of a known variable, this requires 'auto' in c++11\n                    self._vars.remove( target )\n                    self._known_vars.add( target )\n                    return 'auto %s = %s; /*assignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n                else:\n                    return '%s = %s; /*reassignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n\n            elif fixed_size.isdigit() and int(fixed_size)\n512:  ## or in self._macro_constants: TODO\n                fixed_size = int(fixed_size)\n                r = []\n                for i in range(fixed_size):\n                    r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                return ' '.join(r)\n            else:\n                r = [\n                    'for (int __i=0; __i\n%s; __i++) {' %fixed_size,\n                    self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                    self.indent()+'}',\n                ]\n                return '\\n'.join(r)\n\n        elif isinstance(node.targets[0], ast.Subscript) and isinstance(node.targets[0].slice, ast.Slice):\n            ## slice assignment, the place sliced away is replaced with the assignment value, this happens inplace.\n            ## `arr1[ :n ]=arr2` slices away all items before n, and inserts arr2 in its place.\n            ## if `n` is greater than the length of the array, then the array is cleared first.\n            target = self.visit(node.targets[0].value)\n            slice = node.targets[0].slice\n            value = self.visit(node.value)\n            if not slice.lower and not slice.upper and not slice.step:  ## slice copy: `myarr[:]=other` ##\n                if self._memory[-1]=='STACK':\n                    if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                        atype, fixed_size = self._known_arrays[target]\n                        ## unroll loop if possible ##\n                        if fixed_size.isdigit() and int(fixed_size)\n512:  ## or in self._macro_constants: TODO\n                            fixed_size = int(fixed_size)\n                            r = []\n                            for i in range(fixed_size):\n                                r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                            return '\\n'.join(r)\n                        else:\n                            r = [\n                                'for (int __i=0; __i\n%s; __i++) {' %fixed_size,\n                                self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                                self.indent()+'}',\n                            ]\n                            return '\\n'.join(r)\n\n                    elif value in self._known_arrays and isinstance(self._known_arrays[value], tuple):\n                        atype, fixed_size = self._known_arrays[value]\n                        ## unroll loop if possible ##\n                        if fixed_size.isdigit() and int(fixed_size)\n512:  ## or in self._macro_constants: TODO\n                            fixed_size = int(fixed_size)\n                            r = []\n                            for i in range(fixed_size):\n                                r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                            return '\\n'.join(r)\n                        else:\n                            r = [\n                                'for (int __i=0; __i\n%s; __i++) {' %fixed_size,\n                                self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                                self.indent()+'}',\n                            ]\n                            return '\\n'.join(r)\n                    else:\n                        raise RuntimeError( self.format_error('can not determine the fixed array size from either the target or source: %s=%s'%(target,value) ))\n                else:\n                    raise RuntimeError('TODO array slice assign `arr[:]=other`')\n\n            elif not slice.lower and slice.upper:\n                s = self.visit(slice.upper)\n                if self._memory[-1]=='STACK':\n                    if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                        atype, fixed_size = self._known_arrays[target]\n                        ## TODO assert fixed_size \n slice.upper\n\n                    r = [\n                        'for (int __i=0; __i\n%s; __i++) {' %self.visit(slice.upper),\n                        self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                        self.indent()+'}',\n                    ]\n                    return '\\n'.join(r)\n\n                    #if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                    #   atype, fixed_size = self._known_arrays[target]\n                    #   r = [\n                    #       'for (int __i=0; __i\n%s; __i++) {' %self.visit(slice.upper),\n                    #       self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                    #       self.indent()+'}',\n                    #   ]\n                    #   return '\\n'.join(r)\n                    #else:\n                    #   r = [\n                    #       'if (%s \n= %s.size()) { %s.erase(%s.begin(), %s.end());' %(s,target, target,target,target),\n                    #       '} else { %s.erase(%s.begin(), %s.begin()+%s); }' %(target,target,target, self.visit(slice.upper)),\n                    #       '%s.insert(%s.begin(), %s.begin(), %s.end());' %(target, target, value,value)\n                    #   ]\n                    #return '\\n'.join(r)\n                else:\n                    r = [\n                        'if (%s \n= %s-\nsize()) { %s-\nerase(%s-\nbegin(), %s-\nend());' %(s,target, target,target,target),\n                        '} else { %s-\nerase(%s-\nbegin(), %s-\nbegin()+%s); }' %(target,target,target, self.visit(slice.upper)),\n                        '%s-\ninsert(%s-\nbegin(), %s-\nbegin(), %s-\nend());' %(target, target, value,value)\n                    ]\n                    return '\\n'.join(r)\n            elif slice.lower and not slice.upper:\n                if self._memory[-1]=='STACK':\n                    if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                        fixed_size = self._known_arrays[target][1]\n                        r = [\n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s; __i\n%s; __i++) {' %(self.visit(slice.lower), fixed_size),\n                            self.indent()+'  %s[__i] = %s[__L];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ]\n                        return '\\n'.join(r)\n                    else:\n                        r = [\n                            '%s.erase(%s.begin()+%s, %s.end());' %(target,target,self.visit(slice.lower), target),\n                            '%s.insert(%s.end(), %s.begin(), %s.end());' %(target, target, value,value)\n                        ]\n                        return '\\n'.join(r)\n                else:\n                    r = [\n                        '%s-\nerase(%s-\nbegin()+%s, %s-\nend());' %(target,target,self.visit(slice.lower), target),\n                        '%s-\ninsert(%s-\nend(), %s-\nbegin(), %s-\nend());' %(target, target, value,value)\n                    ]\n                    return '\\n'.join(r)\n\n            else:\n                raise RuntimeError('TODO slice assignment lower and upper limits')\n\n        else:\n            target = self.visit( node.targets[0] )\n            self._assign_var_name = target\n            if target.startswith('std::get\n'):\n                ## note: there is no `std::set` because tuples can not change once constructed.\n                #return 'std::set' + target[ len('std::set') : -1 ] + ',' + self.visit(node.value) + ');'\n                raise SyntaxError(self.format_error('tuple items can not be reassigned'))\n        #######################\n\n        if self._cpp and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute) and node.value.func.attr in ('pop', 'insert'):\n            arrname = self.visit(node.value.func.value)\n            if arrname in self._known_arrays:\n                if node.value.func.attr=='insert':\n                    raise RuntimeError('invalid assignment, array.insert returns nothing.')\n\n                elif node.value.func.attr=='pop':\n                    popindex = None\n                    if node.value.args: popindex = self.visit(node.value.args[0])\n                    ######################\n                    if popindex == '0':\n                        if self._memory[-1]=='STACK':\n                            result.append('auto %s = %s[0];' %(target, arrname))\n                            result.append('%s.erase(%s.begin(),%s.begin()+1);' %(arrname,arrname,arrname))\n                        else:\n                            result.append('auto %s = (*%s)[0];' %(target, arrname))\n                            result.append('%s-\nerase(%s-\nbegin(),%s-\nbegin()+1);' %(arrname,arrname,arrname))\n                    elif popindex==None or popindex == '-1':\n                        if self._memory[-1]=='STACK':\n                            result.append('auto %s = %s[ %s.size()-1 ];' %(target, arrname, arrname))\n                            result.append('%s.pop_back();' %arrname)\n                        else:\n                            result.append('auto %s = (*%s)[ %s-\nsize()-1 ];' %(target, arrname, arrname))\n                            result.append('%s-\npop_back();' %arrname)\n                    else:\n                        raise SyntaxError('TODO array.pop(n)', popindex)\n\n                return '\\n'.join(result)\n\n            else:\n                ## do nothing because we are not sure if this is an array\n                pass\n\n\n        #######################\n        if isinstance(node.value, ast.BinOp) and self.visit(node.value.op)=='\n' and isinstance(node.value.left, ast.Name) and node.value.left.id=='__go__send__':\n            value = self.visit(node.value.right)\n            self._has_channels = True\n            if self._cpp:\n                ## cpp-channel API\n                return '%s.send(%s);' % (target, value)\n            elif self._rust:\n                return '%s.send(%s).unwrap();' % (target, value)  ## Rust1.2 API, must call unwrap after send.\n            else: ## Go\n                return '%s \n- %s;' % (target, value)\n\n        elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='__go__':\n            thread = target\n            spawn_func = self.visit(node.value.args[0])\n            if isinstance(node.value.args[0], ast.Name):\n                spawn_func += '()'\n\n            #closure_wrapper = '[\n]{%s;}'%spawn_func  ## do not capture loop variants\n            closure_wrapper = '[=]{%s;}'%spawn_func\n\n            if self._memory[-1]=='STACK':\n                return 'std::thread %s( %s );' %(thread, closure_wrapper)\n            else:\n                return 'auto %s = std::shared_ptr\nstd::thread\n( new std::thread(%s) );' %(thread, closure_wrapper)\n\n        elif not self._function_stack:  ## global level\n            value = self.visit(node.value)\n            if isinstance(value, tuple):\n                assert self._cpp\n                if len(value)==2:\n                    if self._memory[-1]=='STACK':\n                        return '%s %s%s;' %(value[0], target, value[1] )\n                    else:\n                        return 'auto %s = std::make_shared\n%s\n(%s);' %(target, value[0], ','.join(value[1]) )\n                elif len(value)==3:\n                    arrtype, arrsize, arrcon = value\n                    return 'auto %s = std::make_shared\n%s\n(%s);' %(target, arrtype, arrsize)\n\n                else:\n                    raise RuntimeError(value)\n\n\n\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id in self._classes:\n                if self._rust:\n                    value = '__new__' + value\n                    return 'let %s *%s = %s;' % (target, node.value.func.id, value)  ## rust, TODO can c++ construct globals on the heap outside of function?\n                else:\n                    return 'auto %s = %s;' %(target, value)\n            else:\n                guesstype = 'auto'\n                if isinstance(node.value, ast.Num):\n                    guesstype = 'int'\n                elif isinstance(node.value, ast.Str):\n                    guesstype = 'string'\n                elif self._rust:\n                    if isinstance(node.value, ast.Name) and node.value.id=='None':\n                        raise SyntaxError( self.format_error('untyped global set to None'))\n                    else:\n                        raise SyntaxError( self.format_error('untyped global'))\n\n                ## save info about globals ##\n                if isinstance(node.targets[0], ast.Name):\n                    self._globals[ node.targets[0].id ] = guesstype\n                if guesstype not in self._global_types:\n                    self._global_types[guesstype] = set()\n                self._global_types[guesstype].add( target )\n\n                ## we need a syntax for static/const ##\n                isprim = self.is_prim_type(guesstype)\n                if self._cpp:\n                    if guesstype=='string':\n                        #return 'const std::string %s = %s;' % (target, value)\n                        return 'std::string %s = %s;' % (target, value)\n                    elif isprim or guesstype=='auto':\n                        return '%s %s = %s;' % (guesstype, target, value)\n                    else:\n                        if not self._shared_pointers:\n                            return '%s* %s = %s;' % (guesstype, target, value)\n                        elif self._unique_ptr:\n                            return 'std::unique_ptr\n%s\n %s = %s;' % (guesstype, target, value)\n                        else:\n                            return 'std::shared_ptr\n%s\n %s = %s;' % (guesstype, target, value)\n\n                else:\n                    return 'static %s : %s = %s;' % (target, guesstype, value)\n\n        elif isinstance(node.targets[0], ast.Name) and node.targets[0].id in self._vars:\n            ## first assignment of a known variable, this requires 'auto' in c++, or `let` in rust.\n            ## note that the first pass of translation picks up all local variables traversing into\n            ## all nested structures and loops (not block scoped)\n            self._vars.remove( target )\n            self._known_vars.add( target )\n            node._new_assignment = target\n\n            #if len(self._stack)\n=2 and isinstance(self._stack[-2], ast.For):\n            #   raise RuntimeError(self._stack)\n\n            if isinstance(node.value, ast.Str):  ## catch strings for `+=` hack\n                self._known_strings.add( target )\n\n            try:\n                value = self.visit(node.value)\n\n            except GenerateListComp as error:  ## new style to generate list comprehensions\n                compnode = error[0]\n\n                if not isinstance(node.value, ast.BinOp):\n                    ## try to guess type of list comprehension ##\n                    if isinstance(compnode.elt, ast.Call) and isinstance(compnode.elt.func, ast.Name) and compnode.elt.func.id in self._classes:\n                        return self._listcomp_helper(\n                            compnode,\n                            target=target,\n                            type=compnode.elt.func.id\n                        )\n\n                    raise SyntaxError( self.format_error('untyped list comprehension') )\n\n                comptarget = None\n                comptype = None\n                arrtype  = None\n\n                if isinstance(node.value.left, ast.Call):\n                    assert node.value.left.func.id in ('__go__array__', '__go__arrayfixed__')\n                    comptype = node.value.left.func.id\n                    if comptype == '__go__array__':\n                        comptarget = target\n                        comptype = node.value.left.func.id\n                        arrtype  = self.visit(node.value.left.args[0])\n\n                        return self._listcomp_helper(\n                            compnode,\n                            target=comptarget,\n                            type=arrtype\n                        )\n                    else:\n\n                        return self._listcomp_helper(\n                            compnode,\n                            target=target,\n                            type=self.visit(node.value.left.args[1]),\n                            size=self.visit(node.value.left.args[0]),\n                        )\n\n                elif isinstance(node.value.left, ast.BinOp):\n                    ## This happens when the constructor contains a list of items,\n                    ## and one of the items is an list comp, `result` gets shoved\n                    ## into one of the slots in the constuctor.\n                    ## This can also happens when a 1/2D array contains just a single\n                    ## list comp, `arr = [][]int((1,2,3) for i in range(4))`,\n                    ## creates a 4x3 2D array, in this case the list comp needs\n                    ## to be regenerated as 2D below.\n                    comptype = node.value.left.left.id=='__go__array__'\n                    if (node.value.left.left, ast.Name) and node.value.left.left.id=='__go__array__':\n                        arrtype = node.value.left.right.args[0].id\n                        comptarget = '_subcomp_'+target\n                        result.append(\n                            self._listcomp_helper(\n                                compnode,\n                                target=comptarget,\n                                type=arrtype\n                            )\n                        )\n\n                    else:\n                        raise RuntimeError('TODO mdarray subtype')\n                else:\n                    raise RuntimeError(node.value.left)\n\n\n            except GenerateSlice as error:  ## special c++ case for slice syntax\n                assert self._cpp\n                msg = error[0]\n                slice_type = None  ## slice on an unknown type is broken and will segfault - TODO fix this\n                result_size = None\n                if msg['value'] in self._known_arrays:\n                    slice_type = self._known_arrays[msg['value']]\n\n                    ## stack allocated array ##\n                    if isinstance(self._known_arrays[msg['value']], tuple):\n                        new_type   = list(slice_type)\n                        if msg['lower'] and not msg['upper']:\n                            if new_type[1].isdigit() and msg['lower'].isdigit():\n                                result_size = int(new_type[1]) - int(msg['lower'])\n                                new_type[1] = str(result_size)\n                            else:\n                                new_type[1] += '-%s' %msg['lower']\n                        elif not msg['lower'] and msg['upper']:\n                            if new_type[1].isdigit() and msg['upper'].isdigit():\n                                result_size = int(new_type[1]) - int(msg['upper'])\n                                new_type[1] = str(result_size-1)\n                            else:\n                                new_type[1] += '-%s' %msg['upper']\n                        elif not msg['lower'] and not msg['upper']:\n                            ## slice copy, same size\n                            if slice_type[1].isdigit():\n                                result_size = int(slice_type[1])\n                            else:\n                                result_size = slice_type[1]\n\n                        else:\n                            new_type[1]= None\n                        self._known_arrays[target] = tuple(new_type)\n\n                    else:\n                        self._known_arrays[target] = slice_type\n\n                return self._gen_slice(\n                    target,\n                    value=msg['value'],\n                    lower=msg['lower'],\n                    upper=msg['upper'],\n                    step =msg['step'],\n                    type=slice_type,\n                    result_size = result_size\n                )\n\n\n            if isinstance(node.value, ast.Num):\n                if type(node.value.n) is int:\n                    if self._cpp:\n                        pass\n                    else:\n                        value += 'i64'\n\n            if value=='None':\n                if self._cpp:\n                    raise RuntimeError('invalid in c++ mode')  ## is this possible in c++14?\n                else:  ## TODO, this is a bad idea?  letting rust infer the type should have its own syntax like `let x;`\n                    return 'let mut %s;  /* let rust infer type */' %target\n\n\n\n            if not self._cpp and isinstance(node.value, ast.BinOp) and self.visit(node.value.op)=='\n' and isinstance(node.value.left, ast.Call) and isinstance(node.value.left.func, ast.Name) and node.value.left.func.id=='__go__map__':\n                key_type = self.visit(node.value.left.args[0])\n                value_type = self.visit(node.value.left.args[1])\n\n                if isinstance(node.value.left.args[0], ast.Str):\n                    raise RuntimeError(node.value.left.args[0])\n\n                if isinstance(node.value.left.args[1], ast.Str):\n                    raise RuntimeError(node.value.left.args[1])\n\n                if key_type=='string': key_type = 'String'\n                if value_type=='string': value_type = 'String'\n                self._known_maps[ target ] = (key_type, value_type)\n\n                a = []\n                for i in range( len(node.value.right.keys) ):\n                    k = self.visit( node.value.right.keys[ i ] )\n                    v = self.visit( node.value.right.values[i] )\n                    a.append( '_ref_%s.insert(%s,%s);'%(target,k,v) )\n                v = '\\n'.join( a )\n                r  = 'let mut _ref_%s = HashMap::\n%s, %s\n::new();\\n%s\\n' %(target, key_type, value_type, v)\n                r += 'let mut %s = \n_ref_%s;' %(target, target)\n                return r\n\n            elif self._cpp and isinstance(node.value, ast.BinOp) and self.visit(node.value.op)=='\n':\n\n                if isinstance(node.value.left, ast.BinOp) and isinstance(node.value.op, ast.LShift):  ## 2D Array\n                    ## c++ vector of vectors ##\n                    ## std::shared_ptr\n std::vector\nstd::shared_ptr\nstd::vector\nT\n \n\n\n                    if isinstance(node.value.left.left, ast.Name) and node.value.left.left.id=='__go__array__':\n\n                        T = self.visit(node.value.left.right.args[0])\n                        if T=='string': T = 'std::string'\n                        self._known_arrays[ target ] = T\n                        if not self.is_prim_type(T):\n                            T = 'std::shared_ptr\n%s\n' %T\n\n                        subvectype = 'std::vector\n%s\n' %T\n                        if self._memory[-1]=='STACK':\n                            vectype = 'std::vector\n%s\n' %subvectype\n                        elif not self._shared_pointers:\n                            vectype = 'std::vector\n%s*\n' %subvectype\n                        elif self._unique_ptr:\n                            vectype = 'std::vector\nstd::unique_ptr\n%s\n' %subvectype\n                        else:\n                            vectype = 'std::vector\nstd::shared_ptr\n%s\n' %subvectype\n\n\n                        if isinstance(node.value.right, ast.Tuple):\n                            r = ['/* %s = vector of vectors to: %s */' %(target,T)]\n                            args = []\n                            for i,elt in enumerate(node.value.right.elts):\n                                if isinstance(elt, ast.Tuple):\n                                    subname = '_sub%s_%s' %(i, target)\n                                    args.append( subname )\n                                    sharedptr = False\n                                    for sarg in elt.elts:\n                                        if isinstance(sarg, ast.Name) and sarg.id in self._known_instances:\n                                            sharedptr = True\n                                            if self._memory[-1]=='STACK':\n                                                subvectype = 'std::vector\n%s\n' %T\n                                                vectype = 'std::vector\n%s\n' %subvectype\n\n                                            elif not self._shared_pointers:\n                                                subvectype = 'std::vector\n%s*\n' %T\n                                                vectype = 'std::vector\n%s*\n' %subvectype\n                                            elif self._unique_ptr:\n                                                subvectype = 'std::vector\n  std::unique_ptr\n%s\n  \n' %T\n                                                vectype = 'std::vector\n std::unique_ptr\n%s\n \n' %subvectype\n                                            else:\n                                                subvectype = 'std::vector\n  std::shared_ptr\n%s\n  \n' %T\n                                                vectype = 'std::vector\n std::shared_ptr\n%s\n \n' %subvectype\n\n\n                                    subargs = [self.visit(sarg) for sarg in elt.elts]\n                                    if self._memory[-1]=='STACK':\n                                        r.append('%s %s = {%s};' %(subvectype, subname, ','.join(subargs)))  ## direct ref\n                                    else:\n                                        r.append(self.indent()+'%s _r_%s = {%s};' %(subvectype, subname, ','.join(subargs)))\n\n                                        if not self._shared_pointers:\n                                            r.append(\n                                                self.indent()+'%s* %s = \n_r_%s;' %(subvectype, subname, subname)\n                                            )\n\n                                        elif self._unique_ptr:\n                                            r.append(\n                                                self.indent()+'std::unique_ptr\n%s\n %s = _make_unique\n%s\n(_r_%s);' %(subvectype, subname, subvectype, subname)\n                                            )\n\n                                        else:\n                                            r.append(\n                                                self.indent()+'std::shared_ptr\n%s\n %s = std::make_shared\n%s\n(_r_%s);' %(subvectype, subname, subvectype, subname)\n                                            )\n\n                                elif isinstance(elt, ast.ListComp):\n                                    r.extend(result)\n                                    args.append('_subcomp_%s'%target)  ## already a shared_ptr\n\n                                else:\n                                    args.append( self.visit(elt) )\n\n                            if self._memory[-1]=='STACK':\n                                r.append(self.indent()+'%s %s = {%s};' %(vectype, target, ','.join(args)))\n\n                            else:\n                                #r.append(self.indent()+'%s _ref_%s = {%s};' %(vectype, target, ','.join(args)))\n                                heapargs = []\n                                for arg in args:\n                                    if arg.startswith('new std::vector'):\n                                        vtype = arg[ len('new ') : ].split('{')[0]\n                                        arg = 'std::shared_ptr\n%s\n(%s)' %(vtype, arg)\n                                    heapargs.append( self.indent() + '\\t' + arg )\n\n                                if not self._shared_pointers:\n                                    r.append(\n                                        self.indent()+'%s* %s = {%s};' %(vectype, target, ','.join(args))\n                                    )\n\n                                elif self._unique_ptr:  ## TODO test and fixme\n                                    r.append(\n                                        self.indent()+'std::unique_ptr\n%s\n %s = _make_unique\n%s\n(_ref_%s);' %(vectype, target, vectype, target)\n                                    )\n                                else:\n                                    r.append(\n                                        self.indent()+'auto %s = std::make_shared\n%s\n(%s{%s});' %(target, vectype, vectype, ',\\n'.join(heapargs))\n                                    )\n\n                            return (self.indent()+'\\n').join(r)\n\n                        elif isinstance(node.value.right, ast.ListComp):\n                            compnode = node.value.right\n                            return self._listcomp_helper(\n                                compnode,\n                                target=target,\n                                type=T,\n                                dimensions=2\n                            )\n\n                    elif isinstance(node.value.left.right, ast.Name) and node.value.left.right.id=='__as__':\n                        return self.indent()+'auto %s = %s;' %(target, value)\n\n                    else:\n                        raise RuntimeError('TODO other md-array types', node.value)\n\n\n                elif isinstance(node.value.left, ast.Call) and isinstance(node.value.left.func, ast.Name) and node.value.left.func.id in COLLECTION_TYPES:\n                    S = node.value.left.func.id\n                    if S == '__go__map__':\n                        key_type = self.visit(node.value.left.args[0])\n                        value_type = self.visit(node.value.left.args[1])\n                        value_vec  = None\n                        if not self.is_prim_type(value_type):\n                            value_type = 'std::shared_ptr\n%s\n' %value_type\n\n                        if isinstance(node.value.left.args[0], ast.Str):\n                            raise RuntimeError('TODO dict key type from string: %s' %value_type)\n\n                        if isinstance(node.value.left.args[1], ast.Str):\n                            value_type = node.value.left.args[1].s\n                            value_vec  = value_type.split(']')[-1]\n                            if self._memory[-1]=='STACK':\n                                value_type = 'std::vector\n%s\n' %value_vec\n                            else:\n                                value_type = 'std::vector\n%s\n*' %value_vec\n                        elif isinstance(node.value.left.args[1], ast.Tuple):\n                            raise RuntimeError('TODO map and tuple')\n                        elif value_type.startswith('{') and value_type.endswith('}'):\n                            raise RuntimeError(self.format_error('invalid value_type: %s' %value_type))\n                        elif '{' in value_type:\n                            raise RuntimeError('TODO { in value_type')\n\n                        #####################\n                        if key_type=='string':\n                            if self.usertypes and 'string' in self.usertypes:\n                                key_type = self.usertypes['string']['type']\n                            else:\n                                key_type = 'std::string'\n\n\n                        if value_type=='string':\n                            if self.usertypes and 'string' in self.usertypes:\n                                value_type = self.usertypes['string']['type']\n                            else:\n                                value_type = 'std::string'\n\n                        self._known_maps[ target ] = (key_type, value_type)\n\n                        #keyvalues = []\n                        a = []\n                        for i in range( len(node.value.right.keys) ):\n                            k = self.visit( node.value.right.keys[ i ] )\n                            v = self.visit( node.value.right.values[i] )\n                            if v.startswith('[') and v.endswith(']'):\n                                if self._memory[-1]=='STACK':\n                                    v = ('std::vector\n%s\n{'%value_vec) + v[1:-1] + '}'\n                                else:\n                                    v = ('new std::vector\n%s\n{'%value_vec) + v[1:-1] + '}'\n                            a.append( '{%s,%s}'%(k,v) )\n                        #   keyvalues.append( (k,v) )\n                        #v = ', '.join( a )\n                        initlist = '{%s}' %'\\n,'.join(a)\n                        map_type = 'std::map\n%s,%s\n' %(key_type, value_type)\n                        if self._memory[-1]=='STACK':\n                            return 'auto %s = %s%s;' %(target, map_type, initlist)\n\n                        else:\n                            return 'auto %s = std::shared_ptr\n%s\n(new %s%s);' %(target, map_type, map_type, initlist)\n\n\n                        ## DEPRECATED c++11 shared pointer\n                        if self.usertypes and 'map' in self.usertypes:\n                            maptype = self.usertypes['map']['template'] % (key_type, value_type)\n                            st = self.usertypes['shared']['template']\n                            r = ['%s _ref_%s();' %(maptype, target)]\n                            if keyvalues:\n                                for key,val in keyvalues:\n                                    r.append('_ref_%s[%s] = %s;' %(target,key,val))\n                            r.append('%s %s(\n_ref_%s);' %(st%maptype, target, target))\n                            return '\\n'.join(r)\n\n                        elif self._shared_pointers:\n                            maptype = 'std::map\n%s, %s\n' %(key_type, value_type)\n                            r = '%s _ref_%s = {%s};' %(maptype, target, v)\n                            if self._unique_ptr:\n                                r += 'std::unique_ptr\n%s\n %s = _make_unique\n%s\n(_ref_%s);' %(maptype, target, maptype, target)\n                            else:\n                                r += 'std::shared_ptr\n%s\n %s = std::make_shared\n%s\n(_ref_%s);' %(maptype, target, maptype, target)\n                            return r\n                        else:  ## raw pointer\n                            return 'std::map\n%s, %s\n _ref_%s = {%s}; auto %s = \n_ref_%s;' %(key_type, value_type, target, v, target, target)\n\n                    elif 'array' in S:\n                        args = []\n                        for elt in node.value.right.elts:\n                            #if isinstance(elt, ast.Num):\n                            args.append( self.visit(elt) )\n\n                        if S=='__go__array__':\n                            T = self.visit(node.value.left.args[0])\n                            if T in self.macros:\n                                T = self.macros[T]\n                            isprim = self.is_prim_type(T)\n                            if T=='string':\n                                if self.usertypes and 'string' in self.usertypes:\n                                    T = self.usertypes['string']['type']\n                                else:\n                                    T = 'std::string'\n                            self._known_arrays[ target ] = T\n                            if T=='tuple':\n                                tupleargs = []\n                                for elt in node.value.right.elts:\n                                    #raise RuntimeError(elt.func.id)\n                                    tupleargs.append( self.visit(elt) )\n\n                                #for arg in args:\n                                #   if arg.startswith('[]')\n                                #   args.append( self.visit(elt) )\n\n                                #return 'std::shared_ptr\nstd::vector\nstd::tuple\n%s\n %s;' %(','.join(tupleargs), target)\n                                if self._memory[-1]=='STACK':\n                                    tuplevec = 'std::vector\nstd::tuple\n%s\n' %','.join(tupleargs)\n                                    self._known_refs[target] = tuplevec\n                                    return 'auto %s = %s();' %(target, tuplevec)\n                                else:\n                                    tuplevec = 'std::vector\n std::shared_ptr\nstd::tuple\n%s\n \n' %','.join(tupleargs)\n                                    return 'auto %s = std::make_shared\n%s\n(%s());' %(target, tuplevec, tuplevec)\n\n                            if self.usertypes and 'vector' in self.usertypes:\n                                vtemplate = self.usertypes['vector']['template']\n                                stemplate = 'std::shared_ptr\n%s\n'\n                                if 'shared' in self.usertypes:\n                                    stemplate = self.usertypes['shared']['template']\n                                if isprim:\n                                    vectype = vtemplate%T\n                                else:\n                                    vectype = vtemplate % stemplate % T\n                                return '%s %s = {%s};' %(vectype, target, ','.join(args))\n\n                            elif self._shared_pointers:\n                                if isprim or self._memory[-1]=='STACK':\n                                    vectype = 'std::vector\n%s\n' %T\n                                    constuct = '(new std::vector\n%s\n({%s}))' %(T, ','.join(args))\n                                else:\n                                    if self._unique_ptr:\n                                        vectype = 'std::vector\nstd::unique_ptr\n%s\n' %T\n                                    else:\n                                        vectype = 'std::vector\nstd::shared_ptr\n%s\n' %T\n                                        #constuct = '( new std::vector\nstd::shared_ptr\n%s\n(new std::shared_ptr\n%s\n(%s)) )' %(T,T, ','.join(args))\n                                        constuct = '( new std::vector\nstd::shared_ptr\n%s\n({%s}) )' %(T, ','.join(args))\n\n                                ## old style using std::make_shared\n                                #r = '%s _ref_%s = {%s};' %(vectype, target, ','.join(args))\n                                #if self._unique_ptr:\n                                #   r += 'std::unique_ptr\n%s\n %s = _make_unique\n%s\n(_ref_%s); /* 1D Array */' %(vectype, target, vectype, target)\n                                #else:\n                                #   r += 'std::shared_ptr\n%s\n %s = std::make_shared\n%s\n(_ref_%s); /* 1D Array */' %(vectype, target, vectype, target)\n                                #return r\n\n                                ## new style\n                                if self._memory[-1]=='STACK':\n                                    self._known_pointers[target] = vectype\n                                    return '%s* %s = %s; /* 1D Array */' %(vectype, target, constuct )\n                                elif self._unique_ptr:\n                                    r += 'std::unique_ptr\n%s\n %s = _make_unique\n%s\n(_ref_%s); /* 1D Array */' %(vectype, target, vectype, target)\n                                else:\n                                    #return 'std::shared_ptr\n%s\n %s = std::shared_ptr\n%s\n( new %s(%s) ); /* 1D Array */' %(vectype, target,vectype, vectype, ','.join(args) )\n                                    return 'std::shared_ptr\n%s\n %s( %s ); /* 1D Array */' %(vectype, target,constuct )\n\n                            else:  ## raw pointer\n                                if isprim:\n                                    return 'std::vector\n%s\n  _ref_%s = {%s}; auto %s = \n_ref_%s;' %(T, target, ','.join(args), target, target)\n                                else:\n                                    return 'std::vector\n%s*\n  _ref_%s = {%s}; auto %s = \n_ref_%s;' %(T, target, ','.join(args), target, target)\n\n                        elif S=='__go__arrayfixed__':\n                            asize = self.visit(node.value.left.args[0])\n                            atype = self.visit(node.value.left.args[1])\n                            self._known_arrays[ target ] = (atype,asize)\n                            if self._memory[-1]=='STACK':\n                                return '%s %s[%s] = {%s};' %(atype, target, asize, ','.join(args))\n\n                            elif self._shared_pointers:\n                                #vectype = 'std::array\n%s, %sul\n' %(atype, asize)  ## what api or syntax should we use for fixed size arrays?\n                                if self.is_prim_type(atype):\n                                    vectype = 'std::vector\n%s\n' %atype\n                                else:\n                                    vectype = 'std::vector\nstd::shared_ptr\n%s\n' %atype\n\n                                r = '%s _ref_%s = {%s};' %(vectype, target, ','.join(args))\n                                r += '_ref_%s.resize(%s);' %(target, asize)\n                                if self._unique_ptr:\n                                    r += 'std::unique_ptr\n%s\n %s = _make_unique\n%s\n(_ref_%s);' %(vectype, target, vectype, target)\n                                else:\n                                    r += 'std::shared_ptr\n%s\n %s = std::make_shared\n%s\n(_ref_%s);' %(vectype, target, vectype, target)\n                                return r\n                            else:\n                                ## note: the inner braces are due to the nature of initializer lists, one per template param.\n                                #return 'std::array\n%s, %s\n  %s = {{%s}};' %(atype, asize, target, ','.join(args))\n                                ## TODO which is correct? above with double braces, or below with none?\n                                return 'std::array\n%s, %sul\n  _ref_%s  {%s}; auto %s = \n_ref_%s;' %(atype, asize, target, ','.join(args), target, target)\n\n                elif isinstance(node.value.left, ast.Name) and node.value.left.id=='__go__receive__':\n                    if target in self._known_vars:\n                        return 'auto %s = %s;' %(target, self.visit(node.value))  ## TODO check this is this a bug? should not be `auto`\n                    else:\n                        return 'auto %s = %s;' %(target, self.visit(node.value))\n\n                elif isinstance(node.value.left, ast.Attribute) and node.value.left.attr=='__doubledot__':\n                    pyob = self.visit(node.value.left.value)\n                    if isinstance(node.value.right, ast.Name):\n                        attr = node.value.right.id\n                        return 'auto %s = %s;' %(target, self.gen_cpy_get(pyob, attr))\n                    elif isinstance(node.value.right, ast.Call):\n                        return 'auto %s = %s;' %(target, self.gen_cpy_call(pyob, node.value.right))\n                    else:\n                        raise RuntimeError('TODO x=y-\n?')\n\n                else:\n                    #raise SyntaxError(('invalid \n hack', node.value.left.attr))\n                    #raise SyntaxError(('invalid \n hack', self.visit(node.value.right)))\n                    raise SyntaxError(('invalid \n hack', node.value.right))\n\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute) and isinstance(node.value.func.value, ast.Name):\n                varname = node.value.func.value.id\n                info = varname + '  '\n\n                if varname in self._known_vars and varname in self._known_instances and self._go:  ## TODO, c++ backend\n                    ## generics generator ##\n                    #raise SyntaxError(varname + ' is known class::' + self._known_instances[varname] + '%s(%s)' % (fname, args))\n                    cname = self._known_instances[varname]\n                    info += 'class: ' + cname\n                    if node.value.func.attr in self.method_returns_multiple_subclasses[ cname ]:\n                        self._known_instances[target] = cname\n                        raise GenerateGenericSwitch( {'target':target, 'value':value, 'class':cname, 'method':node.value.func.attr} )\n\n                if self._cpp:\n                    #if value.startswith('__cpython_call__'):  ## logic no longer requires _known_pyobjects\n                    #   self._known_pyobjects[ target ] = varname\n                    return 'auto %s = %s;           /* %s */' % (target, value, info)\n                else:\n                    if '.borrow_mut()' in value:\n                        return 'let mut %s = %s;            /* %s */' % (target, value, info)\n                    else:\n                        return 'let %s = %s;            /* %s */' % (target, value, info)\n\n\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n\n                ## creation of a new class instance and assignment to a local variable\n                if node.value.func.id=='new' and isinstance(node.value.args[0],ast.Call) and isinstance(node.value.args[0].func, ast.Name) and not node.value.args[0].func.id.startswith('_'):\n                    classname = node.value.args[0].func.id\n                    value = self.visit(node.value.args[0])\n                    self._known_instances[ target ] = classname\n\n                    if self._cpp:\n                        if classname in self._classes:\n                            if self._memory[-1]=='HEAP':\n                                return 'auto %s = %s; // heap-object' %(target, value)\n                            else:\n                                return 'auto %s = %s; // stack-object' %(target, value)\n                        else:\n                            if self._memory[-1]=='HEAP':\n                                return 'auto %s = new %s; // heap-xobject' %(target, value)\n                            else:\n                                return 'auto %s = %s; // stack-xobject' %(target, value)\n\n                        if self._unique_ptr:\n                            ## TODO fix everywhere, check visit_binop\n                            ## raise RuntimeError(self.visit(node.value))\n                            if 'std::shared_ptr' in value:\n                                value = value.replace('shared_ptr', 'make_unique')  ## c++14\n                                vh,vt = value.split('-\n__init__')\n                                value = vh.split('((')[0] + '()-\n__init__' + vt[:-1]\n\n                        elif self._memory[-1]=='HEAP':\n                            if value.count('-\n__init__(') \n 1:\n                                print 'WARNING: in heap mode with shared pointers,'\n                                print 'objects should be assigned to a variable before'\n                                print 'passing them to the constructor of another object'\n                                print 'target=', target\n                                print 'pre-value=', value\n                                x = value[  : value.index('-\n__init__(') ] + ')'\n                                y = value[ value.index('-\n__init__(') : ][:-1]\n                                value = x+y\n                                print 'post-value=', value\n                            elif '-\n__init__(' in value:\n                                vh,vt = value.split('-\n__init__')\n                                if is_new:\n                                    value = '%s); %s-\n__init__%s' %(vh, target, vt[:-1])\n                                else:\n                                    value = '%s); %s-\n__init__%s' %(vh, target, vt[:-1])\n\n                            return 'auto %s = %s; // heap-object' %(target, value)\n\n                        elif is_new:\n                            return 'auto %s = new %s; // new-object' %(target, value)\n                        else:\n                            return 'auto %s = %s; // stack-object' %(target, value)\n\n                    else:  ## rust\n                        self._construct_rust_structs_directly = False\n\n                        if self._construct_rust_structs_directly:  ## NOT DEFAULT\n                            ## this is option is only useful when nothing is happening\n                            ## in __init__ other than assignment of fields, rust enforces that\n                            ## values for all struct field types are given, and this can not\n                            ## map to __init__ logic where some arguments have defaults.\n\n                            ## convert args into struct constructor style `name:value`\n                            args = []\n                            for i,arg in enumerate(node.value.args):\n                                args.append( '%s:%s' %(self._classes[classname]._struct_init_names[i], self.visit(arg)))\n                            if node.value.keywords:\n                                for kw in node.value.keywords:\n                                    args.append( '%s:%s' %(kw.arg, self.visit(kw.value)))\n\n                            return 'let %s = \nmut %s{ %s };' %(target, classname, ','.join(args))  ## directly construct struct, this requires all arguments are given.\n\n                        else:\n                            ## RUST DEFAULT create new class instance\n                            ## by calling user constructor __init__\n                            ## SomeClass::new(init-args) takes care of making the struct with\n                            ## default null/empty/zeroed values.\n\n                            ## note: methods are always defined with `\nmut self`, this requires that\n                            ## a mutable reference is taken so that methods can be called on the instance.\n\n                            ## old ref style\n                            #value = self._visit_call_helper(node.value, force_name=classname+'::new')\n                            #return 'let %s = \nmut %s;' %(target, value)\n\n                            ## new reference counted mutable style\n                            value = self._visit_call_helper(node.value)\n                            return 'let %s : Rc\nRefCell\n%s\n = %s;' %(target, classname, value)\n                else:\n                    if self._cpp:\n                        if isinstance(node.value, ast.Expr) and isinstance(node.value.value, ast.BinOp) and self.visit(node.value.value.op)=='\n':\n                            raise SyntaxError(node.value.value.left)\n                        elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='new':\n                            V = self.visit(node.value.args[0])\n                            if isinstance(V, tuple):\n                                vType, vInit = V\n                                if isinstance(vInit, list):\n                                    return 'auto %s = new %s({%s});' %(target, vType, ','.join(vInit))\n                                else:\n                                    if vType.endswith('*'):\n                                        vType = vType[:-1]\n                                        return 'auto %s = new %s%s;' %(target, vType, vInit)\n                                    else:\n                                        raise RuntimeError('not a pointer?')\n                                        return '%s %s %s;' %(vType, target, vInit)\n\n                            else:\n                                return 'auto %s = %s;           /* new variable*/' % (target, value)\n                        else:\n                            return 'auto %s = %s;           /* new variable*/' % (target, value)\n                    else:\n                        return 'let %s = %s;            /* new variable */' % (target, value)\n\n            else:\n                if self._cpp:\n                    #raise RuntimeError((node.value.left, node.value.right, node.value.op))\n                    if comptarget:\n                        result.append('auto %s = %s;  /* list comprehension */' % (target, comptarget))\n                        return '\\n'.join(result)\n                    elif isinstance(node.value, ast.BinOp) and isinstance(node.value.op, ast.RShift) and isinstance(node.value.left, ast.Name) and node.value.left.id=='__new__':\n                        self._known_instances[target] = self.visit(node.value.right)\n                        return 'auto %s = %s;  /* new object */' % (target, value)\n                    elif isinstance(node.value, ast.Tuple):\n\n                        tupletype = []\n                        for telt in node.value.elts:\n                            if isinstance(telt, ast.Str):  ## TODO test tuple with strings\n                                v = telt.s\n                                if v.startswith('\n') and v.endswith('\n'):  ## TODO this looks like a bug\n                                    v = v[1:-1]\n                            elif isinstance(telt, ast.List): #v.startswith('[') and v.endswith(']'):\n                                tsubvec = None\n                                for st in telt.elts:\n                                    if isinstance(st, ast.Num):\n                                        tsubvec = 'float64'\n                                        break\n                                assert tsubvec is not None\n                                v = 'std::vector\n%s\n' %tsubvec\n\n\n                            elif isinstance(telt, ast.Num):\n                                v = 'float64'\n                            elif isinstance(telt, ast.Name):\n                                v = 'decltype(%s)' % self.visit(telt)\n                            else:\n                                v = self.visit(telt)\n\n                            if v.startswith('[]'):\n                                t  = v.split(']')[-1]\n                                if self._memory[-1]=='STACK':\n                                    v = 'std::vector\n%s\n' %t\n                                else:\n                                    v = 'std::vector\n%s\n*' %t\n\n                            tupletype.append(v)\n\n\n                        targs = []\n                        for ti,te in enumerate(node.value.elts):\n                            tt = tupletype[ti]\n                            tv = self.visit(te)\n                            if tv.startswith('[') and tv.endswith(']'):\n                                assert tt.startswith('std::vector')\n                                if tt.endswith('*'):\n                                    tv = '(new %s{%s})' %(tt[:-1], tv[1:-1])\n                                else:\n                                    tv = '%s{%s}' %(tt, tv[1:-1])\n                            #elif tv.startswith('std::vector'):  ## never happens?\n                            #   raise RuntimeError(tv)\n\n                            if tt.startswith('std::vector') and self._memory[-1]=='HEAP':\n                                tupletype[ti] = 'std::shared_ptr\n%s\n' %tt\n                                if not tv.startswith('new '):\n                                    raise RuntimeError(self.format_error(tv))\n                                    tv = 'std::shared_ptr\n%s\n(new %s)' %(tt, tv)\n                                else:\n                                    tv = 'std::shared_ptr\n%s\n(%s)' %(tt, tv)\n\n                            targs.append(tv)\n\n                        if self._memory[-1]=='STACK':\n                            self._known_refs[target] = 'tuple\n%s\n' % ','.join(targs)\n                            return 'auto %s = std::make_tuple(%s); /*new-tuple*/' %(target, ','.join(targs))\n                        else:\n                            return 'auto %s = std::make_shared\nstd::tuple\n%s\n(std::make_tuple(%s)); /*new-tuple*/' %(target, ','.join(tupletype), ','.join(targs))\n                    else:\n                        return 'auto %s = %s;  /* auto-fallback %s */' % (target, value, node.value)\n                else:\n                    if value.startswith('Rc::new(RefCell::new('):\n                        #return 'let _RC_%s = %s; let mut %s = _RC_%s.borrow_mut(); /* new array */' % (target, value, target, target)\n                        self._known_arrays[ target ] = 'XXX'  ## TODO get class name\n                        return 'let %s = %s;    /* new array */' % (target, value)\n                    else:\n                        return 'let mut %s = %s;            /* new muatble */' % (target, value)\n\n        else:\n            ## the variable has already be used, and is getting reassigned,\n            ## or its a destructured assignment, or assignment to an attribute, TODO break this apart.\n\n            is_attr = False\n            is_tuple = False\n            if target not in self._known_vars:\n                if isinstance(node.targets[0], ast.Attribute):\n                    is_attr = True\n                elif isinstance(node.targets[0], ast.Tuple):\n                    is_tuple = True\n                elif isinstance(node.targets[0], ast.Name):\n                    ##assert node.targets[0].id in self._globals\n                    pass\n                elif isinstance(node.targets[0], ast.Subscript):\n                    pass\n                else:\n                    raise SyntaxError( self.format_error(node.targets[0]))\n\n            out = []\n            try:\n                value = self.visit(node.value)\n            except GenerateSlice as error:  ## special c++ case for slice syntax\n                assert self._cpp\n                msg = error[0]\n                slice_type = None  ## slice on an unknown type is broken and will segfault - TODO fix this\n                if msg['value'] in self._known_arrays:\n                    slice_type = self._known_arrays[msg['value']]\n                    self._known_arrays[target] = slice_type\n\n                slice = self._gen_slice(\n                    target,\n                    value=msg['value'],\n                    lower=msg['lower'],\n                    upper=msg['upper'],\n                    step =msg['step'],\n                    type=slice_type,\n                )\n                return slice\n\n            isclass = False\n            isglobal = target in self._globals\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id in self._classes:\n                isclass = True\n\n            if self._cpp:\n                if isclass:\n                    classname = node.value.func.id\n                    self._known_instances[ target ] = classname\n\n                    return '%s = %s;' %(target, value)\n                    ## TODO remove below\n                    #constructor_args = value.strip()[ len(classname)+1 :-1] ## strip to just args\n                    #r = ''\n                    #if isglobal:\n                    #   r += '/* global : %s, type:%s */\\n' %(target, classname)\n                    #r += '%s  _ref_%s = %s{};' %(classname, target, classname)\n                    #if constructor_args:\n                    #   r += '_ref_%s.__init__(%s);' %(target, constructor_args)\n                    #if not self._shared_pointers:\n                    #   r += '\\n%s = \n_ref_%s;' %(target, target)\n                    #elif self._unique_ptr:\n                    #   r += '\\n%s = std::make_unique\n%s\n(_ref_%s);' %(target, classname, target)\n                    #else:\n                    #   r += '\\n%s = std::make_shared\n%s\n(_ref_%s);' %(target, classname, target)\n                    #return r\n\n                elif is_attr and target.startswith('PyObject_GetAttrString(') and target.endswith(')'):\n                    pyob = self.visit(node.targets[0].value.value)\n                    attr = node.targets[0].attr\n                    if isinstance(node.value, ast.Num):\n                        if str(node.value.n).isdigit():\n                            return 'PyObject_SetAttrString(%s, \n%s\n, PyInt_FromLong(%s));'%(pyob,attr, value)\n\n                        else:\n                            return 'PyObject_SetAttrString(%s, \n%s\n, PyFloat_FromDouble(%s));'%(pyob,attr, value)\n\n                    elif isinstance(node.value, ast.Str):\n                        raise RuntimeError('TODO assign str to pyobject')\n                    else:\n                        return 'PyObject_SetAttrString(%s, \n%s\n, %s);'%(pyob,attr, value)\n\n                elif target.startswith('PyObject_CallFunction(') and target.endswith(')'):\n                    ## hackish way to support `pyob-\nsomearray[n]\n                    hack = target.replace(\n                        '\n__getitem__\n),\ni\n,',\n                        '\n__setitem__\n),\niO\n,'\n                    )\n                    return '%s, %s);' %( hack[:-1], value )\n\n                elif isinstance(value, tuple):\n                    assert isinstance(node.value, ast.BinOp)\n                    assert isinstance(node.value.left, ast.Call)\n                    assert node.value.left.func.id=='__go__array__'\n                    #raise RuntimeError(value)\n                    #raise RuntimeError(node.value.left.args[0].id)\n                    #assert node.value.left.args[0].id=='tuple'\n                    if target in self._vars:\n                        self._vars.remove( target )\n                        self._known_vars.add( target )\n                        return 'auto %s = %s{%s}; /*somearray*/' %(target, value[0], ','.join(value[1]))\n                    else:\n                        return '%s = %s{%s}; /*somearray*/' %(target, value[0], ','.join(value[1]))\n                else:\n                    if value in self._known_arrays and isinstance(self._known_arrays[value], tuple) and self._memory[-1]=='STACK':\n                        atype, fixed_size = self._known_arrays[value]\n\n                        ## unroll loop if possible ##\n                        if '(' in value and ')' in value:  ## do not unroll from a function call\n                            if target in self._vars:\n                                ## first assignment of a known variable, this requires 'auto' in c++11\n                                self._vars.remove( target )\n                                self._known_vars.add( target )\n                                return 'auto %s = %s; /*Assignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n                            else:\n                                return '%s = %s; /*Reassignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n\n                        elif fixed_size.isdigit() and int(fixed_size)\n512:  ## or in self._macro_constants: TODO\n                            fixed_size = int(fixed_size)\n                            r = []\n                            for i in range(fixed_size):\n                                r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                            return ' '.join(r)\n                        else:\n                            r = [\n                                'for (int __i=0; __i\n%s; __i++) {' %fixed_size,\n                                self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                                self.indent()+'}',\n                            ]\n                            return '\\n'.join(r)\n\n                    else:\n                        return '%s = %s;' % (target, value)\n\n            else:\n                assert self._rust\n                ## destructured assignments also fallback here.\n                ## fallback to mutable by default? `let mut (x,y) = z` breaks rustc\n                if isclass:\n                    raise RuntimeError('TODO')\n                if is_attr:\n                    return '%s = %s;' % (target, value)\n                else:\n                    return 'let %s = %s;' % (target, value)", 
            "title": "SharedRustC++Class"
        }, 
        {
            "location": "/cpprustbase/#c-and-rust", 
            "text": "common base  TODO: do not subclass from  GoGenerator  \nclass CppRustBase( GoGenerator ):\n\n    def __init__(self, source=None, requirejs=False, insert_runtime=False):\n        assert source\n        GoGenerator.__init__(self, source=source, requirejs=False, insert_runtime=False)\n        self._global_types = {\n            'string' : set()\n        }\n        self._with_type = []\n        self._switch_on_type_object = []\n        self._lambda_stack = []\n        self._memory = ['HEAP']  ## affects how `.` is default translated to `- ` or `.`\n        self._rust = True\n        self._go   = False\n        self._threads = []  ## c++11 threads\n        self._unique_ptr = False ## TODO\n        self._has_channels = False\n        self._crates = {}\n        self._root_classes = {}\n        self._java_classpaths = []\n        self._known_strings = set()\n        self._force_cstr = False\n        self._known_pointers = {}\n        self._global_arrays  = {}\n        self._global_refs    = {}\n        self._typedefs       = {}\n        self._in_constant    = False\n        self._known_tuples   = {}\n        self._global_tuples  = {}\n        self.macros = {}\n\n\n    def _inline_code_helper(self, s):\n        return s\n\n    def visit_Expr(self, node):\n        # XXX: this is UGLY\n        s = self.visit(node.value)\n        if s is None:\n            raise RuntimeError('error in rusttranslator.md:' +node.value.func.id)\n        if s.strip() and not s.endswith(';'):\n            s += ';'\n        if s==';': return ''\n        else: return s\n\n\n    def visit_Str(self, node):\n        s = node.s.replace( \\\\ ,  \\\\\\\\ ).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace(' ', '\\\\ ')\n        #return ' %s ' % s\n        if self._function_stack: return ' %s .to_string()' % s\n        else: return ' %s ' % s\n\n    def visit_Is(self, node):\n        return '=='\n\n    def visit_IsNot(self, node):\n        return '!='", 
            "title": "C++ and Rust"
        }, 
        {
            "location": "/cpprustbase/#for-loop", 
            "text": "hooks into bad magic hack, 2nd pass rustc compile.  \n\n    def visit_For(self, node):\n        if not hasattr(node.iter, 'uid'):\n            ## in the first rustc pass we assume regular references using ` X`,\n            ## for loops over an array of Strings requires the other type using just `X` or `ref X`\n            node.iter.uid = self.uid()\n            node.iter.is_ref = True\n            self.unodes[ node.iter.uid ] = node.iter\n\n        target = self.visit(node.target)\n        lines = []\n\n        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, ast.Name):\n\n            if node.iter.func.id == 'range':\n                if len(node.iter.args)==1:\n                    iter = self.visit(node.iter.args[0])\n                    if self._cpp:\n                        lines.append('for (int %s=0; %s %s; %s++) {' %(target, target, iter, target))\n                    else:\n                        lines.append('for %s in range(0u, %s) {' %(target, iter))\n                elif len(node.iter.args)==2:\n                    start = self.visit(node.iter.args[0])\n                    iter = self.visit(node.iter.args[1])\n                    if self._cpp:\n                        lines.append('for (int %s=%s; %s %s; %s++) {' %(target, start, target, iter, target))\n\n                    else:\n                        lines.append('for %s in range(%s as uint, %s as uint) {' %(target, start, iter))\n                else:\n                    raise SyntaxError('invalid for range loop')\n\n            elif node.iter.func.id == 'enumerate':\n                iter = self.visit(node.iter.args[0])\n                idx = self.visit(node.target.elts[0])\n                tar = self.visit(node.target.elts[1])\n                if self._cpp:\n                    lines.append('int %s = -1;' %idx)\n                    lines.append('for (auto  %s: _ref_%s) {' %(tar, iter))  ## TODO remove _ref_\n                else:\n                    lines.append('let mut %s = -1i;' %idx)\n                    if node.iter.is_ref:\n                        lines.append('for  %s in %s.iter() { //magic:%s' %(tar, iter, node.iter.uid))\n                    else:\n                        lines.append('for %s in %s.iter() { //magic:%s' %(tar, iter, node.iter.uid))\n\n                lines.append('  %s += 1;' %idx)\n\n            else: ## generator function\n                gfunc = node.iter.func.id\n                gargs = ','.join( [self.visit(e) for e in node.iter.args] )\n                lines.append('__gen%s := __new__%s(%s)' %(gfunc,gfunc, gargs))\n                lines.append('for __gen%s.__done__ != 1 {' %gfunc)\n                lines.append('  %s := __gen%s.next()' %(self.visit(node.target), gfunc))\n\n        elif isinstance(node.target, ast.List) or isinstance(node.target, ast.Tuple):\n            iter = self.visit( node.iter )\n            if len(node.target.elts)==3 and isinstance(node.target.elts[1], ast.Name) and node.target.elts[1].id == '__as__':\n                target = self.visit(node.target.elts[0])\n                astype = self.visit(node.target.elts[2])\n                if iter.startswith('PyObject_GetAttrString('):\n                    lines.append('PyObject* __pyiter__%s = PyObject_GetIter(%s);' %(target,iter))\n                    lines.append('while (auto _pyob_%s = PyIter_Next(__pyiter__%s)) {' %(target, target))\n                    if astype in 'int long i32 i64'.split():\n                        lines.append('  auto %s = PyInt_AS_LONG(_pyob_%s);' %(target,target))\n                else:\n                    lines.append('for (auto  %s: *%s) {' %(target, iter))\n\n            else:\n                key = self.visit(node.target.elts[0])\n                val = self.visit(node.target.elts[1])\n                iname = iter.split('.')[0]\n                if self._cpp:\n                    if iname not in self._known_maps:\n                        raise SyntaxError(self.format_error('for loop target tuple unpack over some unknown type, not a known map'))\n                    lines.append('for (auto  _pair_%s : *%s) {' %(key, iter))\n                    lines[-1] += '  auto %s = _pair_%s.first;' %(key, key)\n                    lines[-1] += '  auto %s = _pair_%s.second;' %(val, key)\n\n                else:  ## rust\n                    lines.append('for (%s, %s) in %s.iter() {' %(key,val, iter))\n\n        else:\n\n            iter = self.visit( node.iter )\n            arrname = iter.split('.')[0]\n            if node.iter.is_ref:\n                if self._cpp:\n                    if arrname in self._known_arrays:\n                        if isinstance(self._known_arrays[arrname], tuple):\n                            lines.append('for (int __idx=0; __idx %s; __idx++) { /*loop over fixed array*/' %self._known_arrays[arrname][1])\n                            lines.append(self.indent()+'%s %s = %s[__idx];' %(self._known_arrays[arrname][0], target, iter))\n                        elif arrname in self._known_refs:\n                            lines.append('for (auto  %s: %s) { /*loop over stack vector*/' %(target, iter))\n                        else:\n                            lines.append('for (auto  %s: (*%s)) { /*loop over heap vector*/' %(target, iter))\n                    elif arrname in self._known_maps:\n                        lines.append('for (auto  _pair_%s: (*%s)) {' %(target, iter))\n                        #lines.append('  auto %s = _pair_%s.second;' %(target, target))\n                        lines.append('  auto %s = _pair_%s.first;' %(target, target))\n                    else:\n                        if iter.startswith('PyObject_GetAttrString('):\n                            lines.append('PyObject *__pyiterator = PyObject_GetIter(%s);' %iter)\n                            lines.append('while (auto %s = PyIter_Next(__pyiterator)) {' %target)\n                        else:\n                            lines.append('for (auto  %s: *%s) { /*loop over unknown type*/' %(target, iter))\n\n                else:\n                    lines.append('for  %s in %s.borrow_mut().iter() { //magic:%s' %(target, iter, node.iter.uid))\n            else:\n                lines.append('for %s in %s.borrow_mut().iter() { //magic:%s' %(target, iter, node.iter.uid))\n\n        clean_up_scope = []\n        self.push()\n        for b in node.body:\n            lines.append( self.indent()+self.visit(b) )\n            ## after `b` has been visited, if it was an assignment node,\n            ## it will then need to be removed from the known variables list,\n            ## because C++ is block scoped, and in regular python variables escape for loops.\n            if hasattr(b, '_new_assignment'):\n                clean_up_scope.append(b._new_assignment)\n\n        self.pull()\n        lines.append( self.indent()+'}' )  ## end of for loop\n\n        for name in clean_up_scope:\n            self._known_vars.remove(name)\n            self._vars.add(name)\n\n        return '\\n'.join(lines)", 
            "title": "For Loop"
        }, 
        {
            "location": "/cpprustbase/#while-loop", 
            "text": "works with rust and c++  \n    def visit_While(self, node):\n        cond = self.visit(node.test)\n        if cond == 'true' or cond == '1': cond = ''\n        body = []\n        if not cond.strip():\n            if self._cpp:\n                body.append('while (true) {')\n            else:\n                body.append('loop {')\n        else:\n            if self._cpp:\n                body.append('while (%s) {' %cond)\n            else:\n                body.append('while %s {' %cond)\n\n        self.push()\n        for line in list( map(self.visit, node.body) ):\n            body.append( self.indent()+line )\n        self.pull()\n        body.append( self.indent() + '}' )\n        return '\\n'.join( body )", 
            "title": "While Loop"
        }, 
        {
            "location": "/cpprustbase/#compare-xy", 
            "text": "needs to check if item is a string there is an  in  test,  if \"x\" in \"xyz\" \nso that can be translated to string.find or if it is a vector  std::find .      def visit_Compare(self, node):\n        comp = ['(']\n        left = self.visit(node.left)\n        if isinstance(node.left, ast.BinOp):\n            comp.extend( ['(', self.visit(node.left), ')'] )\n        else:\n            comp.append( self.visit(node.left) )\n\n        for i in range( len(node.ops) ):\n            op = node.ops[i]\n            if isinstance(op, ast.In) or isinstance(op, ast.NotIn):\n                if comp[-1]==left:\n                    comp.pop()\n                else:\n                    comp.append('   ')\n                rator = self.visit(node.comparators[i])\n                if rator in self._known_strings:\n                    comp.append('(%s.find(%s) != std::string::npos)' %(rator, left))\n                else:\n                    comp.append('(std::find(%s- begin(), %s- end(), %s) != %s- end())' %(rator, rator, left, rator))\n\n            else:\n                comp.append( self.visit(op) )\n\n                if isinstance(node.comparators[i], ast.BinOp):\n                    comp.append('(')\n                    comp.append( self.visit(node.comparators[i]) )\n                    comp.append(')')\n                else:\n                    comp.append( self.visit(node.comparators[i]) )\n\n        comp.append( ')' )\n\n        return ' '.join( comp )", 
            "title": "Compare x==y"
        }, 
        {
            "location": "/cpprustbase/#if", 
            "text": "TODO test  if pointer:  c++  \n    def visit_If(self, node):\n        out = []\n        isinstance_test = False\n        ispyinstance_test = False\n        target = None\n        classname = None\n\n        if isinstance(node.test, ast.Compare) or isinstance(node.test, ast.UnaryOp) or isinstance(node.test, ast.BoolOp):\n            test = self.visit(node.test)\n        elif isinstance(node.test, ast.Name):\n            if node.test.id in ('null', 'None', 'False'):\n                test = 'false'\n            elif node.test.id == 'True':\n                test = 'true'\n            else:\n                test = '%s==true' %node.test.id\n        elif isinstance(node.test, ast.Num):\n            test = '%s!=0' %node.test.n\n        elif isinstance(node.test, ast.Call) and isinstance(node.test.func, ast.Name) and node.test.func.id=='isinstance':\n            isinstance_test = True\n            target = self.visit(node.test.args[0])\n            classname = self.visit(node.test.args[1])\n            if self._memory[-1]=='STACK':\n                test = '(%s.__class__==std::string( %s ))' %(target, classname)\n            else:\n                test = '(%s- __class__==std::string( %s ))' %(target, classname)\n\n        elif isinstance(node.test, ast.Call) and isinstance(node.test.func, ast.Name) and node.test.func.id=='ispyinstance':\n            ispyinstance_test = True\n            target = self.visit(node.test.args[0])\n            classname = self.visit(node.test.args[1])\n            test = 'ispyinstance(%s, std::string( %s ))==true' %(target, classname)\n            if 'ispyinstance' not in self._called_functions:\n                self._called_functions['ispyinstance'] = 0\n            self._called_functions['ispyinstance'] += 1\n\n        else:\n            test = '%s==true' %self.visit(node.test)\n\n        out.append( 'if (%s) {' %test )\n\n        self.push()\n        if isinstance_test:\n            assert self._cpp\n            self._rename_hacks[target] = '_cast_%s' %target\n            targ = target\n            if '- ' in target:\n                targ = target.replace('- ', '_')\n\n            if self._memory[-1] == 'STACK':\n                out.append(self.indent()+'auto _cast_%s = static_cast %s (%s);' %(targ, classname, target))\n            elif self._polymorphic:\n                out.append(self.indent()+'auto _cast_%s = std::dynamic_pointer_cast %s (%s);' %(targ, classname, target))\n            else:\n                out.append(self.indent()+'auto _cast_%s = std::static_pointer_cast %s (%s);' %(targ, classname, target))\n\n        elif ispyinstance_test:\n            assert self._cpp\n            self._rename_hacks[target] = '_cast_%s' %target\n            if classname in 'int i32 long i64'.split():\n                out.append(self.indent()+'auto _cast_%s = PyInt_AS_LONG(%s);' %(target, target))\n            elif classname in 'float f32 double f64'.split():\n                out.append(self.indent()+'auto _cast_%s = PyFloat_AS_DOUBLE(%s);' %(target, target))\n            elif classname in 'string str'.split():\n                out.append(self.indent()+'auto _cast_%s = std::string(PyString_AS_STRING(%s));' %(target, target))\n            else:\n                #raise RuntimeError('TODO pytype:'+classname)\n                ## user class\n                self._rename_hacks.pop(target)\n\n\n\n        for line in list(map(self.visit, node.body)):\n            if line is None: continue\n            out.append( self.indent() + line )\n\n        if isinstance_test or ispyinstance_test:\n            if target in self._rename_hacks:\n                self._rename_hacks.pop(target)\n\n\n        orelse = []\n        for line in list(map(self.visit, node.orelse)):\n            orelse.append( self.indent() + line )\n\n        self.pull()\n\n        if orelse:\n            out.append( self.indent() + '} else {')\n            out.extend( orelse )\n\n        out.append( self.indent() + '}' )\n\n        return '\\n'.join( out )\n\n\n    def visit_Index(self, node):\n        if isinstance(node.value, ast.Num):\n            return str(node.value.n)\n        else:\n            return self.visit(node.value)", 
            "title": "If"
        }, 
        {
            "location": "/cpprustbase/#name", 
            "text": "note:  nullptr  is c++11  \n    def visit_Name(self, node):\n        if node.id == 'None' or node.id == 'nil' or node.id == 'null':\n            if self._cpp:\n                return 'nullptr'\n            else:\n                return 'None'\n        elif node.id == 'True':\n            return 'true'\n        elif node.id == 'False':\n            return 'false'\n        elif node.id in self._rename_hacks:  ## TODO make the node above on the stack is not an attribute node.\n            return self._rename_hacks[ node.id ]\n        elif node.id=='self' and self._class_stack and self._cpp:\n            return 'this'\n        elif node.id=='__finally__':\n            return 'finally'\n        else:\n            return node.id\n\n    def get_subclasses( self, C ):\n        '''\n        returns all sibling subclasses, C can be a subclass or the base class\n        '''\n        subclasses = set()\n        self._collect_subclasses(C, subclasses)\n        return subclasses\n\n    def _collect_subclasses(self, C, subclasses):\n        node = self._classes[ C ]\n        if len(node._parents)==0:\n            for sub in node._subclasses:\n                subclasses.add( sub )\n        else:\n            for parent in node._parents:\n                self._collect_subclasses(parent, subclasses)\n\n\n    def visit_ClassDef(self, node):\n        self._class_stack.append( node )\n        if not hasattr(node, '_parents'):  ## only setup on the first pass\n            node._parents = set()\n            node._struct_def = dict()\n            node._subclasses = set()  ## required for generics generator\n            ## subclasses must be a struct union so that Go can convert between struct types\n            node._subclasses_union = dict()\n            ## any classes that this class contains in arrays or maps,\n            ## this is used by the child to create a weakref to the parent if required.\n            node._contains_classes = set()\n            node._weak_members = set()\n            node._requires_init = False\n            ## subclasses need to check the parent class for methods with the same name\n            ## and a different signature.  These are regenerated in the subclass.\n            node._methods = list()  ## nodes\n\n        out = []\n        sdef = dict()\n        props = set()\n        bases = set()\n        base_classes = set()\n        self._classes[ node.name ] = node\n        self._class_props[ node.name ] = props\n        if node.name not in self.method_returns_multiple_subclasses:\n            self.method_returns_multiple_subclasses[ node.name ] = set()  ## tracks which methods in a class return different subclass types\n\n        comments = []\n        for b in node.body:\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Str):\n                comments.append(b.value.s)\n\n        if comments:\n            out.append('/**')\n            for line in comments[0].splitlines():\n                out.append(' * '+line)\n            out.append(' */')\n\n\n        root_classes = set()  ## subsubclasses in c++ need to inherit from the roots\n        cpp_bases = list()\n        extern_classes = list()\n        for base in node.bases:\n            n = self.visit(base)\n            if n == 'object':\n                continue\n            if n in self._root_classes:\n                root_classes.add(n)\n\n            node._parents.add( n )\n            cpp_bases.append( n )\n            bases.add( n )\n\n            if n in self._class_props:\n                props.update( self._class_props[n] )\n                base_classes.add( self._classes[n] )\n\n            if n not in self._classes:\n                extern_classes.append(n)\n            else:\n                for p in self._classes[ n ]._parents:\n                    bases.add( p )\n                    props.update( self._class_props[p] )\n                    base_classes.add( self._classes[p] )\n                    if p in self._root_classes:\n                        root_classes.add(p)\n\n                self._classes[ n ]._subclasses.add( node.name )\n\n        if len(root_classes) 1 and self._cpp:\n            raise RuntimeError(root_classes)\n\n        if not len(base_classes):\n            self._root_classes[ node.name ] = node\n\n        ## class decorators ##\n        is_jvm_class = False\n        external_header = None\n        for decor in node.decorator_list:\n            ## __struct__ is generated in python_to_pythonjs.py\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id=='__struct__':\n                for kw in decor.keywords:\n                    props.add( kw.arg )\n                    T = kw.value.id\n                    sdef[ kw.arg ] = T\n            elif self._cpp:\n                if isinstance(decor, ast.Name) and decor.id=='jvm':\n                    ## subclasses from a Java class ##\n                    self._jvm_classes[ node.name ] = node\n                    is_jvm_class = True\n                elif isinstance(decor, ast.Name) and decor.id in self._user_class_headers:\n                    external_header = self._user_class_headers[ decor.id ]\n                elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'macro':\n                    out.append( decor.args[0].s )\n                else:\n                    raise RuntimeError('TODO class decorator')\n\n        init = None\n        method_names = set()\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                method_names.add( b.name )\n                node._methods.append( b )  ## save method node, header-signature and body.\n\n                if b.name == '__init__':\n                    init = b\n                    node._requires_init = True\n\n            elif isinstance(b, ast.Expr) and isinstance(b.value, ast.Dict):\n                for i in range( len(b.value.keys) ):\n                    k = self.visit( b.value.keys[ i ] )\n                    if isinstance(b.value.values[i], ast.Str):\n                        v = b.value.values[i].s\n                    elif isinstance(b.value.values[i], ast.Call):\n                        n = b.value.values[i]\n                        if n.func.id in ('__go__map__', '__arg_map__'):\n                            if n.func.id=='__arg_map__':\n                                assert n.args[0].s.startswith('map[')\n                                key_type = n.args[0].s.split('[')[-1].split(']')[0]\n                                value_type = n.args[0].s.split(']')[-1]\n                            else:\n                                key_type = self.visit(n.args[0])\n                                value_type = self.visit(n.args[1])\n                            if key_type=='string': key_type = 'std::string'\n                            if value_type=='string': value_type = 'std::string'\n                            v = 'std::map %s, %s ' %(key_type, value_type)\n                        elif n.func.id == '__arg_array__':\n                            if isinstance(n.args[0], ast.Str):\n                                t = n.args[0].s\n                            else:\n                                t = self.visit(n.args[0])\n                            dims = 0\n                            if t.startswith('['):\n                                dims = t.count('[')\n                                t = t.split(']')[-1]\n                            if t=='string':\n                                if self.usertypes and 'string' in self.usertypes:\n                                    key_type = self.usertypes['string']['type']\n                                else:\n                                    key_type = 'std::string'\n\n                            if not self.is_prim_type(t):\n                                if self.usertypes and 'shared' in self.usertypes:\n                                    t = self.usertypes['shared']['template'] % t\n                                else:\n                                    t = 'std::shared_ptr %s ' %t\n\n                            if not dims or dims==1:\n                                if self.usertypes and 'vector' in self.usertypes:\n                                    v = self.usertypes['vector']['template'] % t\n                                else:\n                                    v = 'std::vector %s ' %t\n                            elif dims == 2:  ## TODO clean this up, support more dims, and self.usertypes\n                                v = 'std::vector std::shared_ptr std::vector %s ' %t\n\n                        else:\n                            raise RuntimeError('TODO', n.func.id)\n\n                    else:\n                        v = self.visit( b.value.values[i] )\n\n                    if v.startswith('['):  ## swap array style to C++\n                        x,y = v.split(']')\n                        v = y + x + ']'\n                        if self._memory[-1]=='HEAP':\n                            if self.is_prim_type(y):\n                                v = 'std::vector %s ' %y\n                            else:\n                                v = 'std::vector std::shared_ptr %s ' %y\n\n                    sdef[k] = v\n\n\n        node._struct_def.update( sdef )\n        unionstruct = dict()\n        unionstruct.update( sdef )\n        for pname in node._parents:\n            if pname in self._classes:\n                parent = self._classes[ pname ]\n                parent._subclasses_union.update( sdef )        ## first pass\n                unionstruct.update( parent._subclasses_union ) ## second pass\n            else:\n                pass  ## class from external c++ library\n\n\n        parent_init = None\n        overload_nodes = []\n        overloaded  = []  ## this is just for rust\n        overloaded_returns_self = []\n        if base_classes:\n            for bnode in base_classes:\n                for b in bnode.body:\n                    if isinstance(b, ast.FunctionDef):\n                        overload_nodes.append( b )\n                        #if hasattr(b, 'returns_self') and b.returns_self:\n                        #   if b.name != '__init__' and not b.is_abstract:\n                        #       overloaded_returns_self.append(b)\n                        if b.name != '__init__' and b.name not in method_names:\n                            overloaded_returns_self.append(b)\n\n                        ## catch_call trick is used to call methods on base classes from the subclass.\n                        if self._cpp:\n                            ##self.catch_call.add( '%s- %s' %(bnode.name, b.name))\n                            #note: `::` is automatic now when calling classmethod/staticmethods.\n                            self.catch_call.add( '%s::%s' %(bnode.name, b.name))\n                        else:\n                            self.catch_call.add( '%s.%s' %(bnode.name, b.name))\n\n                        if b.name in method_names:\n                            b.overloaded = True\n                            b.classname  = bnode.name\n                        if b.name == '__init__':\n                            parent_init = {'class':bnode, 'node':b}\n                            node._requires_init = True\n\n\n        for b in overload_nodes:\n            if hasattr(b, 'overloaded'):\n                original = b.name\n                b.name = '__%s_%s'%(b.classname, b.name)  ## rust requires this extra hackery\n                overloaded.append( self.visit(b) )\n                b.name = original\n            else:\n                overloaded.append( self.visit(b) )\n\n        if self._cpp:\n            if cpp_bases:\n                #parents = ','.join(['public %s' % rname for rname in root_classes])\n                parents = ','.join(['public %s' % rname for rname in cpp_bases])\n                out.append( 'class %s:  %s {' %(node.name, parents))\n            else:\n                #out.append( 'class %s {' %node.name)\n                ## shared from this is required so that `self` (this) can be passed to\n                ## other functions and objects that may take ownership of `self`.\n                ## on subclasses the base class is returned from `shared_from_this()`\n                out.append( 'class %s: public std::enable_shared_from_this %s  {' %(node.name, node.name))\n\n            ## body macros come before public ##\n            for b in node.body:\n                if isinstance(b, ast.Expr) and isinstance(b.value, ast.Call) and isinstance(b.value.func, ast.Name) and b.value.func.id=='macro':\n                    out.append(b.value.args[0].s)\n\n\n            out.append( '  public:')\n\n            #if not base_classes:\n            if not cpp_bases or is_jvm_class:\n                ## only the base class defines `__class__`, this must be the first element\n                ## in the struct so that all rusthon object has the same header memory layout.\n                ## note if a subclass redefines `__class__` even as a string, and even as the\n                ## first struct item, it will still not have the same memory location as super.__class__.\n                ## We require the same memory location for `__class__` because the `isinstance`\n                ## hack requires on `__class__` always being valid to check an objects class type at runtime.\n                out.append( '   std::string __class__;')\n                out.append( '   bool __initialized__;')\n                out.append( '   int  __classid__;')\n        else:\n            out.append( 'struct %s {' %node.name)\n            ## rust requires that a struct contains at least one item,\n            ## `let a = A{}` is invalid in rust, and will fail with this error\n            ## error: structure literal must either have at least one field or use functional structure update syntax\n            ## to workaround this problem in the init constructor, the A::new static method simply makes\n            ## the new struct passing the classname as a static string, and then calls the users __init__ method\n            out.append( '   __class__ : string,')\n\n\n        rust_struct_init = ['__class__: %s ' %node.name]\n        parent_attrs = {}\n\n        if base_classes:\n            for bnode in base_classes:\n                if self._cpp:\n                    if bnode._struct_def.keys():\n                        out.append('//  members from class: %s  %s'  %(bnode.name, bnode._struct_def.keys()))\n                        ## not required, the subclass should not redeclare members of parents\n                        #for key in bnode._struct_def:\n                        #   if key not in unionstruct:\n                        #       unionstruct[key] = bnode._struct_def[key]\n                        parent_attrs.update( bnode._struct_def )\n\n                elif self._rust:\n                    out.append('//  members from class: %s  %s'  %(bnode.name, bnode._struct_def.keys()))\n                    ## to be safe order should be the same?\n                    for key in bnode._struct_def.keys():\n                        if key in unionstruct:\n                            unionstruct.pop(key)  ## can subclass have different types in rust?\n                        out.append('    %s : %s,' %(key, bnode._struct_def[key]))\n                        rust_struct_init.append('%s:%s' %(key, default_type(bnode._struct_def[key])))\n\n                else:\n                    raise RuntimeError('invalid backend')\n\n        node._struct_init_names = []  ## save order of struct layout\n\n        for name in unionstruct:\n\n            if unionstruct[name]=='interface{}':\n                raise SyntaxError('interface{} is just for the Go backend')\n\n            node._struct_init_names.append( name )\n            #if name=='__class__': continue\n\n            T = unionstruct[name]\n            ## skip redefines of attributes in a subclass with the same type,\n            ## this ensures that subclasses will have the same memory layout\n            ## for shared attributes of the same type, and that std::static_pointer_cast also works.\n            if name in parent_attrs and parent_attrs[name]==T:\n                continue\n\n            member_isprim = self.is_prim_type(T)\n            if self._cpp:\n                if T=='string': T = 'std::string'\n\n                if T.endswith(']'):\n                    x,y = T.split('[')\n                    out.append('    %s  %s[%s;' %(x, name, y ))\n                elif member_isprim:\n                    out.append('    %s  %s;' %(T, name ))\n                else:\n                    otherclass = T.split(' ')[-1].split(' ')[0]\n\n                    if self.is_container_type(T):\n                        node._contains_classes.add( otherclass )\n\n                    weakref = False\n                    if otherclass in self._classes:\n                        if node.name in self._classes[otherclass]._contains_classes:\n                            #raise RuntimeError('%s contains %s' %(otherclass, node.name))\n                            weakref = True\n\n                    if not self._shared_pointers or self._memory[-1]=='STACK':\n                        out.append('    %s*  %s;' %(T, name ))\n                    elif self._unique_ptr:\n                        out.append('    std::unique_ptr %s   %s;' %(T, name ))\n                    else:\n\n                        if weakref:\n                            node._weak_members.add(name)\n                            if self.usertypes and 'weakref' in self.usertypes:\n                                out.append('    %s  %s;' %( self.usertypes['weakref']['template']%T, name ))\n                            else:\n                                out.append('    std::weak_ptr %s   %s;' %(T, name ))\n\n                        elif T.startswith('std::shared_ptr '):  ## TODO check this\n                            out.append('    %s  %s;' %(T, name ))\n\n                        else:\n                            if self.usertypes and 'shared' in self.usertypes:\n                                out.append('    %s  %s;' %(self.usertypes['shared']['template']%T, name ))\n                            else:\n                                out.append('    std::shared_ptr %s   %s;' %(T, name ))\n            else:\n                rust_struct_init.append('%s:%s' %(name, default_type(T)))\n                if T=='string': T = 'String'\n                if member_isprim:\n                    out.append('    %s : %s,' %(name, T))\n                else:\n                    out.append('    %s : Rc RefCell %s ,' %(name, T))\n\n\n        self._rust_trait = []\n        self._cpp_class_header = []\n        impl  = []\n        self.push()\n\n        ## required by new style because __init__ returns this which needs to be defined for each subclass type ##\n        if self._cpp and parent_init:\n            if not init:\n                impl.append( self.visit(parent_init['node']) )\n            elif len(init.args.args) != len(parent_init['node'].args.args):\n                impl.append( self.visit(parent_init['node']) )\n\n        for b in node.body:\n            if isinstance(b, ast.FunctionDef):\n                impl.append( self.visit(b) )\n\n        for b in overloaded_returns_self:\n            impl.append( self.visit(b) )\n\n\n        self.pull()\n\n        if self._cpp:\n            for impl_def in self._cpp_class_header:\n                out.append( '\\t' + impl_def )\n\n\n\n            ## c++ empty constructor with `struct-emeddding` the class name\n            #out.append('   %s() : __class__(std::string( %s )) {}' %(node.name, node.name) )  ## this breaks when looping over array items\n            ## member initializer list `MyClass() : x(1) {}` only work when `x` is locally defined inside the class,\n            ## it breaks on `__class__` because that is defined in the parent class, instead `__class__` is initalized in the constructors body.\n            ## TODO make __class__ static const string.\n\n            if not extern_classes:\n                classid = self._classes.keys().index(node.name)\n                out.append('    bool operator != (std::nullptr_t rhs) {return __initialized__;}' )\n                out.append('    bool operator == (std::nullptr_t rhs) {return !__initialized__;}' )\n                out.append('    %s() {__class__ = std::string( %s ); __initialized__ = true; __classid__=%s;}' %(node.name, node.name, classid) )\n\n                ## `let a:MyClass = None` is generated when in stack mode and an object is created and set to None.\n                out.append('    %s(bool init) {__class__ = std::string( %s ); __initialized__ = init; __classid__=%s;}' %(node.name, node.name, classid) )\n\n                if self._polymorphic:\n                    out.append('    virtual std::string getclassname() {return this- __class__;}')  ## one virtual method makes class polymorphic\n                elif self._memory[-1]=='STACK':\n                    out.append('    std::string getclassname() {return __class__;}')\n                else: #not base_classes:\n                    out.append('    std::string getclassname() {return this- __class__;}')\n\n            elif is_jvm_class:\n                ## TODO constructor args for jvm super class and __init__ for subclass\n                out.append('    %s(JavaVM* _jvm) : %s(_jvm) {__class__ = std::string( %s );}' %(node.name, extern_classes[0], node.name) )\n                out.append('    std::string getclassname() {return this- __class__;}')\n            else:\n                pass ## some unknown external c++ class, TODO constructor.\n\n            out.append('};')\n\n        else: ## rust\n            out.append('}')\n\n        cpp_method_impl = []\n        if self._cpp:\n            for idef in impl:\n                if external_header:\n                    cpp_method_impl.append( idef )\n                else:  ## can not write c++ method implementations before other class headers\n                    self._cpp_class_impl.append( idef )\n\n        else:\n            ## using a trait is not required, because a struct type can be directly implemented.\n            ## note: methods require a lambda wrapper to be passed to another function.\n            #out.append('trait %s {' %node.name)\n            #for trait_def in self._rust_trait: out.append( '\\t'+ trait_def )\n            #out.append('}')\n            #out.append('impl %s for %sStruct {' %(node.name, node.name))\n            #for impl_def in impl: out.append( impl_def )\n            #out.append('}')\n\n            out.append('impl %s {' %node.name)\n            for impl_def in impl: out.append( impl_def )\n\n            if overloaded:\n                out.append('/*      overloaded methods      */')\n                for o in overloaded:\n                    out.append( o )\n\n            if init:\n                tmp = 'let mut __ref__ = %s{%s};' %(node.name, ','.join(rust_struct_init))\n                tmp += '__ref__.__init__(%s);' % ','.join(init._arg_names)\n                tmp += 'return __ref__;'\n                out.append('/*      constructor     */')\n                out.append('    fn new( %s ) -  %s { %s }' %(init._args_signature, node.name, tmp) )\n            else:\n                tmp = 'let mut __ref__ = %s{%s};' %(node.name, ','.join(rust_struct_init))\n                tmp += 'return __ref__;'\n                out.append('/*      constructor     */')\n                out.append('    fn new() -  %s { %s }' %(node.name, tmp) )\n\n\n            out.append('}')  ## end rust `impl`\n\n\n        self.catch_call = set()\n        self._class_stack.pop()\n        if external_header:\n            external_header['source'].extend( out )\n            out.append( '// header saved to: %s'  % external_header['file'])\n            return '\\n'.join(cpp_method_impl)\n\n        else:\n            return '\\n'.join(out)", 
            "title": "Name"
        }, 
        {
            "location": "/cpprustbase/#visit-call-special", 
            "text": "hack for calling base class methods.  \n    def _visit_call_special( self, node ):\n        fname = self.visit(node.func)\n        assert fname in self.catch_call\n        assert len(self._class_stack)\n        if len(node.args):\n            if isinstance(node.args[0], ast.Name) and node.args[0].id == 'self':\n                node.args.remove( node.args[0] )\n\n        if self._cpp:\n            if fname.count('::')   1: raise RuntimeError('TODO: %s'%fname)\n            ##classname = fname.split('- ')[0]\n            classname = fname.split('::')[0]\n            hacked = classname + '::' + fname[len(classname)+2:]\n            return self._visit_call_helper(node, force_name=hacked)\n        else:\n            classname = fname.split('.')[0]\n            hacked = 'self.__%s_%s' %(classname, fname[len(classname)+1:])\n            return self._visit_call_helper(node, force_name=hacked)", 
            "title": "Visit Call Special"
        }, 
        {
            "location": "/cpprustbase/#subscript-an", 
            "text": "def visit_Subscript(self, node):\n        if isinstance(node.slice, ast.Ellipsis):  ## special deference pointer syntax\n            return '(*%s)' %self.visit(node.value)\n        else:\n            ## deference pointer and then index\n            if isinstance(node.slice, ast.Slice):\n                if self._cpp:\n                    ## std::valarray has a slice operator `arr[ std::slice(start,end,step) ]`\n                    ## but std::valarray only works on numeric values, and can not grow in size.\n                    msg = {'value':self.visit(node.value), 'slice':node.slice, 'lower':None, 'upper':None, 'step':None}\n                    if node.slice.lower:\n                        msg['lower'] = self.visit(node.slice.lower)\n                    if node.slice.upper:\n                        msg['upper'] = self.visit(node.slice.upper)\n                    if node.slice.step:\n                        msg['step'] = self.visit(node.slice.step)\n\n                    if msg['step'] is None and (msg['value'] in self._known_strings or msg['value'] in self._global_types['string']):\n                        if msg['lower'] and msg['upper']:\n                            return '%s.substr(%s, %s)' %(msg['value'], msg['lower'], msg['upper'])\n                        elif msg['lower']:\n                            return '%s.substr(%s, %s.size()-1)' %(msg['value'], msg['lower'], msg['value'])\n                        else:\n                            return '%s.substr(0, %s)' %(msg['value'], msg['upper'])\n\n                    raise GenerateSlice( msg )\n\n                else:\n                    r = ' (*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n            else:\n                if self._cpp:\n                    ## default to deference shared pointer ##\n                    value = self.visit(node.value)\n                    is_tuple_index = isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.Set)\n\n                    if value in self._known_pointers:\n                        if is_tuple_index:\n                            r = 'std::get %s (*%s)' % (self.visit(node.slice.value.elts[0]), value)\n                        else:\n                            r = '(*%s)[%s]' % (value, self.visit(node.slice))\n                    elif self._memory[-1]=='STACK':\n                        if is_tuple_index:\n                            r = 'std::get %s (%s)' % (self.visit(node.slice.value.elts[0]), value)\n                        else:\n                            r = '%s[%s]' % (value, self.visit(node.slice))\n                    else:\n                        if is_tuple_index:\n                            r = 'std::get %s (*%s)' % (self.visit(node.slice.value.elts[0]), value)\n                        else:\n                            r = '(*%s)[%s]' % (value, self.visit(node.slice))\n\n                    #############################################\n                    if value.startswith('PyObject_GetAttrString(') and value.endswith(')'):\n                        r = 'PyObject_CallFunction(PyObject_GetAttrString(%s, __getitem__ ), i , %s)' % (value, self.visit(node.slice))\n\n                    elif isinstance(node.value, ast.Name):\n                        target = node.value.id\n                        is_neg = False\n                        if isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.Num) and node.slice.value.n   0:\n                            is_neg = True\n\n                        if self._function_stack:\n                            if target in self._known_strings:\n                                if is_neg:\n                                    r = '%s.substr(%s.size()%s,1)' %(target, target,self.visit(node.slice))\n                                else:\n                                    r = '%s.substr(%s,1)' %(target, self.visit(node.slice))\n                        ## need to also check if the target name is a global string ##\n                        if target in self._global_types['string']:\n                            if is_neg:\n                                r = '%s.substr(%s.size()%s,1)' %(target, target,self.visit(node.slice))\n                            else:\n                                r = '%s.substr(%s,1)' %(target, self.visit(node.slice))\n\n                elif self._rust:\n                    r = '%s.borrow_mut()[%s]' % (self.visit(node.value), self.visit(node.slice))\n                else:\n                    r = '(*%s)[%s]' % (self.visit(node.value), self.visit(node.slice))\n\n            ## TODO: subclass generics for arrays\n            #if isinstance(node.value, ast.Name) and node.value.id in self._known_generics_arrays:\n            #   target = node.value.id\n            #   #value = self.visit( node.value )\n            #   cname = self._known_arrays[target]\n            #   #raise GenerateGenericSwitch( {'target':target, 'value':r, 'class':cname} )\n            #   raise GenerateGenericSwitch( {'value':r, 'class':cname} )\n\n            return r", 
            "title": "Subscript a[n]"
        }, 
        {
            "location": "/cpprustbase/#call-functionmethod", 
            "text": "handles all special calls  \n    def _visit_call_helper(self, node, force_name=None):\n        fname = force_name or self.visit(node.func)\n        if fname =='cdef':\n            s = node.args[0].s\n            varname = s.split('=')[0].split()[-1]\n            if varname.startswith('*'):\n                varname = varname.split('*')[-1]\n            elif varname.startswith(' '):\n                varname = varname.split(' ')[-1]\n\n            self._known_vars.add(varname)\n            if varname in self._vars:\n                self._vars.remove(varname)\n\n            return s\n\n        elif fname=='__array__':\n            if len(node.args)==4:\n                aname  = self.visit(node.args[0])\n                asize  = self.visit(node.args[1])\n                atype = self.visit(node.args[2])\n                ainit = self.visit(node.args[3])\n                self._known_arrays[aname] = (atype, asize)\n                return '%s %s[%s] = %s;' %(atype, aname, asize, ainit)\n            else:\n                raise SyntaxError(self.format_error('invalid __array__'))\n\n        elif self._cpp and fname=='move':\n            args = ','.join([self.visit(arg) for arg in node.args])\n            return 'std::move(%s)' %args\n\n        elif self._cpp and fname=='complex':\n            args = ','.join([self.visit(arg) for arg in node.args])\n            return 'std::complex double (%s)' %args\n\n        elif self._cpp and fname in self._typedefs:\n            typedef = self._typedefs[fname]\n            args = ','.join([self.visit(arg) for arg in node.args])\n            if typedef.startswith('tuple('):\n                if self._memory[-1]=='STACK':\n                    return 'std::make_tuple(%s)' %args\n                else:\n                    return '/*typedef: %s*/[ ](){auto _ = std::make_tuple(%s); return std::make_shared decltype(_) (_);}()' %(typedef,args)\n            #elif typedef.startswith('std::shared_ptr std::vector ') and args:\n            elif typedef.startswith('std::vector ') and not args:\n                if typedef=='std::vector tuple ':\n                    return '/*typedef-tuple-array:%s*/%s(%s)' %(typedef, fname, args)  ## requires `new` ?\n                else:\n                    subtype = typedef.split(' ')[-1].split(' ')[0]\n                    if subtype in self._typedefs:\n                        subsubtype = self._typedefs[subtype]\n                        if subsubtype.startswith('tuple('):\n                            for tsub in subsubtype[len('tuple('):-1].split(','):\n                                if tsub in self._typedefs:\n                                    tsubtype = self._typedefs[tsub]\n                                    if tsubtype.startswith('tuple('):\n                                        raise SyntaxError(self.format_error('TRANSLATION-ERROR: an array of nested tuple of tuples, must be constructed with at least one item.'))\n                    return '/*typedef-array:%s*/%s(%s)' %(typedef, fname, args)  ## requires `new` ?\n\n            elif typedef.startswith('std::vector ') and args:\n                args = [self.visit(arg) for arg in node.args]\n                assert args[0].startswith('new std::vector ')\n                tvectype = args[0].split('{')[0][4:]\n                hacked_args = []\n                for arg in args:\n                    if arg.startswith('new '):\n                        arg = arg[4:]\n                    hacked_args.append(arg)\n                return '/*typedef: %s*/std::make_shared %s (%s)' %(typedef, tvectype, ','.join(hacked_args))\n            else:\n                return '/*typedef:%s*/%s(%s)' %(typedef, fname, args)  ## requires `new` ?\n\n        elif self._cpp and fname =='tuple- get':\n            return 'std::get %s (*%s)' %(self.visit(node.args[1]), self.visit(node.args[0]))\n\n        elif self._cpp and fname == 'tuple.get':\n            return 'std::get %s (%s)' %(self.visit(node.args[1]), self.visit(node.args[0]))\n\n        elif self._cpp and fname == 'dict- keys':\n            if len(node.args) != 1:\n                raise SyntaxError(self.format_error('dict.keys(mymap) requires a single argument'))\n\n            arrname = self.visit(node.args[0])\n            vectype = 'std::vector decltype(%s)::element_type::key_type ' %arrname\n            r = [\n                '[ %s](){' %arrname,\n                'auto __ = std::make_shared %s (%s());' %(vectype,vectype),\n                'for (const auto  _ : *%s) {' %arrname,\n                '__- push_back(_.first);',\n                '}',\n                'return __;}()'\n            ]\n            return ''.join(r)\n\n        elif self._cpp and fname == 'dict- values':\n            if len(node.args) != 1:\n                raise SyntaxError(self.format_error('dict.values(mymap) requires a single argument'))\n\n            arrname = self.visit(node.args[0])\n            vectype = 'std::vector decltype(%s)::element_type::mapped_type ' %arrname\n            r = [\n                '[ %s](){' %arrname,\n                'auto __ = std::make_shared %s (%s());' %(vectype,vectype),\n                'for (auto  _ : *%s) {' %arrname,\n                '__- push_back(_.second);',\n                '}',\n                'return __;}()'\n            ]\n            return ''.join(r)\n\n        elif fname=='future':\n            if not len(self._function_stack):\n                raise SyntaxError('future() call used at global level')\n            elif not self._function_stack[-1].return_type.startswith('future '):\n                raise SyntaxError('expected future T  return type, instead got: %s' %self._function_stack[-1].return_type )\n\n            args = ','.join([self.visit(arg) for arg in node.args])\n            ftemplate = self._function_stack[-1].return_type.replace('future', 'make_ready_future')\n            return '%s(%s)' %(ftemplate, args)\n\n        elif fname in self.macros:\n            macro = self.macros[fname]\n            if '%=' in macro:  ## advanced meta programming, captures the name of the variable the macro assigns to.\n                if not self._assign_var_name:\n                    raise RuntimeError('the macro syntax `%=` can only be used as part of an assignment expression')\n                macro = macro.replace('%=', self._assign_var_name)\n\n            args = ','.join([self.visit(arg) for arg in node.args])\n            if ' %s ' in macro:\n                return macro % tuple([s.s for s in node.args])\n            elif '%s' in macro:\n                if macro.count('%s') 1:\n                    args = tuple([self.visit(s) for s in node.args])\n                try:\n                    return macro % args\n                except TypeError as err:\n                    raise RuntimeError('%s\\nMACRO:\\t%s\\nARGS:\\t%s' %(err[0], macro, args))\n\n            else:\n                return '%s(%s)' %(macro,args)\n\n        if self._stack and fname in self._classes and not isinstance(self._stack, ast.Assign):\n            node.is_new_class_instance = True\n\n        is_append = False\n        if fname.endswith('.append'): ## TODO - deprecate append to pushX or make `.append` method reserved by not allowing methods named `append` in visit_ClassDef?\n            is_append = True\n            arr = fname.split('.append')[0]\n\n        if fname.endswith('- __exec__'):\n            fname = fname.replace('- __exec__', '- exec')\n\n        ###########################################\n        if fname == 'macro':\n            if node.keywords:\n                r = []\n                for kw in node.keywords:\n                    r.append('#define %s %s' %(kw.arg, self.visit(kw.value)))\n                return '\\n'.join(r) + '//;'\n            else:\n                return '%s //;' %node.args[0].s\n        elif fname == 'pragma':\n            return '#pragma %s //;' %node.args[0].s\n        elif fname == 'addr':\n            return ' %s' %self.visit(node.args[0])\n        elif fname.startswith('PyObject_GetAttrString') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_pyobjects:\n            return self.gen_cpy_call(node.func.value.id, node)  ## TODO test this\n        elif fname.startswith('PyObject_GetAttrString(') and fname.endswith(')') and isinstance(node.func, ast.Attribute):\n            return self.gen_cpy_call(fname, node)\n\n        elif fname.endswith('.split') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_strings:\n            splitchar = 'std::string(   )'\n            if len(node.args): splitchar = self.visit(node.args[0])\n            return '__split_string__( %s, %s )' %(node.func.value.id, splitchar)\n        elif fname.endswith('.lower') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_strings:\n            return '__string_lower__(%s)' %node.func.value.id\n        elif fname.endswith('.upper') and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, ast.Name) and node.func.value.id in self._known_strings:\n            return '__string_upper__(%s)' %node.func.value.id\n\n        elif fname.startswith('nuitka- '):\n            fname = fname.split('nuitka- ')[-1]\n            r = [\n                'GET_STRING_DICT_VALUE(',\n                ' moduledict___main__,',\n                '(Nuitka_StringObject *) %s  )' %fname\n            ]\n            return '\\n'.join(r)\n\n        elif fname.startswith('cpython- '):\n            n = fname.split('cpython- ')[-1]\n            if n == 'initalize':\n                return '__cpython_initalize__()'\n            elif n == 'finalize':\n                return '__cpython_finalize__(%s)' %self.visit(node.args[0])\n            else:\n                c = '__cpython_get__( %s )' %n\n                return self.gen_cpy_call(c, node)\n\n        elif fname.startswith('nim- '):\n            if fname.endswith('main'):\n                return 'PreMain(); NimMain()'\n            #elif fname.endswith('unref'):  ## GC_ref is called from nim code, its not part of the NIM C API?\n            #   return 'GC_unref(%s)' %self.visit(node.args[0])\n            #elif fname.endswith('ref'):\n            #   return 'GC_ref(%s)' %self.visit(node.args[0])\n            else:\n                raise RuntimeError('unknown nim api function')\n\n        elif fname=='jvm':\n            classname = node.args[0].func.id\n            args = [self.visit(arg) for arg in node.args[0].args]\n\n            ## using make_shared is safer and is only a single allocation, but it crashes g++4.7\n            #return 'std::make_shared %s (%s)'%(classname,','.join(args))\n\n            ## this is slower because it makes two allocations, and if allocation of shared_ptr\n            ## fails, then the object could be leaked.  using this for now because it works with g++4.7\n            if classname in self._jvm_classes:\n                ## Rusthon class that subclass from Java classes (decorated with @jvm)\n                return 'std::shared_ptr %s ((new %s(__javavm__))- __init__(%s))'%(classname, classname,','.join(args))\n            else:\n                ## Java class ##\n                args.insert(0, '__javavm__') ## global JavaVM instance\n                if len(args) 1:\n                    raise RuntimeError('Giws as of feb21.2015, is missing support for constructor arguments')\n                return 'std::shared_ptr %s (new %s(%s))'%(classname, classname,','.join(args))\n\n\n        elif fname=='jvm- create':  ## TODO - test multiple vms\n            return '__create_javavm__();'\n        elif fname=='jvm- load':\n            if node.args[0].s not in self._java_classpaths:\n                self._java_classpaths.append(node.args[0].s)\n            return ''\n        elif fname=='jvm- namespace':  ## giws squashes the name space from `org.x.y` to `org_x_y`\n            s = node.args[0].s\n            return 'using namespace %s;' %s.replace('.', '_')\n            #ns = []\n            #nspath = s.split('.')\n            #for i,a in enumerate(nspath):\n            #   if i==len(nspath)-1:\n            #       ns.append('::'+a)\n            #   else:\n            #       ns.append(a+'_')\n            #raise SyntaxError(ns)\n        elif fname=='namespace':\n            return 'using namespace %s;' %node.args[0].s\n        elif fname=='weak- unwrap':\n            ## this is needed for cases where we do not know if its a weakptr, `self.a.b.c.parent`,\n            ## it is also useful for the user to simply make their code more clear.\n            w = self.visit(node.args[0])\n            lock_name = 'lock'\n            if self.usertypes and 'weakref' in self.usertypes:\n                lock_name = self.usertypes['weakref']['lock']\n            if not w.endswith('.%s()'%lock_name): w += '.%s()' %lock_name\n            return w\n\n        elif fname=='weak- valid':\n            ## this is needed for cases where we do not know if its a weakptr, `self.a.b.c.parent`,\n            ## it is also useful for the user to simply make their code more clear.\n            w = self.visit(node.args[0])\n            if self.usertypes and 'weakref' in self.usertypes:\n                return '%s.%s()' %(w,self.usertypes['weakref']['valid'])\n            else:\n                return '%s != nullptr' %w\n\n        elif fname.endswith('.insert') and fname.split('.insert')[0] in self._known_arrays and len(node.args) =2:\n            arr = fname.split('.insert')[0]\n            idx = self.visit(node.args[0])\n            val = self.visit(node.args[1])\n\n            if len(node.args)==2:\n                #if '.' in val and arr == val.split('.')[0] and 'pop' in val:  ## TODO\n                if '- ' in val and arr == val.split('- ')[0] and 'pop' in val:\n                    popidx = None\n                    r = []\n                    if val.endswith('pop_back()'):\n                        #popidx = '%s- size()-1' %arr\n                        popidx = '%s-1' %self._known_arrays[arr][1]\n                        r.append('auto __back__ = %s[%s];' %(arr,popidx))\n                        r.extend([  ## move elements forward starting from back\n                            self.indent()+'for (int __i=%s; __i %s; __i--) {' %(popidx, idx),\n                            self.indent()+'  %s[__i] = %s[__i-1];' %(arr, arr),\n                            self.indent()+'}'\n                        ])\n                        r.append(self.indent()+'%s[%s] = __back__;' %(arr, idx))\n\n                    else:\n                        popidx = val.split('(')[-1].split(')')[0].strip()\n                        assert popidx == '0' ## TODO other indices\n                        r.append('auto __front__ = %s[%s];' %(arr,popidx))\n                        r.extend([  ## move elements forward starting from insert idx\n                            self.indent()+'for (int __i=1; __i =%s; __i++) {' %idx,\n                            self.indent()+'  %s[__i-1] = %s[__i];' %(arr, arr),\n                            self.indent()+'}'\n                        ])\n                        r.append(self.indent()+'%s[%s] = __front__;' %(arr, idx))\n\n\n                    return '\\n'.join(r)\n\n                else:\n                    raise SyntaxError('fixed size stack allocated arrays can not use iterators to insert elements from another array')\n\n            elif len(node.args)==3:\n                end = self.visit(node.args[2])\n                return '%s.insert(%s, %s, %s)' %(arr, idx, val, end)\n\n            else:\n                raise RuntimeError('TODO .insert(...)')\n\n\n        elif fname.endswith('- insert') and fname.split('- insert')[0] in self._known_arrays and len(node.args) =2:\n            arr = fname.split('- insert')[0]\n            idx = self.visit(node.args[0])\n            val = self.visit(node.args[1])\n            if len(node.args)==2:\n                #if '- ' in val and arr == val.split('- ')[0] and 'pop' in val:\n                #   if val.endswith('pop_back()'):\n                #       popidx = '%s- size()-1' %arr\n                #   else:\n                #       popidx = val.split('(')[-1].split(')')[0]\n\n                if '- begin()' in idx:\n                    return '%s- insert(%s, %s)' %(arr, idx, val)\n                else:\n                    return '%s- insert(%s- begin()+%s, %s)' %(arr, arr, idx, val)\n                #else:\n                #   return '%s- insert(%s+%s, %s)' %(arr, arr, idx, val)\n            elif len(node.args)==3:\n                end = self.visit(node.args[2])\n                return '%s- insert(%s, %s, %s)' %(arr, idx, val, end)\n\n            else:\n                raise RuntimeError('TODO .insert(...)')\n\n        elif fname == 'double' and self._cpp:\n            return '__double__(%s)' %self.visit(node.args[0])\n\n        elif fname == 'clock' and len(node.args)==0:\n            ## note in c++ std::clock returns clock ticks, not time\n            return '__clock__()'\n\n        elif fname == '__asm__':\n            ASM_WRITE_ONLY = '='  ## write constraint\n            ASM_ANY_REG    = 'r'  ## register name: r, eax, ax, al,  ebx, bx, bl\n            ASM_OUT_DEFAULT = ASM_WRITE_ONLY + ASM_ANY_REG\n\n            code = []\n            if self._cpp:\n                code.append('asm')\n            else:\n                # http://doc.rust-lang.org/guide-unsafe.html#inline-assembly\n                code.append('unsafe{ asm!')\n\n            volatile = False\n            alignstack = False\n            outputs = []\n            inputs = []\n            clobber = []\n            asmcode = None\n            for kw in node.keywords:\n                if kw.arg == 'volatile' and kw.value.id.lower()=='true':\n                    volatile = True\n                elif kw.arg == 'alignstack' and kw.value.id.lower()=='true':\n                    alignstack = True\n                elif kw.arg == 'outputs':\n                    write_mode = ASM_OUT_DEFAULT\n                    if isinstance(kw.value, ast.List):\n                        mode = kw.value.elts[0].s\n                        output = kw.value.elts[1].id\n                        outputs.append(' %s  (%s)' %(mode, output))\n                    else:\n                        outputs.append(' %s  (%s)' %(write_mode, kw.value.id))\n\n                elif kw.arg == 'inputs':\n                    if isinstance(kw.value, ast.List) or isinstance(kw.value, ast.Tuple):\n                        for elt in kw.value.elts:\n                            if isinstance(elt, ast.List):\n                                register = elt.elts[0].s\n                                input = elt.elts[1].id\n                                inputs.append(' %s  (%s)' %(register, input))\n                            else:\n                                inputs.append(' %s  (%s)' %(ASM_ANY_REG,elt.id))\n                    else:\n                        inputs.append(' %s  (%s)' %(ASM_ANY_REG,kw.value.id))\n                elif kw.arg == 'clobber':\n                    if isinstance(kw.value, ast.List) or isinstance(kw.value, ast.Tuple):\n                        clobber.extend( [' %s ' %elt.s for elt in kw.value.elts] )\n                    else:\n                        clobber.extend(\n                            [' %s '%clob for clob in kw.value.s.split(',') ]\n                        )\n\n                elif kw.arg == 'code':\n                    asmcode = ' %s ' %kw.value.s\n\n            if volatile:\n                if self._cpp:\n                    code.append( 'volatile' )\n\n            assert asmcode\n            if not self._cpp:\n                ## rust asm uses llvm as its backend,\n                ## llvm asm syntax is slightly different from regular gcc,\n                ## input arguments in gcc are given as `%N`,\n                ## while in llvm they are given as `$N`\n                asmcode = self._gccasm_to_llvmasm(asmcode)\n\n            code.append( '(' )\n            code.append( asmcode )\n            code.append( ':' )\n            if outputs:\n                code.append( ','.join(outputs) )\n            code.append( ':' )\n            if inputs:\n                code.append( ','.join(inputs) )\n            code.append( ':' )\n            if clobber:\n                code.append( ','.join(clobber) )\n\n            if self._cpp:\n                code.append( ');')\n            else:\n                code.append( ':' )  ## rust options\n                ropts = []\n                if volatile:\n                    ropts.append(' volatile ')\n                if alignstack:\n                    ropts.append(' alignstack ')\n\n                code.append( ','.join(ropts) )\n                code.append( '); } // end unsafe' )\n\n\n            return ' '.join( code )\n\n        elif fname == '__let__':\n            vname = None\n            infer_from = None\n            if len(node.args) and isinstance(node.args[0], ast.Name):\n                vname = node.args[0].id\n            elif len(node.args)==2 and isinstance(node.args[0], ast.Call):\n                ## syntax: `let foo(bar) : SomeClass`, translates into c++11 universal constructor call\n                ## used when using classes from external libraries.\n                assert self._cpp\n                if isinstance(node.args[1], ast.Str):\n                    T = node.args[1].s\n                else:\n                    T = self.visit(node.args[1])\n\n                return '%s %s' %(T, self.visit(node.args[0]))\n\n\n            elif len(node.args) and isinstance(node.args[0], ast.Attribute): ## syntax `let self.x:T = y`\n                assert node.args[0].value.id == 'self'\n                T = None\n                if isinstance(node.args[1], ast.Str):\n                    T = node.args[1].s\n                else:\n                    T = self.visit(node.args[1])\n\n                if len(node.args)==2:\n                    #raise SyntaxError(','.join([self.visit(a) for a in node.args]))\n                    if T.startswith('['):\n                        if self._memory[-1]=='HEAP':\n                            x,y = T.split(']')\n                            n = x.split('[')[-1]\n                            return 'this- %s = std::make_shared std::vector %s (%s);' %(node.args[0].attr, y, n)\n\n                        else:\n                            return '/* %s : %s */' %(node.args[0].attr, T)\n\n\n                value = self.visit(node.args[2])\n\n                if isinstance(node.args[2], ast.Dict):\n                    assert T.startswith('__go__map__')\n                    d = node.args[2]\n                    mtypek = self.visit(node.args[1].args[0])\n                    mtypev = self.visit(node.args[1].args[1])\n                    if mtypev.startswith('{') or '{' in mtypev:\n                        raise RuntimeError(mtypev)\n                    value = '(new std::map %s, %s )' %(mtypek, mtypev)\n                    #raise SyntaxError(value)\n                if self._cpp:\n                    return 'this- %s = %s' %(node.args[0].attr, self.visit(node.args[2]))\n                else:\n                    return '%s = %s' %(self.visit(node.args[0]), self.visit(node.args[2]))\n\n            else:\n                assert node.keywords\n                for kw in node.keywords:\n                    if kw.arg=='mutable': continue\n                    else:\n                        vname = kw.arg\n                        infer_from = kw.value  ## TODO need way to infer types for c++ backend\n\n            if self._function_stack:\n                self._known_vars.add( vname )\n                if vname in self._vars:\n                    self._vars.remove( vname )\n                V = 'let'\n            else:\n                V = 'static'\n\n            mutable = False\n            for kw in node.keywords:\n                if kw.arg=='mutable':\n                    if kw.value.id.lower()=='true':\n                        mutable = True\n\n            if len(node.args) == 0:\n                if self._cpp:\n                    return 'auto %s = %s' %(vname, self.visit(infer_from))\n                else:\n                    if mutable:\n                        return '%s mut %s = %s' %(V, vname, self.visit(infer_from))\n                    else:\n                        return '%s %s = %s' %(V, vname, self.visit(infer_from))\n\n            elif len(node.args) == 1:\n                return '%s %s           /* declared - rust maybe able to infer the type */' %(V, node.args[0].id)\n            elif len(node.args) == 2:\n                if self._cpp:\n                    is_array = False\n                    if isinstance(node.args[1], ast.Str):\n                        T = node.args[1].s\n                        if '__go__array__(' in T:\n                            is_array = True\n                            dims = T.count('__go__array__')\n                            atype = T.split('(')[-1]\n                            if not self.is_prim_type(atype):\n                                atype = 'std::shared_ptr %s ' %atype\n\n                            if dims==1:\n                                T = 'std::vector %s ' %atype\n                            else:\n                                raise RuntimeError(T)  ## TODO\n\n                            ## note: if a shared_ptr is created on the stack without\n                            ## std::make_shared it will print as `0`\n                            ## and if not initalized with data, will segfault if push_back is called.\n                            ## return '%s  %s' %(T, node.args[0].id)\n                            return 'auto %s = std::make_shared %s ()' %(node.args[0].id, T)\n\n                        elif T.startswith('[') and ']' in T:\n                            is_array = True\n                            x,y = T.split(']')\n                            alen = x.split('[')[-1].strip()\n\n                            self._known_arrays[node.args[0].id] = (y, alen)\n                            if not len(self._function_stack):\n                                self._global_arrays[node.args[0].id] = (y, alen)\n\n                            if self._memory[-1]=='STACK':\n                                ## note a fixed size C-array non-global `int myarr[N];` will not always\n                                ## allocate all items to zero or null. gcc4.9 bug?\n                                if alen.isdigit():\n                                    alen = int(alen)\n                                    if y in ('int', 'uint'):\n                                        return '%s %s%s] = {%s}' %(y, node.args[0].id, x, ','.join(['0']*alen))\n                                    elif self.is_prim_type(y):\n                                        return '%s %s%s] = {}' %(y, node.args[0].id, x)  ## TODO test if these are all init to null\n                                    elif y in self._classes:\n                                        return '%s %s%s] = {%s}' %(y, node.args[0].id, x, ','.join([y+'(false)']*alen))\n                                    else:\n                                        raise RuntimeError('TODO let...')\n\n                                return '%s %s%s]' %(y, node.args[0].id, x)\n                            else:\n                                if not self.is_prim_type(y):\n                                    y = 'std::shared_ptr %s ' %y\n                                return 'auto %s = std::make_shared std::vector %s (%s)' %(node.args[0].id, y, alen)\n\n\n                    else:\n                        T = node.args[1].id\n\n                    if self.is_prim_type(T) or T.endswith('*') or T.endswith(' ') or self._memory[-1]=='STACK':\n                        return '%s  %s' %(T, node.args[0].id)\n                    else:\n                        if not self._shared_pointers:\n                            return '%s*  %s' %(T, node.args[0].id)\n                        elif self._unique_ptr:\n                            return 'std::unique_ptr %s   %s' %(T, node.args[0].id)\n                        else:\n                            return 'std::shared_ptr %s   %s' %(T, node.args[0].id)\n                else:\n                    varname = node.args[0].id\n                    typename = None\n                    if isinstance(node.args[1], ast.Str):\n                        typename = node.args[1].s\n                    else:\n                        typename = node.args[1].id\n\n                    if mutable:\n                        return '%s mut %s : %s' %(V, varname, typename)\n                    else:\n                        return '%s %s : %s' %(V, varname, typename)\n\n            elif len(node.args) == 3:\n                if self._cpp:\n                    if isinstance(node.args[1], ast.Name):\n                        T = node.args[1].id\n                    else:\n                        T = node.args[1].s\n                    T = T.strip()\n                    if self.is_prim_type(T) or T.endswith(' ') or isinstance(node.args[2], ast.Set):\n                        if T.endswith(' '):\n                            ## http://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object\n                            ## TODO is using `const T ` safer?\n                            #T = 'const '+T  ## this also works\n                            ## strip away ` `\n                            T = T[:-1]\n                        varname = node.args[0].id\n                        if '*' in T:\n                            varname += '[]' * T.count('*')\n                            if T=='const char*':\n                                self._force_cstr = True\n                        data = self.visit(node.args[2])\n                        self._force_cstr = False\n\n                        return '%s  %s = %s' %(T, varname, data)\n                    else:\n                        if self._memory[-1]=='STACK':\n                            value = self.visit(node.args[2])\n                            if value == 'nullptr' and not T.endswith('*'):\n                                value = T + '(false)'  ## special case, construct the class to act like `None`\n                            return '%s  %s = %s' %(T, node.args[0].id, value)\n                        elif not self._shared_pointers:\n                            self._known_pointers[node.args[0].id] = T\n                            if not len(self._function_stack):\n                                self._globals[node.args[0].id] = T + '*'\n                            return '%s*  %s = %s' %(T, node.args[0].id, self.visit(node.args[2]))\n                        elif self._unique_ptr:\n                            return 'std::unique_ptr %s   %s = %s' %(T, node.args[0].id, self.visit(node.args[2]))\n                        else:\n                            return 'std::shared_ptr %s   %s = %s' %(T, node.args[0].id, self.visit(node.args[2]))\n                else:  ## rust\n                    if mutable:\n                        return '%s mut %s : %s = %s' %(V, node.args[0].id, node.args[1].s, self.visit(node.args[2]))\n                    else:\n                        return '%s %s : %s = %s' %(V, node.args[0].id, node.args[1].s, self.visit(node.args[2]))\n            else:\n                raise SyntaxError('TODO __let__ %s' %len(node.args))\n\n        elif fname == '__let__' and isinstance(node.args[0], ast.Attribute):\n            if isinstance(node.args[0].value, ast.Name) and node.args[0].value.id=='self':\n                if self._cpp:\n                    if self._memory[-1]=='STACK':\n                        return 'this.%s = %s' %(node.args[0].attr, self.visit(node.args[-1]))\n                    else:\n                        return 'this- %s = %s' %(node.args[0].attr, self.visit(node.args[-1]))\n                else:\n                    return 'self.%s = %s' %(node.args[0].attr, self.visit(node.args[-1]))\n\n        elif fname=='str' and not self._cpp:\n            if self._cpp:\n                #return 'static_cast std::ostringstream* (  (std::ostringstream()   %s) )- str()' %self.visit(node.args[0])\n                return 'std::to_string(%s)' %self.visit(node.args[0])  ## only works with number types\n            else:\n                return '%s.to_string()' %self.visit(node.args[0])\n\n        elif fname == 'range':\n            assert len(node.args)\n            if self._rust:  ## TODO - some syntax for mutable/immutable range\n                fname = ' mut ' + fname  ## default to mutable\n                fname += str(len(node.args))\n            else:\n                assert self._cpp\n                fname += str(len(node.args))\n                if self._memory[-1]=='STACK':\n                    fname = '__%s__' %fname\n\n        elif fname == 'len':\n            if self._cpp:\n                arg = self.visit(node.args[0])\n                if arg in self._known_strings:\n                    if self.usertypes and 'string' in self.usertypes:\n                        return '%s.%s()' %(arg, self.usertypes['string']['len'])\n                    else:\n                        return '%s.size()' %arg\n                elif arg.startswith('PyObject_GetAttrString(') and arg.endswith(')'):\n                    return '(long)PySequence_Length(%s)' %arg\n                elif self._memory[-1]=='STACK':\n                    if arg in self._known_arrays and isinstance(self._known_arrays[arg], tuple):\n                        return self._known_arrays[arg][1]\n                    elif arg in self._known_pointers:\n                        return '%s- size()' %arg\n                    else:\n                        return '%s.size()' %arg\n                elif self.usertypes and 'vector' in self.usertypes:\n                    return '%s- %s()' %(arg, self.usertypes['vector']['len'])\n                else:\n                    return '%s- size()' %arg\n            else:\n                return '%s.borrow().len()' %self.visit(node.args[0])\n\n        elif fname == 'float':\n            if self._cpp or self._rust:\n                return '__float__(%s)'%self.visit(node.args[0])\n            else:\n                raise SyntaxError( TODO float builtin )\n\n        elif fname == '__open__':\n            if self._cpp:\n                if len(node.args) == 2:\n                    return '__open__(%s, %s)' % (self.visit(node.args[0]), self.visit(node.args[1]))\n                else:\n                    return '__open__(%s, std::string( rb ))' % self.visit(node.args[0])\n\n            else:\n                return 'File::open_mode(  Path::new(%s.to_string()), Open, Read )' %self.visit(node.args[0])\n\n        elif fname == '__arg_array__':\n            assert len(node.args)==1\n            T = self.parse_go_style_arg(node.args[0])\n            if self._rust:\n                if self.is_prim_type(T):\n                    #return ' mut Vec %s ' %T\n                    return 'Rc RefCell  Vec %s   ' %T\n                else:\n                    #return ' mut Vec mut %s ' %T  ## old ref style\n                    return 'Rc RefCell  Vec Rc RefCell %s   ' %T\n\n            elif self._cpp:\n                if self.is_prim_type(T):\n                    if not self._shared_pointers:\n                        return 'std::vector %s *' %T\n                    elif self._unique_ptr:\n                        return 'std::unique_ptr std::vector %s ' %T\n                    else:\n                        return 'std::shared_ptr std::vector %s ' %T\n                else:\n                    if not self._shared_pointers:\n                        return 'std::vector %s* *' %T\n                    elif self._unique_ptr:\n                        return 'std::unique_ptr std::vector  std::unique_ptr %s   ' %T\n                    else:\n                        return 'std::shared_ptr std::vector  std::shared_ptr %s   ' %T\n            else:\n                raise RuntimeError('TODO generic arg array')\n\n        elif fname == '__arg_map__':\n            parse = node.args[0].s\n            assert parse.startswith('map[')\n            key_type = parse.split('[')[-1].split(']')[0]\n            value_type = parse.split(']')[-1]\n            if key_type=='string': key_type = 'std::string'\n            if value_type=='string': value_type = 'std::string'\n            return 'std::shared_ptr std::map %s, %s ' %(key_type, value_type)\n\n\n        if node.args:\n            #args = [self.visit(e) for e in node.args]\n            #args = ', '.join([e for e in args if e])\n            args = []\n            for e in node.args:\n                if self._rust and isinstance(e, ast.Name) and e.id in self._known_arrays:\n                    args.append( e.id+'.clone()' )  ## automatically clone known array Rc box\n                elif isinstance(e, ast.Call) and isinstance(e.func, ast.Attribute) and isinstance(e.func.value, ast.Name) and e.func.value.id in self._known_arrays and e.func.attr=='clone':\n                    if self._rust:\n                        args.append( e.func.value.id+'.clone()' )   ## user called clone()\n                    else:\n                        args.append( e.func.value.id )              ## skip clone() for c++ backend\n                else:\n                    args.append( self.visit(e) )\n\n            args = ', '.join(args)\n\n        else:\n            args = ''\n\n        haskwargs = False\n        if node.keywords:\n            haskwargs = True\n            if args: args += ','\n\n            if self._rust:\n                raise RuntimeError( self.format_error('TODO calling a function named params for rust backend') )\n            elif self._cpp:\n                ## In the future we can easily optimize this away on plain functions,\n                ## because it is simple to lookup the function here, and see the order\n                ## of the named params, and then reorder the args here to bypass\n                ## creating a new `_KwArgs_` instance.\n                args += '(new _KwArgs_())'\n                for kw in node.keywords:\n                    args += '- %s(%s)' %(kw.arg,self.visit(kw.value))\n            else:\n                raise RuntimeError('TODO named params for some backend')\n\n        if node.starargs:\n            if args: args += ','\n            if self._cpp:\n                args += '(*%s)' %self.visit(node.starargs)\n            else:\n                args += '*%s...' %self.visit(node.starargs)\n\n\n        if hasattr(node, 'is_new_class_instance') and self._rust:\n            return 'Rc::new(RefCell::new( %s::new(%s) ))' % (fname, args)\n\n        elif self._cpp and fname in self._classes:\n            ## create class instance - new clean style - TODO deprecate all the old _ref_hacks ##\n            prefix = ''\n            if self.usertypes and 'shared' in self.usertypes:\n                prefix = self.usertypes['shared']['template'] % fname\n\n            elif self._memory[-1]=='STACK':\n                if self._classes[fname]._requires_init:\n                    return '%s().__init__(%s)' %(fname,args)\n                else:\n                    return '%s()' %fname\n\n            elif self._shared_pointers:\n                prefix = 'std::shared_ptr %s ' %fname\n            elif self._unique_ptr:\n                prefix = 'std::unique_ptr %s ' %fname\n\n            #########################################\n            if self._classes[fname]._requires_init:\n                if not isinstance(self._stack[-2], ast.Assign) and self._memory[-1]=='HEAP':\n                    if isinstance(self._stack[-2], ast.ListComp):\n                        return '%s((new %s())- __init__(%s))' %(prefix,fname,args)\n\n                    #elif self._assign_node:\n                    #   argname = '%s_%s' %(fname, int(id(node)))\n                    #   pre = 'auto %s = %s(new %s()); %s- __init__(%s);' %(argname,prefix,fname, argname,args)\n                    #   if not self._assign_pre:\n                    #       self._assign_pre.append(pre)\n                    #   elif pre not in self._assign_pre:\n                    #       self._assign_pre.append(pre)\n                    #   return argname\n                    #elif isinstance(self._stack[-2], ast.Call):\n                    #   print 'WARNING: object created without assignment to a variable'\n                    #   print fname\n                    #   print args\n                    #   return '%s((new %s())- __init__(%s))' %(prefix,fname,args)\n                    #elif isinstance(self._stack[-2], ast.Expr):\n                    #   argname = '%s_%s' %(fname, int(id(node)))\n                    #   pre = 'auto %s = %s(new %s()); %s- __init__(%s);' %(argname,prefix,fname, argname,args)\n                    #   return pre\n                    #elif isinstance(self._stack[-2], ast.Return):\n                    #   pass\n                    #else:\n                    #   raise SyntaxError(self.format_error('heap mode requires objects are assigned to variables on initialization: %s' %self._stack[-2]))\n\n                    #return '%s((new %s())- __init__(%s))' %(prefix,fname,args)\n\n                    ## wrap in lambda ##\n                    return '[ ](){auto _ = %s(new %s()); _- __init__(%s); return _;}()' %(prefix,fname,args)\n\n\n                else:\n                    #return '%s((new %s())- __init__(%s))' %(prefix,fname,args)\n                    return '[ ](){auto _ = %s(new %s()); _- __init__(%s); return _;}()' %(prefix,fname,args)\n\n            else:\n                return '%s(new %s())' %(prefix,fname)\n        else:\n            return '%s(%s)' % (fname, args)", 
            "title": "Call Function/Method"
        }, 
        {
            "location": "/cpprustbase/#binop", 
            "text": "Extra syntax is supported by  typedpython.md  using   and special names as a way of encoding syntax that \nregular Python has no support for.      def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n        try:\n            right = self.visit(node.right)\n        except GenerateListComp as err:\n            if isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id=='__go__array__':\n                node.right._comp_type = node.left.args[0].id\n                node.right._comp_dims = 1\n                raise err\n            elif isinstance(node.left, ast.BinOp) and isinstance(node.left.left, ast.Name) and node.left.left.id=='__go__array__':\n                node.right._comp_type = node.left.right.args[0].id\n                node.right._comp_dims = 2\n                raise err\n            else:\n                print node.left\n                print node.right\n                raise SyntaxError(self.format_error(err))\n\n        if op == ' ' and left == '__new__':\n            if self._cpp:\n                if isinstance(node.right, ast.Call) and isinstance(node.right.func, ast.Name):\n                    classname = node.right.func.id\n                    if classname in self._classes:\n                        if node.right.args:\n                            args = ','.join([self.visit(arg) for arg in node.right.args])\n                            return '(new %s)- __init__(%s)' %(classname, args)\n                        else:\n                            return '(new %s)- __init__()' %classname\n                    else:\n                        if node.right.args:\n                            args = ','.join([self.visit(arg) for arg in node.right.args])\n                            return '(new %s(%s))' %(classname, args)\n                        else:\n                            return '(new %s)' %classname\n\n                else:\n                    #raise SyntaxError(self.format_error(self.visit(node.right)))\n                    return '(new %s)' %self.visit(node.right)\n\n            else:\n                return ' new %s' %right\n\n        elif op == ' ':\n            go_hacks = ('__go__array__', '__go__arrayfixed__', '__go__map__', '__go__func__')\n\n            if isinstance(node.left, ast.Attribute) and node.left.attr=='__doubledot__':  ## this style is deprecated\n                if isinstance(node.right, ast.Call):\n                    return self.gen_cpy_call(self.visit(node.left.value), node.right)\n                    r = [\n                        'PyObject_Call(',\n                        '   PyObject_GetAttrString(%s, %s ),' %(self.visit(node.left.value), node.right.func.id),\n                        '   Py_BuildValue( () ),',\n                        '   NULL',\n                        ')'\n                    ]\n                    return '\\n'.join(r)\n\n                elif isinstance(node.right, ast.Name):\n                    return 'PyObject_GetAttrString(%s, %s )' %(self.visit(node.left.value), node.right.id)\n                elif isinstance(node.right, ast.Attribute) and node.right.attr=='__doubledot__':\n                    return 'PyObject_GetAttrString(%s, %s )' %(self.visit(node.left.value), self.visit(node.right.value))\n                else:\n                    raise SyntaxError(self.format_error('bad use of - '))\n\n            elif left in ('__go__receive__', '__go__send__'):\n                self._has_channels = True\n                if self._cpp:\n                    ## cpp-channel API\n                    return '%s.recv()' %right\n                elif self._rust:\n                    return '%s.recv().unwrap()' %right\n\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id in go_hacks:\n                if node.left.func.id == '__go__func__':\n                    raise SyntaxError('TODO - go.func')\n                elif node.left.func.id == '__go__map__':\n                    key_type = self.visit(node.left.args[0])\n                    value_type = self.visit(node.left.args[1])\n                    value_vec  = None\n                    if isinstance(node.left.args[0], ast.Str):\n                        key_type = node.left.args[0].s\n                        if key_type.startswith('['):\n                            raise SyntaxError(self.format_error('dictionary keys can not be a vector type'))\n\n                    if isinstance(node.left.args[1], ast.Str):\n                        value_type = node.left.args[1].s\n                        if value_type.startswith('[]'):\n                            value_vec = value_type.split(']')[-1]\n                            value_type = 'std::vector %s *' % value_vec\n                    elif isinstance(node.left.args[1], ast.Tuple):\n                        tupletype = []\n                        for telt in node.left.args[1].elts:\n                            if isinstance(telt, ast.Str):\n                                v = telt.s\n                                if v.startswith(' ') and v.endswith(' '):\n                                    v = v[1:-1]\n                            else:\n                                v = self.visit(telt)\n                            if v.startswith('[]'):\n                                t  = v.split(']')[-1]\n                                if self._memory[-1]=='STACK':\n                                    v = 'std::vector %s ' %t\n                                else:\n                                    v = 'std::vector %s *' %t\n\n                            tupletype.append(v)\n                        if self._memory[-1]=='STACK':\n                            value_type = 'std::tuple %s ' %','.join(tupletype)\n                        else:\n                            value_type = 'std::shared_ptr std::tuple %s ' %','.join(tupletype)\n                        #raise RuntimeError(value_type)\n\n                    #########################\n                    if key_type == 'string':\n                        key_type = 'std::string'\n\n                    if isinstance(node.right, ast.Dict):\n                        items = []\n                        for i in range( len(node.right.keys) ):\n                            k = self.visit(node.right.keys[i])\n                            v = self.visit(node.right.values[i])\n                            if v.startswith('[') and v.endswith(']'):\n                                v = ('new std::vector %s {'%value_vec) + v[1:-1] + '}'\n                            elif isinstance(node.right.values[i], ast.Tuple): #elif v.startswith('{') and v.endswith('}'):\n                                targs = []\n                                tuptargs = []\n                                for ti,te in enumerate(node.right.values[i].elts):\n                                    tt = tupletype[ti]\n                                    tv = self.visit(te)\n                                    if tv.startswith('[') and tv.endswith(']'):\n                                        assert tt.startswith('std::vector')\n                                        if tt.endswith('*'):\n                                            tv = '(new %s{%s})' %(tt[:-1], tv[1:-1])\n                                        else:\n                                            tv = '%s{%s}' %(tt, tv[1:-1])\n                                    targs.append(tv)\n\n                                if self._memory[-1]=='STACK':\n                                    v = 'std::make_tuple(%s)' %','.join(targs)\n                                else:\n                                    v = 'std::make_shared std::tuple %s (std::make_tuple(%s))' %(','.join(tupletype), ','.join(targs))\n\n                            items.append('{%s, %s}' %(k,v))\n\n                        right = '{%s}' %'\\n,'.join(items)\n\n                    if self._memory[-1]=='STACK':\n                        return 'std::map %s, %s %s' %(key_type, value_type, right)\n                    else:\n                        map_type = 'std::map %s,%s ' %(key_type, value_type)\n                        return 'std::shared_ptr %s (new %s%s)' %(map_type, map_type, right)\n                else:\n                    if isinstance(node.right, ast.Name):\n                        raise SyntaxError(node.right.id)\n\n                    right = []\n                    for elt in node.right.elts:\n                        if isinstance(elt, ast.Num) and self._rust:\n                            right.append( str(elt.n)+'i64' )\n                        else:\n                            right.append( self.visit(elt) )\n\n                    rargs = right[:]\n\n                    if self._rust:\n                        right = '(%s)' %','.join(right)\n                    elif self._cpp:\n                        right = '{%s}' %','.join(right)\n\n                    if node.left.func.id == '__go__array__':\n                        T = self.visit(node.left.args[0])\n                        if self._cpp:\n                            return ('std::vector %s '%T, rargs)   ## note special case, returns a tuple.\n\n                        elif self._rust:\n                            #return ' mut vec!%s' %right\n                            return 'Rc::new(RefCell::new(vec!%s))' %right\n\n                        else:\n                            raise RuntimeError('invalid backend')\n\n                    elif node.left.func.id == '__go__arrayfixed__':\n                        asize = self.visit(node.left.args[0])\n                        atype = self.visit(node.left.args[1])\n                        isprim = self.is_prim_type(atype)\n                        if self._cpp:\n                            return ('std::vector %s '%atype, asize, rargs) ## note special case, returns a tuple.\n                        elif self._rust:\n                            #return ' vec!%s' %right\n                            return 'Rc::new(RefCell::new(vec!%s))' %right\n                        else:\n                            raise RuntimeError('invalid backend')\n\n\n            elif isinstance(node.left, ast.Name) and node.left.id=='__go__array__':\n                if self._rust:\n                    raise RuntimeError('TODO array pointer')\n                    return ' mut Vec %s ' %self.visit(node.right)  ## TODO - test this\n                elif self._cpp:\n                    if not isinstance(node.right,ast.Call):\n                        raise RuntimeError('TODO mdarrays')\n\n                    mdtype = self.visit(node.right.args[0])\n                    if not self._shared_pointers:\n                        return 'std::vector std::vector %s * *'%mdtype\n                    elif self._unique_ptr:\n                        return 'std::unique_ptr std::vector  std::unique_ptr std::vector %s   '%mdtype\n                    else:\n                        return 'std::shared_ptr std::vector  std::shared_ptr std::vector %s   '%mdtype\n                else:\n                    raise RuntimeError('invalid backend')\n\n            elif isinstance(node.right, ast.Name) and node.right.id=='__as__':\n                if self._cpp:\n                    return self.visit(node.left)\n                else:\n                    return '%s as ' %self.visit(node.left)\n\n            elif isinstance(node.left, ast.BinOp) and isinstance(node.left.right, ast.Name) and node.left.right.id=='__as__':\n                #cast_to = right\n                cast_to = self.visit(node.right)\n                if isinstance(node.right, ast.Str):\n                    cast_to = node.right.s\n\n                if self._rust:\n                    return '%s %s' %(self.visit(node.left), cast_to)\n                else:\n                    ptr = self.visit(node.left.left)\n                    if cast_to in 'pystring pystr pyint pyi32 pylong pyi64 pyfloat pydouble pyf32 pyf64 pybool'.split():\n                        if cast_to=='pystring' or cast_to=='pystr':\n                            return 'PyString_FromString(%s.c_str())' %ptr\n                        elif cast_to in 'pyint pyi32 pylong pyi64'.split():\n                            return 'PyInt_FromLong(%s)' %ptr\n                        elif cast_to in 'pyfloat pyf32'.split():\n                            return 'PyFloat_FromDouble(%s)' %ptr\n                        else:\n                            raise RuntimeError('TODO as type: %s'%cast_to)\n\n                    elif self.is_prim_type(cast_to):\n                        if type(ptr) is tuple: ## this is probably a bug\n                            ptr = ptr[0]\n                        if ptr.startswith('PyObject_GetAttrString') or ptr.startswith('PyObject_Call'):\n                            if cast_to == 'int':\n                                return 'static_cast %s (PyInt_AS_LONG(%s))' %(cast_to, ptr)\n                            elif cast_to in ('float','f32'):\n                                return 'static_cast %s (PyFloat_AsDouble(%s))' %(cast_to, ptr)\n                            elif cast_to in ('double','f64'):\n                                return 'PyFloat_AsDouble(%s)' %ptr\n                            elif cast_to == 'string':\n                                return 'std::string(PyString_AS_STRING(%s))' %ptr\n                            elif cast_to == 'bool':\n                                return '(%s==Py_True)' %ptr\n                            else:\n                                raise RuntimeError('TODO other cast to types for cpython')\n                        else:\n                            return 'static_cast %s (%s)' %(cast_to, self.visit(node.left.left))\n                    elif self._memory[-1]=='STACK':\n                        cast_from = self.visit(node.left.left)\n                        if isinstance(node.left.left, ast.Str):  ## allow quoted cast to with `as`\n                            cast_from = node.left.left.s\n\n                        if cast_from in self._known_refs:\n                            raise RuntimeError(cast_from)\n                        if self._function_stack:\n                            fnode = self._function_stack[-1]\n                            if fnode.return_type==cast_to:  ## TODO check is node above is ast.Return\n                                return 'static_cast %s (%s)' %(cast_to, cast_from)\n\n                        return 'static_cast %s (%s)' %(cast_to, self.visit(node.left.left))\n\n                    elif self._polymorphic:\n                        return 'std::dynamic_pointer_cast %s (%s)' %(cast_to, self.visit(node.left.left))\n                    else:\n                        return 'std::static_pointer_cast %s (%s)' %(cast_to, self.visit(node.left.left))\n\n            elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name) and node.left.func.id=='inline':\n                return '%s%s' %(node.left.args[0].s, right)\n            else:\n                ## TODO this is hackish\n                if type(left) is tuple:\n                    raise RuntimeError(left)\n                atype = left.split(' ')[-1].split(' ')[0]\n                if isinstance(node.right, ast.Tuple):\n                    r = ['new std::vector %s  %s' %(atype, self.visit(elt)) for elt in node.right.elts]\n                    right = '{%s}' %','.join(r)\n                return (left, right)  ## special case for new arrays\n\n\n        if left in self._typed_vars and self._typed_vars[left] == 'numpy.float32':  ## deprecated\n            left += '[_id_]'\n        if right in self._typed_vars and self._typed_vars[right] == 'numpy.float32':  ## deprecated\n            right += '[_id_]'\n\n        #if op==' ':\n        #   #raise SyntaxError(type(node.left))\n        #   raise SyntaxError(left+right)\n        if left in self._known_instances:\n            left = '*'+left\n\n        return '(%s %s %s)' % (left, op, right)\n\n    def visit_ListComp(self, node):\n        #raise RuntimeError('list comps are only generated from the parent node')\n        raise GenerateListComp(node)", 
            "title": "BinOp"
        }, 
        {
            "location": "/cpprustbase/#return", 
            "text": "TODO remove GenerateTypeAssert, go leftover.\nTODO tuple return for c++  \n    #def visit_Num(self, node):\n    #   return node.n\n\n    def visit_Raise(self, node):\n        if self._rust:\n            return 'panic!( %s );'  % self.visit(node.type)\n        elif self._cpp:\n            if isinstance(node.type, ast.Call) and node.type.keywords:\n                self._has_rebuild = True\n                args = []\n                for k in node.type.keywords:\n                    args.append( self.visit(k.value) + ' /*%s*/'%k.arg )\n                return '__request_rebuild( %s );' %','.join(args)\n            else:\n                T = self.visit(node.type)\n                return 'throw %s;' % T\n        else:\n            raise RuntimeError('unknown backend')\n\n\n    def visit_Return(self, node):\n        assert not self._cpp  ## cpptranslator.md overrides this\n        if isinstance(node.value, ast.Tuple):\n            return 'return %s;' % ', '.join(map(self.visit, node.value.elts))\n        elif node.value:\n            v = self.visit(node.value)\n            return 'return %s;' % v\n        return 'return;'", 
            "title": "Return"
        }, 
        {
            "location": "/cpprustbase/#lambda-functions", 
            "text": "rust lambda\nc++11 lambda  Lambda functions have a different type syntax from normal functions and methods.\nRegular functions and methods type their arguments with Python3 annotation syntax, def f( a:int ):  Lambda functions type their arguments using the keyword default value, lambda a=int:  \n    def visit_Lambda(self, node):\n        args = [self.visit(a) for a in node.args.args]\n        if args and args[0]=='__INLINE_FUNCTION__':\n            raise SyntaxError('TODO inline lambda/function hack')\n        elif self._cpp:\n            assert len(node.args.args)==len(node.args.defaults)\n            args = []\n            for i,a in enumerate(node.args.args):\n                T = node.args.defaults[i].s\n                if not self.is_prim_type(T): T = 'std::shared_ptr %s ' %T\n                s = '%s  %s' %(T, self.visit(a))\n                args.append( s )\n            ## TODO support multiline lambda, and return the last line\n            return '[ ](%s){ return %s; }' %(','.join(args), self.visit(node.body))\n        else:\n            return '|%s| %s ' %(','.join(args), self.visit(node.body))", 
            "title": "Lambda Functions"
        }, 
        {
            "location": "/cpprustbase/#functionmethod", 
            "text": "note: functions defined in  with extern(abi=\"C\"):  are  declare_only  their bodies are skipped.\noperator overloading is implemented here for c++\nTODO clean up go stuff.  \n    def _visit_function(self, node):\n        func_pre = []\n        out = []\n\n        is_declare = hasattr(node, 'declare_only') and node.declare_only  ## see pythonjs.py visit_With\n        is_closure = False\n        node.is_abstract = False\n        node.func_header = None\n        node.func_args = []\n        node.func_body = []\n\n        if self._function_stack[0] is node:\n            self._global_functions[node.name] = node\n            self._vars = set()\n            self._known_vars = set()\n            self._known_instances = dict()\n            self._known_arrays    = dict()\n            self._known_arrays.update( self._global_arrays )\n            self._known_strings   = set()\n            self._known_pyobjects = dict()\n            self._known_refs      = dict()\n            self._known_refs.update( self._global_refs )\n            self._known_pointers  = dict()\n            self._known_tuples    = dict()\n            self._known_tuples.update( self._global_tuples )\n\n        elif len(self._function_stack)   1:\n            ## do not clear self._known_* inside of closures ##\n            is_closure = True\n\n        comments = []\n        for b in node.body:\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Str):\n                comments.append( b.value.s )\n        if comments:\n            out.append('/**')\n            for line in comments[0].splitlines():\n                out.append(' * '+line)\n            out.append(' */')\n\n\n        args_typedefs = {}\n        chan_args_typedefs = {}\n        generics = set()\n        args_generics = dict()\n        args_super_classes = {}\n        func_pointers = set()\n        arrays = dict()\n        operator = None\n        if node.name in ('__getitem__', '__setitem__'):  ## TODO support setitem, return a proxy with `=` overloaded?\n            operator = '[]'\n        elif node.name == '__unwrap__':\n            operator = '- '\n        elif node.name == '__copy__':\n            operator = '='\n        elif node.name == '__call__':\n            operator = '()'\n        elif node.name == '__add__':\n            operator = '+'\n        elif node.name == '__iadd__':\n            operator = '+='\n        elif node.name == '__sub__':\n            operator = '-'\n        elif node.name == '__isub__':\n            operator = '-='\n        elif node.name == '__mul__':\n            operator = '*'\n        elif node.name == '__imul__':\n            operator = '*='\n        elif node.name == '__div__':\n            operator = '/'\n        elif node.name == '__idiv__':\n            operator = '/='\n\n\n        options = {'getter':False, 'setter':False, 'returns':None, 'returns_self':False, 'generic_base_class':None, 'classmethod':False}\n\n        virtualoverride = False\n        extern = False\n\n        for decor in node.decorator_list:\n            self._visit_decorator(\n                decor,\n                node=node,\n                options=options,\n                args_typedefs=args_typedefs,\n                chan_args_typedefs=chan_args_typedefs,\n                generics=generics,\n                args_generics=args_generics,\n                func_pointers=func_pointers,\n                arrays = arrays,\n                args_super_classes=args_super_classes,\n            )\n\n            if isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'expression':\n                assert len(decor.args)==1\n                node.name = self.visit(decor.args[0])\n            elif isinstance(decor, ast.Name) and decor.id=='jvm':\n                raise RuntimeError('TODO @jvm for function')\n            elif isinstance(decor, ast.Name) and decor.id=='virtualoverride':\n                virtualoverride = True\n            elif isinstance(decor, ast.Name) and decor.id=='extern':\n                extern = True\n            elif isinstance(decor, ast.Call) and isinstance(decor.func, ast.Name) and decor.func.id == 'macro':\n                #out.append(decor.args[0].s)\n                if self._cpp:\n                    self._cpp_class_header.append(decor.args[0].s)\n            elif isinstance(decor, ast.Name) and decor.id=='abstractmethod':\n                ## TODO: virtual function c++\n                assert self._cpp\n                out.append('/* abstractmethod: %s */' %node.name)\n                node.is_abstract = True\n            elif isinstance(decor, ast.Attribute) and decor.attr=='safe':  ## GCC STM\n                func_pre.append('__attribute__((transaction_safe))')\n            elif isinstance(decor, ast.Attribute) and decor.attr=='pure':  ## GCC STM\n                func_pre.append('__attribute__((transaction_pure))')\n\n        for name in arrays:\n            arrtype = args_typedefs[name]#arrays[ name ]\n            if '[' in arrtype:\n                # C-style\n                if arrtype.endswith(']'):\n                    raise RuntimeError(arrtype)\n                else:\n                    raise RuntimeError(arrtype+'!!!')\n\n            self._known_arrays[ name ] = arrtype\n\n        for name in args_typedefs:\n            if args_typedefs[name]=='string':\n                self._known_strings.add(name)\n            elif args_typedefs[name].endswith(' '):\n                self._known_refs[name] = args_typedefs[name]\n            elif args_typedefs[name].endswith('*'):\n                self._known_instances[name]= args_typedefs[name]\n                self._known_pointers[name] = args_typedefs[name]\n\n\n        node.returns_self = returns_self = options['returns_self']\n        return_type = options['returns']\n        generic_base_class = options['generic_base_class']\n        #if self._cpp and return_type and return_type.startswith('tuple('):\n        #   raise RuntimeError(return_type)\n\n        if returns_self and self._cpp:\n            return_type = self._class_stack[-1].name\n\n        node.func_returns = return_type\n\n        is_delete = node.name == '__del__'\n        is_init = node.name == '__init__'\n        is_main = node.name == 'main'\n        if is_main and self._cpp:  ## g++ requires main returns an integer\n            return_type = 'int'\n        elif is_init and self._cpp:\n            if self._memory[-1]=='STACK':\n                return_type = '%s' %self._class_stack[-1].name\n            else:\n                return_type = '%s*' %self._class_stack[-1].name\n\n        elif return_type and not self.is_prim_type(return_type):\n            if self._cpp:\n                if 'returns_array' in options and options['returns_array']:\n                    pass\n                else:\n                    if return_type.endswith(' ') or return_type.endswith('*') or return_type.endswith(' ') or self._memory[-1]=='STACK':\n                        pass\n                    elif self.usertypes and 'shared' in self.usertypes:\n                        return_type = self.usertypes['shared']['template'] % return_type\n                    elif not self._shared_pointers:\n                        return_type = '%s*' %return_type\n                        #return_type = '%s' %return_type  ## return copy of object\n\n                    elif self._unique_ptr:\n                        return_type = 'std::unique_ptr %s ' %return_type\n                    else:\n                        return_type = 'std::shared_ptr %s ' %return_type\n            else:\n                if return_type == 'self':  ## Rust 1.2 can not return keyword `self`\n                    return_type = self._class_stack[-1].name\n\n                return_type = 'Rc RefCell %s ' %return_type\n\n        if return_type == 'string':\n            if self._cpp:\n                if self.usertypes and 'string' in self.usertypes:\n                    return_type = self.usertypes['string']['type']\n                else:\n                    return_type = 'std::string'\n            elif self._rust:\n                return_type = 'String'\n\n        node.return_type = return_type\n        node._arg_names = args_names = []\n        args = []\n        oargs = []\n        offset = len(node.args.args) - len(node.args.defaults)\n        varargs = False\n        varargs_name = None\n        is_method = False\n        args_gens_indices = []\n        closures = []\n        alt_versions = []  ## list of ([args], [body])\n        if args_super_classes:\n            alt_versions.append( ([],[]) )\n\n        has_stdmove = False\n        stdmoveargs  =[]\n\n        for i, arg in enumerate(node.args.args):\n            arg_name = arg.id\n            dindex = i - offset\n            stdmove = False\n\n            if arg_name not in args_typedefs.keys()+chan_args_typedefs.keys():\n                if arg_name=='self':\n                    assert i==0\n                    is_method = True\n                    continue\n                elif dindex  = 0 and node.args.defaults and self.visit(node.args.defaults[dindex]).startswith('move('):\n                    stdmove = True\n                    has_stdmove = True\n                    #fails in c++11#a = 'auto %s = std::%s' %(arg_name, self.visit(node.args.defaults[dindex]))\n                    a = '%s = std::%s' %(arg_name, self.visit(node.args.defaults[dindex]))\n                elif self._cpp:\n                    args_typedefs[arg_name]='auto'  ## c++14\n                else:\n                    err =[\n                        '- - - - - - - - - - - - - - - - - -',\n                        'error in function: %s' %node.name,\n                        'missing typedef: %s' %arg.id,\n                        '- - - - - - - - - - - - - - - - - -',\n                    ]\n                    raise SyntaxError( self.format_error('\\n'.join(err)) )\n\n            if arg_name in args_typedefs:\n                arg_type = args_typedefs[arg_name]\n                if self._cpp:\n                    if args_super_classes:\n                        altargs, altbody = alt_versions[0]\n                        if arg_name in args_super_classes:\n                            if is_method:  ## inlined wrapper methods\n                                altargs.append(\n                                    'std::shared_ptr %s  %s' %(args_super_classes[arg_name][0], arg_name)\n                                )\n                                altbody.append('std::static_pointer_cast %s (%s),' %(arg_type.split(' ')[-1].split(' ')[0], arg_name))\n                            else:  ## fully regenerated function\n                                altargs.append(\n                                    'std::shared_ptr %s  __%s' %(args_super_classes[arg_name][0], arg_name)\n                                )\n                                altbody.append('auto %s = std::static_pointer_cast %s (__%s);' %(arg_name, arg_type.split(' ')[-1].split(' ')[0], arg_name))\n                        else:\n                            altargs.append('%s %s' %(arg_type, arg_name))\n                            altbody.append(arg_name+',')\n\n                    ## TODO better way to guess if an untyped param is a pointer\n                    #if arg_type=='auto':\n                    #   self._known_instances[arg_name]='auto'\n\n                    ## rule above assumes anything marked with `auto` should not used __shared__ wrapper and directly use `a- b`\n                    if arg_type in ('string', 'string*', 'string ', 'string '):\n                        if self.usertypes and 'string' in self.usertypes:\n                            if arg_type.endswith(' '):\n                                arg_type = self.usertypes['string']['type'] + ' '\n                            elif arg_type.endswith(' '):\n                                arg_type = self.usertypes['string']['type'] + ' '\n                            elif arg_type.endswith('*'):\n                                arg_type = self.usertypes['string']['type'] + '*'\n                            else:\n                                arg_type = self.usertypes['string']['type']\n                        else:\n                            ## standard string type in c++ std::string\n                            arg_type = arg_type.replace('string', 'std::string')\n\n                    if 'std::' in arg_type and arg_type.endswith(' ') and ('shared_ptr' in arg_type or 'unique_ptr' in arg_type):\n                        if arg_name in self._known_instances:\n                            print 'nested lambda?'\n                        self._known_instances[arg_name] = arg_type\n\n\n                    if arg_name in func_pointers:\n                        ## note C has funky function pointer syntax, where the arg name is in the middle\n                        ## of the type, the arg name gets put there when parsing above.\n                        a = arg_type\n                    elif arg_type.endswith(']'):\n                        atype,alen = arg_type.split('[')\n                        self._known_arrays[arg_name] = (atype, alen[:-1])\n                        a = '%s %s[%s' %(atype, arg_name, alen)\n                    else:\n                        a = '%s %s' %(arg_type, arg_name)\n\n                    if generics and arg_name in args_generics.keys():\n                        args_gens_indices.append(i)\n\n                    if arg_type.endswith('*'):\n                        self._known_pointers[arg_name] = arg_type  ## TODO, strip star?\n\n                elif self._rust:  ## standard string type in rust `String`\n                    if arg_type == 'string': arg_type = 'String'  \n                    if '|' in arg_type:\n                        x,y,z = arg_type.split('|')\n                        arg_type = '__functype__%s'%len(closures)\n                        closures.append('%s:Fn(%s) %s' %('__functype__%s'%len(closures), y,z))\n\n                    a = '%s:%s' %(arg_name, arg_type)\n\n\n            elif arg_name in chan_args_typedefs:\n                arg_type = chan_args_typedefs[arg_name]\n                is_sender = False\n                is_recver = False\n                if arg_type.startswith('Sender '):\n                    arg_type = arg_type[ len('Sender ') : -1 ]\n                    is_sender = True\n                elif arg_type.startswith('Receiver '):\n                    arg_type = arg_type[ len('Receiver ') : -1 ]\n                    is_recver = True\n\n\n                if self._cpp:\n                    ## cpp-channel API is both input and output like Go.\n                    if self.is_prim_type(arg_type):\n                        a = 'cpp::channel %s   %s' %(arg_type, arg_name)\n                    else:\n                        a = 'cpp::channel %s*   %s' %(arg_type, arg_name)\n                elif self._rust:\n                    ## allow go-style `chan` keyword with Rust backend,\n                    ## defaults to Sender T , because its assumed that sending channels\n                    ## will be the ones most often passed around.\n                    ## the user can use rust style typing `def f(x:X t ):` in function defs\n                    ## to type a function argument as `Reveiver t `\n\n                    if is_recver:\n                        a = '%s : Receiver %s ' %(arg_name, arg_type)\n                    else:\n                        a = '%s : Sender %s ' %(arg_name, arg_type)\n\n                else:\n                    raise RuntimeError('TODO chan for backend')\n\n\n            if dindex  = 0 and node.args.defaults and not stdmove:\n                default_value = self.visit( node.args.defaults[dindex] )\n                ## because _KwArgs_ class has argument types that refer to user defined\n                ## classes (that are forward declared), only pointers or std::shared_ptr\n                ## can be used as their type, otherwise g++ will fail with this error:\n                ## error: \u2018MyClass\u2019 has incomplete type\n                if not self.is_prim_type(arg_type):\n                    if not arg_type.endswith('*') and not arg_type.endswith(' ') and not arg_type.endswith(' ') and not arg_type.startswith('std::'):\n                        assert self._memory[-1]=='STACK'\n                        arg_type += '*'\n                        args_typedefs[arg_name] = arg_type\n\n                self._kwargs_type_[ arg_name ] = arg_type\n                oargs.append( (arg_name, default_value) )\n            elif stdmove:\n                stdmoveargs.append(a)\n            else:\n                args.append( a )\n                node._arg_names.append( arg_name )\n\n        ##############################################\n        if args_super_classes:\n            if is_method:\n                altargs, altbody = alt_versions[0]\n                altbody.insert(0,'{ return %s('%node.name)\n                if altbody[-1][-1]==',':\n                    altbody[-1] = altbody[-1][:-1]\n                altbody[-1] += ');}'\n            else:\n                ## there is a bug in gcc4.9 where a static_pointer_cast of a shared pointer\n                ## can cause a segfault in the generated wrapper functions.\n                ## note: the wrappers work with methods, see above.\n                altbody.insert(0,'{')\n\n                for b in node.body:\n                    altbody.append(self.indent()+self.visit(b))\n                altbody.append('}')\n\n        if oargs:\n            node._arg_names.append( '__kwargs' )\n            if self._cpp:\n                args.append( '_KwArgs_*  __kwargs')\n            elif self._rust:\n                raise SyntaxError( self.format_error('TODO named keyword parameters') )\n            else:\n                raise SyntaxError('TODO kwargs for some backend')\n\n        starargs = None\n        if node.args.vararg:\n            if self._cpp: raise RuntimeError('TODO *args for c++')\n            starargs = node.args.vararg\n            assert starargs in args_typedefs\n            args.append( '__vargs__ : Vec %s ' %args_typedefs[starargs])\n            node._arg_names.append( starargs )\n\n        #prefix = '__attribute__((visibility( default ))) '  ## this fails to force functions to be available to ctypes in CPython.\n        prefix = ''\n        if func_pre:\n            prefix +=  ' '.join(func_pre) + ' '\n\n        if options['classmethod']:\n            prefix += 'static '\n            if args and 'object ' in args[0]:  ## classmethods output from java2python produces `cls:object`\n                args = args[1:]\n        if extern:\n            prefix += 'extern '\n            is_declare = True\n\n        if virtualoverride:\n            is_method = True\n\n        fname = node.name\n        if operator:\n            fname = 'operator ' + operator\n\n        #if self._cpp:\n        #   for arg in args:\n        #       if arg.startswith('string '):\n        #           raise RuntimeError(args)  ## should never happen\n\n        node._args_signature = ','.join(args)\n        ####\n        if is_method:\n            assert self._class_stack\n            method = '(self *%s)  ' %self._class_stack[-1].name\n        else:\n            method = ''\n\n        clonames = ','.join(['__functype__%s'%ci for ci in range(len(closures))])\n\n\n        if is_closure:\n            if self._rust and closures:\n                raise SyntaxError('TODO: rust syntax for a lambda function that takes function pointers as arguments')\n\n            if return_type:\n                if self._rust:\n                    out.append( 'let %s = |%s| -  %s {\\n' % (node.name, ', '.join(args), return_type) )\n                elif self._cpp:\n                    if has_stdmove:\n                        out.append( 'auto %s = [%s](%s) -  %s {\\n' % (node.name, ', '.join(stdmoveargs), ', '.join(args), return_type) )\n                    else:\n                        out.append( 'auto %s = [ ](%s) -  %s {\\n' % (node.name, ', '.join(args), return_type) )\n            else:\n                if self._rust:\n                    out.append( 'let %s = |%s| {\\n' % (node.name, ', '.join(args)) )\n                elif self._cpp:\n                    if has_stdmove:\n                        out.append( 'auto %s = [%s](%s) {\\n' % (node.name,', '.join(stdmoveargs), ', '.join(args)) )\n                    else:\n                        out.append( 'auto %s = [ ](%s) {\\n' % (node.name, ', '.join(args)) )\n\n        else:\n            if return_type:\n                if self._cpp: ## c++ ##\n                    if is_method or options['classmethod']:\n                        classname = self._class_stack[-1].name\n                        sig = '%s %s::%s(%s)' % (return_type, classname, fname, ', '.join(args))\n\n                        if self._noexcept:\n                            out.append( self.indent() + '%s noexcept {\\n' % sig )\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n                            self._cpp_class_header.append(sig + ' noexcept;')\n                        else:\n                            out.append( self.indent() + '%s {\\n' % sig )\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n\n                            if virtualoverride:\n                                sig = 'virtual %s override' %sig\n\n                            self._cpp_class_header.append(sig + ';')\n\n                            if alt_versions:\n                                assert args_super_classes\n                                for av in alt_versions:\n                                    altargs, altbody = av\n                                    asig = 'inline %s %s(%s)' % (return_type, fname, ', '.join(altargs))\n                                    self._cpp_class_header.append( asig + '\\n'.join(altbody))\n\n                            if node.args.defaults:\n                                if len(args)==1:  ## all args have defaults, generate plain version with no defaults ##\n                                    okwargs = ['(new _KwArgs_)']\n                                    args = []\n                                    for oarg in oargs:\n                                        oname = oarg[0]\n                                        T = args_typedefs[oname]\n                                        if T=='string':\n                                            T = 'std::string'\n                                        args.append('%s %s' %(T, oname))\n                                        okwargs.append('%s(%s)' %(oname,oname))\n\n                                    okwargs = '- '.join(okwargs)\n                                    osig = '%s%s %s(%s) { return this- %s(%s); }' % (prefix,return_type, fname, ','.join(args), fname, okwargs)\n                                    self._cpp_class_header.append(osig)\n\n                    else:  ## regular function\n                        if self._noexcept:\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n                            out.append( self.indent() + '%s noexcept {\\n' % sig )\n                            if not is_main: self._cheader.append( sig + ' noexcept;' )\n                        else:\n                            sig = '%s%s %s(%s)' % (prefix,return_type, fname, ', '.join(args))\n                            out.append( self.indent() + '%s {\\n' % sig )\n                            if not is_main:\n                                self._cheader.append( sig + ';' )\n                                if alt_versions:\n                                    assert args_super_classes\n                                    for av in alt_versions:\n                                        altargs, altbody = av\n                                        asig = '%s %s(%s)' % (return_type, fname, ', '.join(altargs))\n                                        out.insert(0, asig + '\\n'.join(altbody))\n\n                else:  ## rust ##\n                    if is_method:\n                        self._rust_trait.append('fn %s( mut self, %s) -  %s;' %(node.name, ', '.join(args), return_type) )\n                        if closures:\n                            out.append( self.indent() + 'fn %s %s ( mut self, %s) -  %s' % (node.name, clonames, ', '.join(args), return_type) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n\n                        else:\n                            out.append( self.indent() + 'fn %s( mut self, %s) -  %s {' % (node.name, ', '.join(args), return_type) )\n\n                    else:\n                        if closures:\n                            out.append( self.indent() + 'fn %s %s (%s) -  %s' % (node.name, clonames, ', '.join(args), return_type) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n                        else:\n                            out.append( self.indent() + 'fn %s(%s) -  %s {' % (node.name, ', '.join(args), return_type) )\n\n            else:  ## function with no return type, `auto` can be used in c++14 to find the return type.\n\n                if self._cpp: ## c++ ##\n                    if is_method or options['classmethod']:\n                        classname = self._class_stack[-1].name\n                        if is_delete:\n                            sig = '%s::~%s()' %(classname, classname)\n                            if self._noexcept:\n                                out.append( self.indent() + '%s noexcept {\\n' % sig  )\n                                sig = '~%s()' %classname\n                                self._cpp_class_header.append(sig + ';')\n                            else:\n                                out.append( self.indent() + '%s {\\n' % sig  )\n                                sig = '~%s()' %classname\n                                self._cpp_class_header.append(sig + ';')\n\n                        else:\n                            sig = 'auto %s::%s(%s)' %(classname, fname, ', '.join(args))\n                            if self._noexcept:\n                                out.append( self.indent() + '%s noexcept {\\n' % sig  )\n                                sig = '%sauto %s(%s)' % (prefix,fname, ', '.join(args))\n                                self._cpp_class_header.append(sig + ' noexcept;')\n                            else:\n                                out.append( self.indent() + '%s {\\n' % sig  )\n                                sig = '%sauto %s(%s)' % (prefix,fname, ', '.join(args))\n\n                                if virtualoverride:\n                                    sig = 'virtual %s override' %sig\n\n                                self._cpp_class_header.append(sig + ';')\n                    else:\n                        if self._noexcept:\n                            sig = '%sauto %s(%s)' %(prefix, fname, ', '.join(args))\n                            out.append( self.indent() + '%s noexcept {\\n' % sig  )\n                            if not is_main: self._cheader.append( sig + ' noexcept;' )\n                        else:\n                            sig = '%sauto %s(%s)' %(prefix, fname, ', '.join(args))\n                            out.append( self.indent() + '%s {\\n' % sig  )\n                            if not is_main: self._cheader.append( sig + ';' )\n\n                else:         ## rust ##\n                    if is_method:\n                        self._rust_trait.append('fn %s( mut self, %s);' %(node.name, ', '.join(args)) )\n                        if closures:\n                            out.append( self.indent() + 'fn %s %s ( mut self, %s) ' % (node.name, clonames, ', '.join(args)) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n                        else:\n                            out.append( self.indent() + 'fn %s( mut self, %s) {' % (node.name, ', '.join(args)) )\n\n                    else:\n                        if closures:\n                            out.append( self.indent() + 'fn %s %s (%s)' % (node.name, clonames, ', '.join(args)) )\n                            out.append( self.indent() + '   where')\n                            self.push()\n                            for clo in closures:\n                                out.append( self.indent() + '   %s,' %clo)\n                            self.pull()\n                            out.append( self.indent() + '{')\n                        else:\n                            out.append( self.indent() + 'fn %s(%s) {' % (node.name, ', '.join(args)) )\n\n        self.push()\n\n        if oargs:\n            for n,v in oargs:\n                if self._cpp:\n                    T = args_typedefs[n]\n                    if T=='string':\n                        T = 'std::string'\n                    ## in stack mode the user must explicitly pass a pointer\n                    ## when using keyword arguments and object instances.\n                    ## (in heap mode this is not required)\n                    if n in self._kwargs_type_ and self._memory[-1]=='STACK':\n                        T = self._kwargs_type_[n]\n\n                    out.append(self.indent() + '%s  %s = %s;' %(T,n,v))\n                    out.append(self.indent() + 'if (__kwargs- __use__%s == true) {' %n )\n                    out.append(self.indent() +  '  %s = __kwargs- _%s_;' %(n,n))\n                    out.append(self.indent() + '}')\n\n                else:\n                    out.append(self.indent() + 'let mut %s = %s;' %(n,v))\n                    out.append(self.indent() + 'if (__kwargs.__use__%s == true) {' %n )\n                    out.append(self.indent() +  '  %s = __kwargs.%s;' %(n,n))\n                    out.append(self.indent() + '}')\n\n            if self._cpp:\n                ## TODO free __kwargs\n                pass\n\n        if starargs:\n            out.append(self.indent() + 'let %s =  __vargs__;' %starargs)\n\n        if self._cpp:\n            for b in node.body:\n                out.append(self.indent()+self.visit(b))\n\n        else:  ## the rust backend requires this?\n            body = node.body[:]\n            body.reverse()\n            self.generate_generic_branches( body, out, self._vars, self._known_vars )\n\n\n        self._scope_stack = []\n\n        if self._threads:\n            assert self._cpp\n            while self._threads:\n                threadname = self._threads.pop()\n                out.append(self.indent()+'if (%s.joinable()) %s.join();' %(threadname,threadname))\n\n        if is_main and self._cpp:\n            if self._has_jvm:\n                out.append('std::cout    program exit - DestroyJavaVM   std::endl;')\n                out.append(self.indent()+'__javavm__- DestroyJavaVM();')\n                out.append('std::cout    JavaVM shutdown ok.   std::endl;')  ## jvm crashes here TODO fixme.\n                #out.append('delete __javavm__;')  ## invalid pointer - segfault.\n            out.append( self.indent() + 'return 0;' )\n        if is_init and self._cpp:\n            if self._memory[-1]=='STACK':\n                out.append( self.indent() + 'return *this;' )\n            else:\n                out.append( self.indent() + 'return this;' )\n\n            #if not self._shared_pointers:\n            #   out.append( self.indent() + 'return this;' )\n            #else:\n            #   #out.append( self.indent() + 'return std::make_shared %s (this);' %self._class_stack[-1].name )  ## crashes GCC\n            #   out.append( self.indent() + 'return nullptr;' )  ## the exe with PGO will crash if nothing returns\n\n        if len(self._known_arrays.keys()):\n            out.append( self.indent()+'/* arrays:')\n            for arrname in self._known_arrays:\n                arrtype = self._known_arrays[arrname]\n                out.append(self.indent()+'  %s : %s' %(arrname, arrtype))\n            out.append('*/')\n\n        self.pull()\n        if (self._rust or self._cpp) and is_closure:\n            out.append( self.indent()+'};' )\n        else:\n            if is_declare:\n                return out[0].replace('{', ';')\n            else:\n                out.append( self.indent()+'}' )\n\n        node.func_body = out[:]\n\n        if generics and self._cpp:\n            overloads = []\n            gclasses = set(args_generics.values())\n            for gclass in gclasses:\n\n                for subclass in generics:\n                    for i,line in enumerate(out):\n                        if i==0: line = line.replace(' %s '%gclass, ' %s '%subclass)\n                        overloads.append(line)\n\n                if len(args_generics.keys())   1:\n                    len_gargs = len(args_generics.keys())\n                    len_gsubs = len(generics)\n                    gsigs = []\n\n                    p = list(generics)\n                    p.append( generic_base_class )\n                    while len(p)   len_gargs:\n                        p.append( generic_base_class )\n                    gcombos = set( itertools.permutations(p) )\n                    if len(gcombos)   16:  ## TODO fix bug that makes this explode\n                        for combo in gcombos:\n                            combo = list(combo)\n                            combo.reverse()\n                            gargs = []\n                            for idx, arg in enumerate(args):\n                                if idx in args_gens_indices:\n                                    gargs.append(\n                                        arg.replace(' %s '%gclass, ' %s '%combo.pop())\n                                    )\n                                else:\n                                    gargs.append( arg )\n\n                        sig = '%s %s(%s)' % (return_type, node.name, ', '.join(gargs))\n                        gsigs.append( sig )\n\n                    for sig in gsigs:\n                        overloads.append('%s {' %sig)\n                        for line in out[1:]:\n                            overloads.append(line)\n\n\n            out.extend(overloads)\n\n        return '\\n'.join(out)\n\n    def _hack_return(self, v, return_type, gname, gt, node):\n        ## TODO - fix - this breaks easily\n        raise RuntimeError('hack return deprecated')\n        if v.strip().startswith('return ') and '*'+gt != return_type:\n            if gname in v and v.strip() != 'return self':\n                if '(' not in v:\n                    v += '.(%s)' %return_type\n                    v = v.replace(gname, '__gen__')\n                    self.method_returns_multiple_subclasses[ self._class_stack[-1].name ].add(node.name)\n        return v", 
            "title": "Function/Method"
        }, 
        {
            "location": "/cpprustbase/#generate_generic_branches", 
            "text": "TODO, this is a left over from the Go backend,\nit is a nice hack that generates a branch in the caller for methods that return different types,\nthis could also come in handy with the rust and c++ backends.  \n    def generate_generic_branches(self, body, out, force_vars, force_used_vars):\n        #out.append('/* GenerateGeneric */')\n        #out.append('/*vars: %s*/' %self._vars)\n        #out.append('/*used: %s*/' %self._known_vars)\n\n        #force_vars, force_used_vars = self._scope_stack[-1]\n        self._vars = set(force_vars)\n        self._known_vars = set(force_used_vars)\n\n        #out.append('/*force vars: %s*/' %force_vars)\n        #out.append('/*force used: %s*/' %force_used_vars)\n\n        prev_vars = None\n        prev_used = None\n        vars = None\n        used = None\n\n        vars = set(self._vars)\n        used = set(self._known_vars)\n\n        #out.append('/*Sstack len: %s*/' %len(self._scope_stack))\n        #if self._scope_stack:\n        #   out.append('/*stack: %s - %s*/' %self._scope_stack[-1])\n        #   out.append('/*STAK: %s */' %self._scope_stack)\n\n\n        while len(body):\n            prev_vars = vars\n            prev_used = used\n\n            b = body.pop()\n            if isinstance(b, ast.Expr) and isinstance(b.value, ast.Str):  ## skip doc strings here\n                continue\n\n            try:\n                v = self.visit(b)\n                if v: out.append( self.indent() + v )\n            except GenerateGenericSwitch as err:\n                self._scope_stack.append( (set(self._vars), set(self._known_vars)))\n\n                #out.append('/*         GenerateGenericSwitch */')\n                #out.append('/* vars: %s*/' %self._vars)\n                #out.append('/* used: %s*/' %self._known_vars)\n                #out.append('/* prev vars: %s*/' %prev_vars)\n                #out.append('/* prev used: %s*/' %prev_used)\n                #out.append('/* stack: %s - %s*/' %self._scope_stack[-1])\n                #out.append('/* stack len: %s*/' %len(self._scope_stack))\n                #out.append('/* stack: %s*/' %self._scope_stack)\n\n                G = err[0]\n                if 'target' not in G:\n                    if isinstance(b, ast.Assign):\n                        G['target'] = self.visit(b.targets[0])\n                    else:\n                        raise SyntaxError('no target to generate generic switch')\n\n\n                out.append(self.indent()+'__subclass__ := %s' %G['value'])\n                out.append(self.indent()+'switch __subclass__.__class__ {')\n                self.push()\n\n                subclasses = self.get_subclasses( G['class'] )\n                for sub in subclasses:\n                    out.append(self.indent()+'case  %s :' %sub)\n                    self.push()\n                    #out.append(self.indent()+'%s := __subclass__.(*%s)' %(G['target'], sub)) ## error not an interface\n                    #out.append(self.indent()+'%s := %s(*__subclass__)' %(G['target'], sub))\n                    out.append(self.indent()+'__addr := %s(*__subclass__)' %sub)\n                    out.append(self.indent()+'%s :=  __addr' %G['target'])\n\n                    pv, pu = self._scope_stack[-1]\n                    self.generate_generic_branches( body[:], out, pv, pu )\n\n                    self.pull()\n                self._scope_stack.pop()\n\n                self.pull()\n                out.append(self.indent()+'}')\n                return\n\n\n    def _visit_call_helper_var(self, node):\n        args = [ self.visit(a) for a in node.args ]\n        #if args:\n        #   out.append( 'var ' + ','.join(args) )\n        if node.keywords:\n            for key in node.keywords:\n                args.append( key.arg )\n\n        for name in args:\n            if name not in self._vars:\n                self._vars.add( name )\n\n        #out = []\n        #for v in args:\n        #   out.append( self.indent() + 'var ' + v + ' int')\n\n        #return '\\n'.join(out)\n        return ''\n\n\n\n    def visit_Break(self, node):\n        if len(self._match_stack) and not self._cpp:\n            return ''\n        else:\n            return 'break;'", 
            "title": "generate_generic_branches"
        }, 
        {
            "location": "/cpprustbase/#augmented-assignment", 
            "text": "def visit_AugAssign(self, node):\n        ## n++ and n-- are slightly faster than n+=1 and n-=1\n        target = self.visit(node.target)\n        op = self.visit(node.op)\n        value = self.visit(node.value)\n\n        if target in self._known_instances:\n            target = '*'+target\n\n        if isinstance(node.target, ast.Name) and op=='+' and node.target.id in self._known_strings and not self._cpp:\n            return '%s.push_str(%s.as_slice());' %(target, value)\n\n        if self._cpp and op=='+' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s ++;' %target\n        elif self._cpp and op=='-' and isinstance(node.value, ast.Num) and node.value.n == 1:\n            a = '%s --;' %target\n        else:\n            a = '%s %s= %s;' %(target, op, value)\n        return a", 
            "title": "Augmented Assignment +="
        }, 
        {
            "location": "/cpprustbase/#attribute", 
            "text": "TODO deprecate  -  or use for something else.\nAlso swaps  .  for c++ namespace  ::  by checking if the value is a Name and the name is one of the known classes.  \n    def visit_Attribute(self, node):\n        parent_node = self._stack[-2]\n        name = self.visit(node.value)\n        fname = None\n        if isinstance(node.value, ast.Call):\n            fname = self.visit(node.value.func)\n\n        attr = node.attr\n        if attr=='__finally__':\n            attr = 'finally'\n        #############################\n        if attr == '__doublecolon__':\n            return '%s::' %name\n        elif attr == '__right_arrow__':\n            return '%s- ' %name\n        elif attr == '__doubledot__':\n            return 'PyObject_GetAttrString(%s,' %name\n        elif name.endswith('- ') or name.endswith('::'):\n            return '%s%s' %(name,attr)\n        elif name in ('self','this') and self._cpp and self._class_stack:\n            if attr in self._class_stack[-1]._weak_members:\n                if len(self._stack) 2:\n                    assert self._stack[-1] is node\n                    if isinstance(self._stack[-2], ast.Assign):\n                        for target in self._stack[-2].targets:\n                            if target is node:\n                                return 'this- %s' %attr\n                if self.usertypes and 'weakref' in self.usertypes:\n                    return 'this- %s.%s()' %(attr, self.usertypes['weakref']['lock'])\n                else:\n                    return 'this- %s.lock()' %attr\n            elif self._memory[-1]=='STACK':\n                #return 'this.%s' %attr  ## will not work\n                #return '%s' %attr  ## compiles but, but has invalid addresses at runtime\n                return '(*this).%s' %attr ## deref each time\n\n            else:\n                return 'this- %s' %attr\n\n        elif name in self._rename_hacks and not isinstance(parent_node, ast.Attribute):\n            if self._memory[-1]=='STACK':\n                return '_cast_%s.%s' %(name.replace('- ', '_'), attr)\n            else:\n                return '_cast_%s- %s' %(name.replace('- ', '_'), attr)\n\n        elif name.startswith('nuitka- ') and not isinstance(parent_node, ast.Attribute):\n            assert attr in ('module', 'moduledict')\n            raise RuntimeError('TODO')\n\n        elif name.startswith('cpython- ') and not isinstance(parent_node, ast.Attribute):\n            raise RuntimeError(attr)\n\n        elif self._cpp and (name in self._known_pyobjects) and not isinstance(parent_node, ast.Attribute):\n            return 'PyObject_GetAttrString(%s, %s )' %(name, attr)\n\n        elif self._cpp and name in self._globals and self._globals[name].endswith('*'):\n            return '%s- %s' %(name, attr)\n\n        elif self._cpp and name in self._known_pointers:\n            if name in self._known_arrays and attr=='append':\n                return '%s- push_back' %name\n            else:\n                return '%s- %s' %(name, attr)\n\n        elif (name in self._known_instances or name in self._known_arrays) and not isinstance(parent_node, ast.Attribute):\n            if self._cpp:\n                ## TODO - attribute lookup stack to make this safe for `a.x.y`\n                ## from the known instance need to check its class type, for any\n                ## subobjects and deference pointers as required. `a- x- y`\n                ## TODO - the user still needs a syntax to use `- ` for working with\n                ## external C++ libraries where the variable may or may not be a pointer.\n                ## note: `arr.insert(index,value)` is implemented in visit_call_helper\n                if attr=='append' and name in self._known_arrays:\n                    if self.usertypes and 'vector' in self.usertypes:\n                        return '%s- %s' %(name, self.usertypes['vector']['append'])\n                    elif name in self._known_pointers:\n                        return '%s- push_back' %name\n                    elif self._memory[-1]=='STACK':\n                        return '%s.push_back' %name\n                    else:\n                        return '%s- push_back' %name\n                elif attr=='pop' and name in self._known_arrays:\n                    ## pop_back in c++ returns void, so this only works when `arr.pop()` is not used,\n                    ## in the case where the return is assigned `a=arr.pop()`, the workaround is done in visit_Assign, TODO `f(arr.pop())`\n                    if self.usertypes and 'vector' in self.usertypes:\n                        return '%s- %s' %(name, self.usertypes['vector']['pop'])\n                    else:\n                        return '%s- pop_back' %name\n\n                elif self._memory[-1]=='STACK':  ## TODO self._instances_on_stack\n                    return '%s.%s' % (name, attr)\n                else:\n                    return '%s- %s' % (name, attr)\n                    #return 'pointer(%s)- %s' % (name, attr)\n\n            else:  ## rust\n                ## note: this conflicts with the new Rust unstable API,\n                ## where the `append` method acts like Pythons `extend` (but moves the contents)\n                ## depending on how the Rust API develops, this may have to be deprecated,\n                ## or a user option to control if known arrays that call `append` should be\n                ## translated into `push`.\n                ## note: as a workaround known arrays could have special method `merge`,\n                ## that would be translated into `append`, while this would be more python,\n                ## it breaks human readablity of the translation, and makes debugging harder,\n                ## because the user has to be aware of this special case.\n                if attr=='append' and name in self._known_arrays:\n                    attr = 'push'\n\n                return '%s.borrow_mut().%s' % (name, attr)\n\n        elif (name in self._known_strings) and not isinstance(parent_node, ast.Attribute):\n            ## allows direct use of c++ std::string properties and methods like: at, erase, replace, swap, pop_back, etc..\n            return '%s.%s' %(name,attr)\n        elif isinstance(node.value, ast.Str):\n            return '%s.%s' %(name,attr)\n        elif self._cpp:\n            if name in self._classes and not isinstance(parent_node, ast.Attribute):\n                return '%s::%s' % (name, attr)\n            elif name.endswith(',') and name.startswith('PyObject_GetAttrString('):\n                return '%s %s )' %(name, attr)\n            else:\n                if name in 'jvm nim cpython nuitka weak'.split():\n                    return '%s- %s' % (name, attr)\n                elif name in self._known_refs or self._memory[-1]=='STACK':\n                    return '%s.%s' % (name, attr)\n                elif name in self._known_instances:  ## user can use std::move to capture these in lambdas for STACK memory mode.\n                    return '%s- %s' % (name, attr)\n                elif fname in self._global_functions and fname not in self._known_vars:\n                    return '%s.%s' % (name, attr)\n                #elif self._shared_pointers:\n                #   return '__shared__(%s)- %s' % (name, attr)\n                #else:\n                #   return '__pointer__(%s)- %s' % (name, attr)\n                else:\n                    return '%s- %s' % (name, attr)\n\n        else:\n            return '%s.%s' % (name, attr)", 
            "title": "Attribute ."
        }, 
        {
            "location": "/cpprustbase/#list-comp", 
            "text": "def _listcomp_helper(self, node, target=None, type=None, size=None, dimensions=1):\n        if not target: target = node._comp_type\n        assert target\n        assert type\n        isprim = self.is_prim_type(type)\n        slice_hack = False\n        self._known_arrays[target] = type\n\n        gen = node.generators[0]\n        try:\n            a = self.visit(node.elt)\n        except GenerateSlice as error:  ## special c++ case for slice syntax\n            assert self._cpp\n            msg = error[0]\n            a = '_slice_'\n            slice_hack = self._gen_slice(\n                a,\n                value=msg['value'],\n                lower=msg['lower'],\n                upper=msg['upper'],\n                step =msg['step'],\n            )\n\n\n\n        b = self.visit(gen.target)\n        c = self.visit(gen.iter)\n        range_n = []\n        if isinstance(gen.iter, ast.Call) and isinstance(gen.iter.func, ast.Name):\n            if gen.iter.func.id == 'range':\n                if len(gen.iter.args) == 1:\n                    range_n.append( self.visit(gen.iter.args[0]) )\n                elif len(gen.iter.args) == 2:\n                    range_n.append( self.visit(gen.iter.args[0]) )\n                    range_n.append( self.visit(gen.iter.args[1]) )\n                elif len(gen.iter.args) == 3:\n                    range_n.append( self.visit(gen.iter.args[0]) )\n                    range_n.append( self.visit(gen.iter.args[1]) )\n                    range_n.append( self.visit(gen.iter.args[2]) )\n\n        out = []\n        compname = target\n        if self._memory[-1]=='HEAP':\n            compname = '_comp_%s' %target\n\n        if self._rust:\n            if range_n:\n                if len(range_n)==1:\n                    #c = 'range(0u,%su)' %range_n[0]\n                    c = '0u32..%su32' %range_n[0]\n                elif len(range_n)==2:\n                    #c = 'range(%su,%su)' %( range_n[0], range_n[1] )\n                    c = '%su32..%su32' %( range_n[0], range_n[1] )\n                else:\n                    raise SyntaxError('TODO list comp range(low,high,step)')\n\n            mutref = False\n            if isprim:\n                out.append('let mut %s : Vec %s  = Vec::new();' %(compname,type))\n            else:\n                mutref = True\n                #out.append('let mut %s : Vec mut %s  = Vec::new();' %(compname,type))  ## ref style\n                out.append('let mut %s : Vec  Rc RefCell %s    = Vec::new();' %(compname,type))\n\n            if range_n:\n                ## in rust the range builtin returns ...\n                out.append('for %s in %s {' %(b, c))\n                out.append('    %s.push(%s as %s);' %(compname, a, type))\n            else:\n                out.append('for  %s in %s.iter() {' %(b, c))\n                if mutref:\n                    #out.append('   %s.push( mut %s);' %(compname, a))\n                    out.append('    %s.push(%s);' %(compname, a))\n                else:\n                    out.append('    %s.push(%s);' %(compname, a))\n\n            out.append('}')\n\n            #out.append('let mut %s =  %s;' %(target, compname))\n            if mutref:\n                out.append('let %s : Rc RefCell  Vec Rc RefCell %s    = Rc::new(RefCell::new(%s));' %(target, type, compname))\n            else:\n                out.append('let %s : Rc RefCell  Vec %s    = Rc::new(RefCell::new(%s));' %(target, type, compname))\n\n            self._known_arrays[target] = type\n            #out.append('drop(%s);' %compname)  ## release from scope, not required because the Rc/RefCell moves it.\n\n\n        elif self._cpp:\n            vectype    = None\n            subvectype = None\n            if isprim:\n                subvectype = 'std::vector %s ' %type\n                #out.append('std::vector %s  %s;' %(type,compname))\n            else:\n                if self._memory[-1]=='STACK':\n                    subvectype = 'std::vector %s ' %type\n                elif not self._shared_pointers:\n                    subvectype = 'std::vector %s* ' %type\n                elif self._unique_ptr:\n                    subvectype = 'std::vector std::unique_ptr %s ' %type\n                else:\n                    subvectype = 'std::vector std::shared_ptr %s ' %type\n\n            if dimensions == 1:\n                vectype = subvectype\n            elif dimensions == 2:\n                if self._memory[-1]=='STACK':\n                    vectype = 'std::vector %s ' %subvectype\n                elif not self._shared_pointers:\n                    vectype = 'std::vector %s* ' %subvectype\n                elif self._unique_ptr:\n                    vectype = 'std::vector std::unique_ptr  %s  ' %subvectype\n                else:\n                    vectype = 'std::vector std::shared_ptr  %s  ' %subvectype\n            else:\n                raise SyntaxError('TODO other dimensions')\n\n            out.append('%s %s; /*comprehension*/' %(vectype,compname))\n\n\n            if range_n:\n                if len(range_n)==1:\n                    out.append(self.indent()+'for (int %s=0; %s %s; %s++) {' %(b, b, range_n[0], b))\n\n                elif len(range_n)==2:\n                    out.append(self.indent()+'for (int %s=%s; %s %s; %s++) {' %(b, range_n[0], b, range_n[1], b))\n\n            else:\n                out.append(self.indent()+'for (auto  %s: %s) {' %(b, c))\n\n            if slice_hack:\n                out.append( slice_hack )\n\n            if isprim:\n                out.append(self.indent()+'  %s.push_back(%s);' %(compname, a))\n            else:\n                assert type in self._classes\n                if False:\n                    tmp = '_tmp_'\n                    constructor_args = a.strip()[ len(type)+1 :-1] ## strip to just args\n                    r = '%s  _ref_%s = %s{};' %(type, tmp, type)\n                    if constructor_args:\n                        r += '_ref_%s.__init__(%s);\\n' %(tmp, constructor_args)\n\n                    if not self._shared_pointers:\n                        r += '%s* %s =  _ref_%s;' %(type, tmp, tmp)\n                    elif self._unique_ptr:\n                        r += 'std::unique_ptr %s  %s = std::make_unique %s (_ref_%s);' %(type, tmp, type, tmp)\n                    else:\n                        r += 'std::shared_ptr %s  %s = std::make_shared %s (_ref_%s);' %(type, tmp, type, tmp)\n                    out.append( r )\n                    out.append('    %s.push_back(%s);' %(compname, tmp))\n\n                out.append(self.indent()+'  %s.push_back(%s);' %(compname, a))\n\n\n            out.append(self.indent()+'}')  ## end comp for loop\n\n\n            ## TODO vector.resize if size is given\n            if self._memory[-1]=='STACK':\n                #out.append(self.indent()+'auto %s = %s;' %(target, compname))\n                pass\n            elif not self._shared_pointers:\n                out.append(self.indent()+'auto %s =  %s;' %(target, compname))\n            elif self._unique_ptr:\n                out.append(self.indent()+'auto %s = std::make_unique %s (%s);' %(target, vectype, compname))\n            else:\n                out.append(self.indent()+'auto %s = std::make_shared %s (%s);' %(target, vectype, compname))\n\n        else:\n            raise RuntimeError('TODO list comp for some backend')\n\n        return '\\n'.join(out)", 
            "title": "List Comp"
        }, 
        {
            "location": "/cpprustbase/#assignment", 
            "text": "implemented for rust and c++  Assignment to some variable, tracks assignments to local variables for arrays, objects, and strings,\nbecause they need some special handling in other places.  \n\n    def visit_Assign(self, node):\n        self._catch_assignment = False\n        self._assign_node = node\n        self._assign_pre  = []\n        res = self._visit_assign(node)\n        self._assign_node = None\n        if self._assign_pre:\n            self._assign_pre.append(res)\n            res = '\\n'.join(self._assign_pre) \n            self._assign_pre  = []\n        return res\n\n    def _visit_assign(self, node):\n        result = []  ## for arrays of arrays with list comps\n        value  = None\n        comptarget = None  ## if there was a comp, then use result and comptarget\n\n        if isinstance(node.targets[0], ast.Name) and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='range':\n            self._known_arrays[node.targets[0].id] = 'int'\n            #if len(node.value.args)==1:\n            #   alen = self.visit(node.value.args[0])\n            #   self._known_arrays[node.targets[0].id] = ('int', alen)\n            #   if not len(self._function_stack):\n            #       self._global_arrays[node.targets[0].id] = ('int', alen)\n            if not len(self._function_stack):\n                self._global_arrays[node.targets[0].id] = 'int'\n                if self._memory[-1]=='STACK':\n                    ## note: __range#__ returns a copy of std::vector T \n                    ## TODO `range(start,stop,step, fixed=True/False)\n                    self._global_refs[node.targets[0].id] = 'std::vector int '\n\n        #######################\n        if isinstance(node.targets[0], ast.Tuple):\n            if len(node.targets)   1: raise NotImplementedError('TODO')\n            elts = [self.visit(e) for e in node.targets[0].elts]\n            target = '(%s)' % ','.join(elts)  ## this works in rust, not c++\n            assert not self._cpp\n        elif isinstance(node.targets[0], ast.Name) and node.targets[0].id in self._known_arrays and isinstance(self._known_arrays[node.targets[0].id], tuple):\n            target = self.visit(node.targets[0])\n            value = None\n            if isinstance(node.value, ast.Subscript):\n                if isinstance(node.value.slice, ast.Slice):\n                    if not node.value.slice.lower and not node.value.slice.upper and not node.value.slice.step:\n                        value = self.visit(node.value.value)\n                    else:\n                        raise SyntaxError(self.format_error('invalid slice assignment to a fixed size array'))\n                else:\n                    raise SyntaxError(self.format_error('invalid assignment to a fixed size array'))\n\n            if value is None:\n                value = self.visit(node.value)\n\n            atype, fixed_size = self._known_arrays[target]\n\n            if '(' in value and ')' in value:  ## do not unroll from a function call\n                if not self._function_stack:  ## global\n                    self._globals[ target ] = (atype, fixed_size)\n                    return 'auto %s = %s; /*global fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n\n                elif target in self._vars:\n                    ## first assignment of a known variable, this requires 'auto' in c++11\n                    self._vars.remove( target )\n                    self._known_vars.add( target )\n                    return 'auto %s = %s; /*assignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n                else:\n                    return '%s = %s; /*reassignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n\n            elif fixed_size.isdigit() and int(fixed_size) 512:  ## or in self._macro_constants: TODO\n                fixed_size = int(fixed_size)\n                r = []\n                for i in range(fixed_size):\n                    r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                return ' '.join(r)\n            else:\n                r = [\n                    'for (int __i=0; __i %s; __i++) {' %fixed_size,\n                    self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                    self.indent()+'}',\n                ]\n                return '\\n'.join(r)\n\n        elif isinstance(node.targets[0], ast.Subscript) and isinstance(node.targets[0].slice, ast.Slice):\n            ## slice assignment, the place sliced away is replaced with the assignment value, this happens inplace.\n            ## `arr1[ :n ]=arr2` slices away all items before n, and inserts arr2 in its place.\n            ## if `n` is greater than the length of the array, then the array is cleared first.\n            target = self.visit(node.targets[0].value)\n            slice = node.targets[0].slice\n            value = self.visit(node.value)\n            if not slice.lower and not slice.upper and not slice.step:  ## slice copy: `myarr[:]=other` ##\n                if self._memory[-1]=='STACK':\n                    if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                        atype, fixed_size = self._known_arrays[target]\n                        ## unroll loop if possible ##\n                        if fixed_size.isdigit() and int(fixed_size) 512:  ## or in self._macro_constants: TODO\n                            fixed_size = int(fixed_size)\n                            r = []\n                            for i in range(fixed_size):\n                                r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                            return '\\n'.join(r)\n                        else:\n                            r = [\n                                'for (int __i=0; __i %s; __i++) {' %fixed_size,\n                                self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                                self.indent()+'}',\n                            ]\n                            return '\\n'.join(r)\n\n                    elif value in self._known_arrays and isinstance(self._known_arrays[value], tuple):\n                        atype, fixed_size = self._known_arrays[value]\n                        ## unroll loop if possible ##\n                        if fixed_size.isdigit() and int(fixed_size) 512:  ## or in self._macro_constants: TODO\n                            fixed_size = int(fixed_size)\n                            r = []\n                            for i in range(fixed_size):\n                                r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                            return '\\n'.join(r)\n                        else:\n                            r = [\n                                'for (int __i=0; __i %s; __i++) {' %fixed_size,\n                                self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                                self.indent()+'}',\n                            ]\n                            return '\\n'.join(r)\n                    else:\n                        raise RuntimeError( self.format_error('can not determine the fixed array size from either the target or source: %s=%s'%(target,value) ))\n                else:\n                    raise RuntimeError('TODO array slice assign `arr[:]=other`')\n\n            elif not slice.lower and slice.upper:\n                s = self.visit(slice.upper)\n                if self._memory[-1]=='STACK':\n                    if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                        atype, fixed_size = self._known_arrays[target]\n                        ## TODO assert fixed_size   slice.upper\n\n                    r = [\n                        'for (int __i=0; __i %s; __i++) {' %self.visit(slice.upper),\n                        self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                        self.indent()+'}',\n                    ]\n                    return '\\n'.join(r)\n\n                    #if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                    #   atype, fixed_size = self._known_arrays[target]\n                    #   r = [\n                    #       'for (int __i=0; __i %s; __i++) {' %self.visit(slice.upper),\n                    #       self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                    #       self.indent()+'}',\n                    #   ]\n                    #   return '\\n'.join(r)\n                    #else:\n                    #   r = [\n                    #       'if (%s  = %s.size()) { %s.erase(%s.begin(), %s.end());' %(s,target, target,target,target),\n                    #       '} else { %s.erase(%s.begin(), %s.begin()+%s); }' %(target,target,target, self.visit(slice.upper)),\n                    #       '%s.insert(%s.begin(), %s.begin(), %s.end());' %(target, target, value,value)\n                    #   ]\n                    #return '\\n'.join(r)\n                else:\n                    r = [\n                        'if (%s  = %s- size()) { %s- erase(%s- begin(), %s- end());' %(s,target, target,target,target),\n                        '} else { %s- erase(%s- begin(), %s- begin()+%s); }' %(target,target,target, self.visit(slice.upper)),\n                        '%s- insert(%s- begin(), %s- begin(), %s- end());' %(target, target, value,value)\n                    ]\n                    return '\\n'.join(r)\n            elif slice.lower and not slice.upper:\n                if self._memory[-1]=='STACK':\n                    if target in self._known_arrays and isinstance(self._known_arrays[target], tuple):\n                        fixed_size = self._known_arrays[target][1]\n                        r = [\n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s; __i %s; __i++) {' %(self.visit(slice.lower), fixed_size),\n                            self.indent()+'  %s[__i] = %s[__L];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ]\n                        return '\\n'.join(r)\n                    else:\n                        r = [\n                            '%s.erase(%s.begin()+%s, %s.end());' %(target,target,self.visit(slice.lower), target),\n                            '%s.insert(%s.end(), %s.begin(), %s.end());' %(target, target, value,value)\n                        ]\n                        return '\\n'.join(r)\n                else:\n                    r = [\n                        '%s- erase(%s- begin()+%s, %s- end());' %(target,target,self.visit(slice.lower), target),\n                        '%s- insert(%s- end(), %s- begin(), %s- end());' %(target, target, value,value)\n                    ]\n                    return '\\n'.join(r)\n\n            else:\n                raise RuntimeError('TODO slice assignment lower and upper limits')\n\n        else:\n            target = self.visit( node.targets[0] )\n            self._assign_var_name = target\n            if target.startswith('std::get '):\n                ## note: there is no `std::set` because tuples can not change once constructed.\n                #return 'std::set' + target[ len('std::set') : -1 ] + ',' + self.visit(node.value) + ');'\n                raise SyntaxError(self.format_error('tuple items can not be reassigned'))\n        #######################\n\n        if self._cpp and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute) and node.value.func.attr in ('pop', 'insert'):\n            arrname = self.visit(node.value.func.value)\n            if arrname in self._known_arrays:\n                if node.value.func.attr=='insert':\n                    raise RuntimeError('invalid assignment, array.insert returns nothing.')\n\n                elif node.value.func.attr=='pop':\n                    popindex = None\n                    if node.value.args: popindex = self.visit(node.value.args[0])\n                    ######################\n                    if popindex == '0':\n                        if self._memory[-1]=='STACK':\n                            result.append('auto %s = %s[0];' %(target, arrname))\n                            result.append('%s.erase(%s.begin(),%s.begin()+1);' %(arrname,arrname,arrname))\n                        else:\n                            result.append('auto %s = (*%s)[0];' %(target, arrname))\n                            result.append('%s- erase(%s- begin(),%s- begin()+1);' %(arrname,arrname,arrname))\n                    elif popindex==None or popindex == '-1':\n                        if self._memory[-1]=='STACK':\n                            result.append('auto %s = %s[ %s.size()-1 ];' %(target, arrname, arrname))\n                            result.append('%s.pop_back();' %arrname)\n                        else:\n                            result.append('auto %s = (*%s)[ %s- size()-1 ];' %(target, arrname, arrname))\n                            result.append('%s- pop_back();' %arrname)\n                    else:\n                        raise SyntaxError('TODO array.pop(n)', popindex)\n\n                return '\\n'.join(result)\n\n            else:\n                ## do nothing because we are not sure if this is an array\n                pass\n\n\n        #######################\n        if isinstance(node.value, ast.BinOp) and self.visit(node.value.op)==' ' and isinstance(node.value.left, ast.Name) and node.value.left.id=='__go__send__':\n            value = self.visit(node.value.right)\n            self._has_channels = True\n            if self._cpp:\n                ## cpp-channel API\n                return '%s.send(%s);' % (target, value)\n            elif self._rust:\n                return '%s.send(%s).unwrap();' % (target, value)  ## Rust1.2 API, must call unwrap after send.\n            else: ## Go\n                return '%s  - %s;' % (target, value)\n\n        elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='__go__':\n            thread = target\n            spawn_func = self.visit(node.value.args[0])\n            if isinstance(node.value.args[0], ast.Name):\n                spawn_func += '()'\n\n            #closure_wrapper = '[ ]{%s;}'%spawn_func  ## do not capture loop variants\n            closure_wrapper = '[=]{%s;}'%spawn_func\n\n            if self._memory[-1]=='STACK':\n                return 'std::thread %s( %s );' %(thread, closure_wrapper)\n            else:\n                return 'auto %s = std::shared_ptr std::thread ( new std::thread(%s) );' %(thread, closure_wrapper)\n\n        elif not self._function_stack:  ## global level\n            value = self.visit(node.value)\n            if isinstance(value, tuple):\n                assert self._cpp\n                if len(value)==2:\n                    if self._memory[-1]=='STACK':\n                        return '%s %s%s;' %(value[0], target, value[1] )\n                    else:\n                        return 'auto %s = std::make_shared %s (%s);' %(target, value[0], ','.join(value[1]) )\n                elif len(value)==3:\n                    arrtype, arrsize, arrcon = value\n                    return 'auto %s = std::make_shared %s (%s);' %(target, arrtype, arrsize)\n\n                else:\n                    raise RuntimeError(value)\n\n\n\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id in self._classes:\n                if self._rust:\n                    value = '__new__' + value\n                    return 'let %s *%s = %s;' % (target, node.value.func.id, value)  ## rust, TODO can c++ construct globals on the heap outside of function?\n                else:\n                    return 'auto %s = %s;' %(target, value)\n            else:\n                guesstype = 'auto'\n                if isinstance(node.value, ast.Num):\n                    guesstype = 'int'\n                elif isinstance(node.value, ast.Str):\n                    guesstype = 'string'\n                elif self._rust:\n                    if isinstance(node.value, ast.Name) and node.value.id=='None':\n                        raise SyntaxError( self.format_error('untyped global set to None'))\n                    else:\n                        raise SyntaxError( self.format_error('untyped global'))\n\n                ## save info about globals ##\n                if isinstance(node.targets[0], ast.Name):\n                    self._globals[ node.targets[0].id ] = guesstype\n                if guesstype not in self._global_types:\n                    self._global_types[guesstype] = set()\n                self._global_types[guesstype].add( target )\n\n                ## we need a syntax for static/const ##\n                isprim = self.is_prim_type(guesstype)\n                if self._cpp:\n                    if guesstype=='string':\n                        #return 'const std::string %s = %s;' % (target, value)\n                        return 'std::string %s = %s;' % (target, value)\n                    elif isprim or guesstype=='auto':\n                        return '%s %s = %s;' % (guesstype, target, value)\n                    else:\n                        if not self._shared_pointers:\n                            return '%s* %s = %s;' % (guesstype, target, value)\n                        elif self._unique_ptr:\n                            return 'std::unique_ptr %s  %s = %s;' % (guesstype, target, value)\n                        else:\n                            return 'std::shared_ptr %s  %s = %s;' % (guesstype, target, value)\n\n                else:\n                    return 'static %s : %s = %s;' % (target, guesstype, value)\n\n        elif isinstance(node.targets[0], ast.Name) and node.targets[0].id in self._vars:\n            ## first assignment of a known variable, this requires 'auto' in c++, or `let` in rust.\n            ## note that the first pass of translation picks up all local variables traversing into\n            ## all nested structures and loops (not block scoped)\n            self._vars.remove( target )\n            self._known_vars.add( target )\n            node._new_assignment = target\n\n            #if len(self._stack) =2 and isinstance(self._stack[-2], ast.For):\n            #   raise RuntimeError(self._stack)\n\n            if isinstance(node.value, ast.Str):  ## catch strings for `+=` hack\n                self._known_strings.add( target )\n\n            try:\n                value = self.visit(node.value)\n\n            except GenerateListComp as error:  ## new style to generate list comprehensions\n                compnode = error[0]\n\n                if not isinstance(node.value, ast.BinOp):\n                    ## try to guess type of list comprehension ##\n                    if isinstance(compnode.elt, ast.Call) and isinstance(compnode.elt.func, ast.Name) and compnode.elt.func.id in self._classes:\n                        return self._listcomp_helper(\n                            compnode,\n                            target=target,\n                            type=compnode.elt.func.id\n                        )\n\n                    raise SyntaxError( self.format_error('untyped list comprehension') )\n\n                comptarget = None\n                comptype = None\n                arrtype  = None\n\n                if isinstance(node.value.left, ast.Call):\n                    assert node.value.left.func.id in ('__go__array__', '__go__arrayfixed__')\n                    comptype = node.value.left.func.id\n                    if comptype == '__go__array__':\n                        comptarget = target\n                        comptype = node.value.left.func.id\n                        arrtype  = self.visit(node.value.left.args[0])\n\n                        return self._listcomp_helper(\n                            compnode,\n                            target=comptarget,\n                            type=arrtype\n                        )\n                    else:\n\n                        return self._listcomp_helper(\n                            compnode,\n                            target=target,\n                            type=self.visit(node.value.left.args[1]),\n                            size=self.visit(node.value.left.args[0]),\n                        )\n\n                elif isinstance(node.value.left, ast.BinOp):\n                    ## This happens when the constructor contains a list of items,\n                    ## and one of the items is an list comp, `result` gets shoved\n                    ## into one of the slots in the constuctor.\n                    ## This can also happens when a 1/2D array contains just a single\n                    ## list comp, `arr = [][]int((1,2,3) for i in range(4))`,\n                    ## creates a 4x3 2D array, in this case the list comp needs\n                    ## to be regenerated as 2D below.\n                    comptype = node.value.left.left.id=='__go__array__'\n                    if (node.value.left.left, ast.Name) and node.value.left.left.id=='__go__array__':\n                        arrtype = node.value.left.right.args[0].id\n                        comptarget = '_subcomp_'+target\n                        result.append(\n                            self._listcomp_helper(\n                                compnode,\n                                target=comptarget,\n                                type=arrtype\n                            )\n                        )\n\n                    else:\n                        raise RuntimeError('TODO mdarray subtype')\n                else:\n                    raise RuntimeError(node.value.left)\n\n\n            except GenerateSlice as error:  ## special c++ case for slice syntax\n                assert self._cpp\n                msg = error[0]\n                slice_type = None  ## slice on an unknown type is broken and will segfault - TODO fix this\n                result_size = None\n                if msg['value'] in self._known_arrays:\n                    slice_type = self._known_arrays[msg['value']]\n\n                    ## stack allocated array ##\n                    if isinstance(self._known_arrays[msg['value']], tuple):\n                        new_type   = list(slice_type)\n                        if msg['lower'] and not msg['upper']:\n                            if new_type[1].isdigit() and msg['lower'].isdigit():\n                                result_size = int(new_type[1]) - int(msg['lower'])\n                                new_type[1] = str(result_size)\n                            else:\n                                new_type[1] += '-%s' %msg['lower']\n                        elif not msg['lower'] and msg['upper']:\n                            if new_type[1].isdigit() and msg['upper'].isdigit():\n                                result_size = int(new_type[1]) - int(msg['upper'])\n                                new_type[1] = str(result_size-1)\n                            else:\n                                new_type[1] += '-%s' %msg['upper']\n                        elif not msg['lower'] and not msg['upper']:\n                            ## slice copy, same size\n                            if slice_type[1].isdigit():\n                                result_size = int(slice_type[1])\n                            else:\n                                result_size = slice_type[1]\n\n                        else:\n                            new_type[1]= None\n                        self._known_arrays[target] = tuple(new_type)\n\n                    else:\n                        self._known_arrays[target] = slice_type\n\n                return self._gen_slice(\n                    target,\n                    value=msg['value'],\n                    lower=msg['lower'],\n                    upper=msg['upper'],\n                    step =msg['step'],\n                    type=slice_type,\n                    result_size = result_size\n                )\n\n\n            if isinstance(node.value, ast.Num):\n                if type(node.value.n) is int:\n                    if self._cpp:\n                        pass\n                    else:\n                        value += 'i64'\n\n            if value=='None':\n                if self._cpp:\n                    raise RuntimeError('invalid in c++ mode')  ## is this possible in c++14?\n                else:  ## TODO, this is a bad idea?  letting rust infer the type should have its own syntax like `let x;`\n                    return 'let mut %s;  /* let rust infer type */' %target\n\n\n\n            if not self._cpp and isinstance(node.value, ast.BinOp) and self.visit(node.value.op)==' ' and isinstance(node.value.left, ast.Call) and isinstance(node.value.left.func, ast.Name) and node.value.left.func.id=='__go__map__':\n                key_type = self.visit(node.value.left.args[0])\n                value_type = self.visit(node.value.left.args[1])\n\n                if isinstance(node.value.left.args[0], ast.Str):\n                    raise RuntimeError(node.value.left.args[0])\n\n                if isinstance(node.value.left.args[1], ast.Str):\n                    raise RuntimeError(node.value.left.args[1])\n\n                if key_type=='string': key_type = 'String'\n                if value_type=='string': value_type = 'String'\n                self._known_maps[ target ] = (key_type, value_type)\n\n                a = []\n                for i in range( len(node.value.right.keys) ):\n                    k = self.visit( node.value.right.keys[ i ] )\n                    v = self.visit( node.value.right.values[i] )\n                    a.append( '_ref_%s.insert(%s,%s);'%(target,k,v) )\n                v = '\\n'.join( a )\n                r  = 'let mut _ref_%s = HashMap:: %s, %s ::new();\\n%s\\n' %(target, key_type, value_type, v)\n                r += 'let mut %s =  _ref_%s;' %(target, target)\n                return r\n\n            elif self._cpp and isinstance(node.value, ast.BinOp) and self.visit(node.value.op)==' ':\n\n                if isinstance(node.value.left, ast.BinOp) and isinstance(node.value.op, ast.LShift):  ## 2D Array\n                    ## c++ vector of vectors ##\n                    ## std::shared_ptr  std::vector std::shared_ptr std::vector T   \n\n                    if isinstance(node.value.left.left, ast.Name) and node.value.left.left.id=='__go__array__':\n\n                        T = self.visit(node.value.left.right.args[0])\n                        if T=='string': T = 'std::string'\n                        self._known_arrays[ target ] = T\n                        if not self.is_prim_type(T):\n                            T = 'std::shared_ptr %s ' %T\n\n                        subvectype = 'std::vector %s ' %T\n                        if self._memory[-1]=='STACK':\n                            vectype = 'std::vector %s ' %subvectype\n                        elif not self._shared_pointers:\n                            vectype = 'std::vector %s* ' %subvectype\n                        elif self._unique_ptr:\n                            vectype = 'std::vector std::unique_ptr %s ' %subvectype\n                        else:\n                            vectype = 'std::vector std::shared_ptr %s ' %subvectype\n\n\n                        if isinstance(node.value.right, ast.Tuple):\n                            r = ['/* %s = vector of vectors to: %s */' %(target,T)]\n                            args = []\n                            for i,elt in enumerate(node.value.right.elts):\n                                if isinstance(elt, ast.Tuple):\n                                    subname = '_sub%s_%s' %(i, target)\n                                    args.append( subname )\n                                    sharedptr = False\n                                    for sarg in elt.elts:\n                                        if isinstance(sarg, ast.Name) and sarg.id in self._known_instances:\n                                            sharedptr = True\n                                            if self._memory[-1]=='STACK':\n                                                subvectype = 'std::vector %s ' %T\n                                                vectype = 'std::vector %s ' %subvectype\n\n                                            elif not self._shared_pointers:\n                                                subvectype = 'std::vector %s* ' %T\n                                                vectype = 'std::vector %s* ' %subvectype\n                                            elif self._unique_ptr:\n                                                subvectype = 'std::vector   std::unique_ptr %s    ' %T\n                                                vectype = 'std::vector  std::unique_ptr %s   ' %subvectype\n                                            else:\n                                                subvectype = 'std::vector   std::shared_ptr %s    ' %T\n                                                vectype = 'std::vector  std::shared_ptr %s   ' %subvectype\n\n\n                                    subargs = [self.visit(sarg) for sarg in elt.elts]\n                                    if self._memory[-1]=='STACK':\n                                        r.append('%s %s = {%s};' %(subvectype, subname, ','.join(subargs)))  ## direct ref\n                                    else:\n                                        r.append(self.indent()+'%s _r_%s = {%s};' %(subvectype, subname, ','.join(subargs)))\n\n                                        if not self._shared_pointers:\n                                            r.append(\n                                                self.indent()+'%s* %s =  _r_%s;' %(subvectype, subname, subname)\n                                            )\n\n                                        elif self._unique_ptr:\n                                            r.append(\n                                                self.indent()+'std::unique_ptr %s  %s = _make_unique %s (_r_%s);' %(subvectype, subname, subvectype, subname)\n                                            )\n\n                                        else:\n                                            r.append(\n                                                self.indent()+'std::shared_ptr %s  %s = std::make_shared %s (_r_%s);' %(subvectype, subname, subvectype, subname)\n                                            )\n\n                                elif isinstance(elt, ast.ListComp):\n                                    r.extend(result)\n                                    args.append('_subcomp_%s'%target)  ## already a shared_ptr\n\n                                else:\n                                    args.append( self.visit(elt) )\n\n                            if self._memory[-1]=='STACK':\n                                r.append(self.indent()+'%s %s = {%s};' %(vectype, target, ','.join(args)))\n\n                            else:\n                                #r.append(self.indent()+'%s _ref_%s = {%s};' %(vectype, target, ','.join(args)))\n                                heapargs = []\n                                for arg in args:\n                                    if arg.startswith('new std::vector'):\n                                        vtype = arg[ len('new ') : ].split('{')[0]\n                                        arg = 'std::shared_ptr %s (%s)' %(vtype, arg)\n                                    heapargs.append( self.indent() + '\\t' + arg )\n\n                                if not self._shared_pointers:\n                                    r.append(\n                                        self.indent()+'%s* %s = {%s};' %(vectype, target, ','.join(args))\n                                    )\n\n                                elif self._unique_ptr:  ## TODO test and fixme\n                                    r.append(\n                                        self.indent()+'std::unique_ptr %s  %s = _make_unique %s (_ref_%s);' %(vectype, target, vectype, target)\n                                    )\n                                else:\n                                    r.append(\n                                        self.indent()+'auto %s = std::make_shared %s (%s{%s});' %(target, vectype, vectype, ',\\n'.join(heapargs))\n                                    )\n\n                            return (self.indent()+'\\n').join(r)\n\n                        elif isinstance(node.value.right, ast.ListComp):\n                            compnode = node.value.right\n                            return self._listcomp_helper(\n                                compnode,\n                                target=target,\n                                type=T,\n                                dimensions=2\n                            )\n\n                    elif isinstance(node.value.left.right, ast.Name) and node.value.left.right.id=='__as__':\n                        return self.indent()+'auto %s = %s;' %(target, value)\n\n                    else:\n                        raise RuntimeError('TODO other md-array types', node.value)\n\n\n                elif isinstance(node.value.left, ast.Call) and isinstance(node.value.left.func, ast.Name) and node.value.left.func.id in COLLECTION_TYPES:\n                    S = node.value.left.func.id\n                    if S == '__go__map__':\n                        key_type = self.visit(node.value.left.args[0])\n                        value_type = self.visit(node.value.left.args[1])\n                        value_vec  = None\n                        if not self.is_prim_type(value_type):\n                            value_type = 'std::shared_ptr %s ' %value_type\n\n                        if isinstance(node.value.left.args[0], ast.Str):\n                            raise RuntimeError('TODO dict key type from string: %s' %value_type)\n\n                        if isinstance(node.value.left.args[1], ast.Str):\n                            value_type = node.value.left.args[1].s\n                            value_vec  = value_type.split(']')[-1]\n                            if self._memory[-1]=='STACK':\n                                value_type = 'std::vector %s ' %value_vec\n                            else:\n                                value_type = 'std::vector %s *' %value_vec\n                        elif isinstance(node.value.left.args[1], ast.Tuple):\n                            raise RuntimeError('TODO map and tuple')\n                        elif value_type.startswith('{') and value_type.endswith('}'):\n                            raise RuntimeError(self.format_error('invalid value_type: %s' %value_type))\n                        elif '{' in value_type:\n                            raise RuntimeError('TODO { in value_type')\n\n                        #####################\n                        if key_type=='string':\n                            if self.usertypes and 'string' in self.usertypes:\n                                key_type = self.usertypes['string']['type']\n                            else:\n                                key_type = 'std::string'\n\n\n                        if value_type=='string':\n                            if self.usertypes and 'string' in self.usertypes:\n                                value_type = self.usertypes['string']['type']\n                            else:\n                                value_type = 'std::string'\n\n                        self._known_maps[ target ] = (key_type, value_type)\n\n                        #keyvalues = []\n                        a = []\n                        for i in range( len(node.value.right.keys) ):\n                            k = self.visit( node.value.right.keys[ i ] )\n                            v = self.visit( node.value.right.values[i] )\n                            if v.startswith('[') and v.endswith(']'):\n                                if self._memory[-1]=='STACK':\n                                    v = ('std::vector %s {'%value_vec) + v[1:-1] + '}'\n                                else:\n                                    v = ('new std::vector %s {'%value_vec) + v[1:-1] + '}'\n                            a.append( '{%s,%s}'%(k,v) )\n                        #   keyvalues.append( (k,v) )\n                        #v = ', '.join( a )\n                        initlist = '{%s}' %'\\n,'.join(a)\n                        map_type = 'std::map %s,%s ' %(key_type, value_type)\n                        if self._memory[-1]=='STACK':\n                            return 'auto %s = %s%s;' %(target, map_type, initlist)\n\n                        else:\n                            return 'auto %s = std::shared_ptr %s (new %s%s);' %(target, map_type, map_type, initlist)\n\n\n                        ## DEPRECATED c++11 shared pointer\n                        if self.usertypes and 'map' in self.usertypes:\n                            maptype = self.usertypes['map']['template'] % (key_type, value_type)\n                            st = self.usertypes['shared']['template']\n                            r = ['%s _ref_%s();' %(maptype, target)]\n                            if keyvalues:\n                                for key,val in keyvalues:\n                                    r.append('_ref_%s[%s] = %s;' %(target,key,val))\n                            r.append('%s %s( _ref_%s);' %(st%maptype, target, target))\n                            return '\\n'.join(r)\n\n                        elif self._shared_pointers:\n                            maptype = 'std::map %s, %s ' %(key_type, value_type)\n                            r = '%s _ref_%s = {%s};' %(maptype, target, v)\n                            if self._unique_ptr:\n                                r += 'std::unique_ptr %s  %s = _make_unique %s (_ref_%s);' %(maptype, target, maptype, target)\n                            else:\n                                r += 'std::shared_ptr %s  %s = std::make_shared %s (_ref_%s);' %(maptype, target, maptype, target)\n                            return r\n                        else:  ## raw pointer\n                            return 'std::map %s, %s  _ref_%s = {%s}; auto %s =  _ref_%s;' %(key_type, value_type, target, v, target, target)\n\n                    elif 'array' in S:\n                        args = []\n                        for elt in node.value.right.elts:\n                            #if isinstance(elt, ast.Num):\n                            args.append( self.visit(elt) )\n\n                        if S=='__go__array__':\n                            T = self.visit(node.value.left.args[0])\n                            if T in self.macros:\n                                T = self.macros[T]\n                            isprim = self.is_prim_type(T)\n                            if T=='string':\n                                if self.usertypes and 'string' in self.usertypes:\n                                    T = self.usertypes['string']['type']\n                                else:\n                                    T = 'std::string'\n                            self._known_arrays[ target ] = T\n                            if T=='tuple':\n                                tupleargs = []\n                                for elt in node.value.right.elts:\n                                    #raise RuntimeError(elt.func.id)\n                                    tupleargs.append( self.visit(elt) )\n\n                                #for arg in args:\n                                #   if arg.startswith('[]')\n                                #   args.append( self.visit(elt) )\n\n                                #return 'std::shared_ptr std::vector std::tuple %s  %s;' %(','.join(tupleargs), target)\n                                if self._memory[-1]=='STACK':\n                                    tuplevec = 'std::vector std::tuple %s ' %','.join(tupleargs)\n                                    self._known_refs[target] = tuplevec\n                                    return 'auto %s = %s();' %(target, tuplevec)\n                                else:\n                                    tuplevec = 'std::vector  std::shared_ptr std::tuple %s   ' %','.join(tupleargs)\n                                    return 'auto %s = std::make_shared %s (%s());' %(target, tuplevec, tuplevec)\n\n                            if self.usertypes and 'vector' in self.usertypes:\n                                vtemplate = self.usertypes['vector']['template']\n                                stemplate = 'std::shared_ptr %s '\n                                if 'shared' in self.usertypes:\n                                    stemplate = self.usertypes['shared']['template']\n                                if isprim:\n                                    vectype = vtemplate%T\n                                else:\n                                    vectype = vtemplate % stemplate % T\n                                return '%s %s = {%s};' %(vectype, target, ','.join(args))\n\n                            elif self._shared_pointers:\n                                if isprim or self._memory[-1]=='STACK':\n                                    vectype = 'std::vector %s ' %T\n                                    constuct = '(new std::vector %s ({%s}))' %(T, ','.join(args))\n                                else:\n                                    if self._unique_ptr:\n                                        vectype = 'std::vector std::unique_ptr %s ' %T\n                                    else:\n                                        vectype = 'std::vector std::shared_ptr %s ' %T\n                                        #constuct = '( new std::vector std::shared_ptr %s (new std::shared_ptr %s (%s)) )' %(T,T, ','.join(args))\n                                        constuct = '( new std::vector std::shared_ptr %s ({%s}) )' %(T, ','.join(args))\n\n                                ## old style using std::make_shared\n                                #r = '%s _ref_%s = {%s};' %(vectype, target, ','.join(args))\n                                #if self._unique_ptr:\n                                #   r += 'std::unique_ptr %s  %s = _make_unique %s (_ref_%s); /* 1D Array */' %(vectype, target, vectype, target)\n                                #else:\n                                #   r += 'std::shared_ptr %s  %s = std::make_shared %s (_ref_%s); /* 1D Array */' %(vectype, target, vectype, target)\n                                #return r\n\n                                ## new style\n                                if self._memory[-1]=='STACK':\n                                    self._known_pointers[target] = vectype\n                                    return '%s* %s = %s; /* 1D Array */' %(vectype, target, constuct )\n                                elif self._unique_ptr:\n                                    r += 'std::unique_ptr %s  %s = _make_unique %s (_ref_%s); /* 1D Array */' %(vectype, target, vectype, target)\n                                else:\n                                    #return 'std::shared_ptr %s  %s = std::shared_ptr %s ( new %s(%s) ); /* 1D Array */' %(vectype, target,vectype, vectype, ','.join(args) )\n                                    return 'std::shared_ptr %s  %s( %s ); /* 1D Array */' %(vectype, target,constuct )\n\n                            else:  ## raw pointer\n                                if isprim:\n                                    return 'std::vector %s   _ref_%s = {%s}; auto %s =  _ref_%s;' %(T, target, ','.join(args), target, target)\n                                else:\n                                    return 'std::vector %s*   _ref_%s = {%s}; auto %s =  _ref_%s;' %(T, target, ','.join(args), target, target)\n\n                        elif S=='__go__arrayfixed__':\n                            asize = self.visit(node.value.left.args[0])\n                            atype = self.visit(node.value.left.args[1])\n                            self._known_arrays[ target ] = (atype,asize)\n                            if self._memory[-1]=='STACK':\n                                return '%s %s[%s] = {%s};' %(atype, target, asize, ','.join(args))\n\n                            elif self._shared_pointers:\n                                #vectype = 'std::array %s, %sul ' %(atype, asize)  ## what api or syntax should we use for fixed size arrays?\n                                if self.is_prim_type(atype):\n                                    vectype = 'std::vector %s ' %atype\n                                else:\n                                    vectype = 'std::vector std::shared_ptr %s ' %atype\n\n                                r = '%s _ref_%s = {%s};' %(vectype, target, ','.join(args))\n                                r += '_ref_%s.resize(%s);' %(target, asize)\n                                if self._unique_ptr:\n                                    r += 'std::unique_ptr %s  %s = _make_unique %s (_ref_%s);' %(vectype, target, vectype, target)\n                                else:\n                                    r += 'std::shared_ptr %s  %s = std::make_shared %s (_ref_%s);' %(vectype, target, vectype, target)\n                                return r\n                            else:\n                                ## note: the inner braces are due to the nature of initializer lists, one per template param.\n                                #return 'std::array %s, %s   %s = {{%s}};' %(atype, asize, target, ','.join(args))\n                                ## TODO which is correct? above with double braces, or below with none?\n                                return 'std::array %s, %sul   _ref_%s  {%s}; auto %s =  _ref_%s;' %(atype, asize, target, ','.join(args), target, target)\n\n                elif isinstance(node.value.left, ast.Name) and node.value.left.id=='__go__receive__':\n                    if target in self._known_vars:\n                        return 'auto %s = %s;' %(target, self.visit(node.value))  ## TODO check this is this a bug? should not be `auto`\n                    else:\n                        return 'auto %s = %s;' %(target, self.visit(node.value))\n\n                elif isinstance(node.value.left, ast.Attribute) and node.value.left.attr=='__doubledot__':\n                    pyob = self.visit(node.value.left.value)\n                    if isinstance(node.value.right, ast.Name):\n                        attr = node.value.right.id\n                        return 'auto %s = %s;' %(target, self.gen_cpy_get(pyob, attr))\n                    elif isinstance(node.value.right, ast.Call):\n                        return 'auto %s = %s;' %(target, self.gen_cpy_call(pyob, node.value.right))\n                    else:\n                        raise RuntimeError('TODO x=y- ?')\n\n                else:\n                    #raise SyntaxError(('invalid   hack', node.value.left.attr))\n                    #raise SyntaxError(('invalid   hack', self.visit(node.value.right)))\n                    raise SyntaxError(('invalid   hack', node.value.right))\n\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Attribute) and isinstance(node.value.func.value, ast.Name):\n                varname = node.value.func.value.id\n                info = varname + '  '\n\n                if varname in self._known_vars and varname in self._known_instances and self._go:  ## TODO, c++ backend\n                    ## generics generator ##\n                    #raise SyntaxError(varname + ' is known class::' + self._known_instances[varname] + '%s(%s)' % (fname, args))\n                    cname = self._known_instances[varname]\n                    info += 'class: ' + cname\n                    if node.value.func.attr in self.method_returns_multiple_subclasses[ cname ]:\n                        self._known_instances[target] = cname\n                        raise GenerateGenericSwitch( {'target':target, 'value':value, 'class':cname, 'method':node.value.func.attr} )\n\n                if self._cpp:\n                    #if value.startswith('__cpython_call__'):  ## logic no longer requires _known_pyobjects\n                    #   self._known_pyobjects[ target ] = varname\n                    return 'auto %s = %s;           /* %s */' % (target, value, info)\n                else:\n                    if '.borrow_mut()' in value:\n                        return 'let mut %s = %s;            /* %s */' % (target, value, info)\n                    else:\n                        return 'let %s = %s;            /* %s */' % (target, value, info)\n\n\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n\n                ## creation of a new class instance and assignment to a local variable\n                if node.value.func.id=='new' and isinstance(node.value.args[0],ast.Call) and isinstance(node.value.args[0].func, ast.Name) and not node.value.args[0].func.id.startswith('_'):\n                    classname = node.value.args[0].func.id\n                    value = self.visit(node.value.args[0])\n                    self._known_instances[ target ] = classname\n\n                    if self._cpp:\n                        if classname in self._classes:\n                            if self._memory[-1]=='HEAP':\n                                return 'auto %s = %s; // heap-object' %(target, value)\n                            else:\n                                return 'auto %s = %s; // stack-object' %(target, value)\n                        else:\n                            if self._memory[-1]=='HEAP':\n                                return 'auto %s = new %s; // heap-xobject' %(target, value)\n                            else:\n                                return 'auto %s = %s; // stack-xobject' %(target, value)\n\n                        if self._unique_ptr:\n                            ## TODO fix everywhere, check visit_binop\n                            ## raise RuntimeError(self.visit(node.value))\n                            if 'std::shared_ptr' in value:\n                                value = value.replace('shared_ptr', 'make_unique')  ## c++14\n                                vh,vt = value.split('- __init__')\n                                value = vh.split('((')[0] + '()- __init__' + vt[:-1]\n\n                        elif self._memory[-1]=='HEAP':\n                            if value.count('- __init__(')   1:\n                                print 'WARNING: in heap mode with shared pointers,'\n                                print 'objects should be assigned to a variable before'\n                                print 'passing them to the constructor of another object'\n                                print 'target=', target\n                                print 'pre-value=', value\n                                x = value[  : value.index('- __init__(') ] + ')'\n                                y = value[ value.index('- __init__(') : ][:-1]\n                                value = x+y\n                                print 'post-value=', value\n                            elif '- __init__(' in value:\n                                vh,vt = value.split('- __init__')\n                                if is_new:\n                                    value = '%s); %s- __init__%s' %(vh, target, vt[:-1])\n                                else:\n                                    value = '%s); %s- __init__%s' %(vh, target, vt[:-1])\n\n                            return 'auto %s = %s; // heap-object' %(target, value)\n\n                        elif is_new:\n                            return 'auto %s = new %s; // new-object' %(target, value)\n                        else:\n                            return 'auto %s = %s; // stack-object' %(target, value)\n\n                    else:  ## rust\n                        self._construct_rust_structs_directly = False\n\n                        if self._construct_rust_structs_directly:  ## NOT DEFAULT\n                            ## this is option is only useful when nothing is happening\n                            ## in __init__ other than assignment of fields, rust enforces that\n                            ## values for all struct field types are given, and this can not\n                            ## map to __init__ logic where some arguments have defaults.\n\n                            ## convert args into struct constructor style `name:value`\n                            args = []\n                            for i,arg in enumerate(node.value.args):\n                                args.append( '%s:%s' %(self._classes[classname]._struct_init_names[i], self.visit(arg)))\n                            if node.value.keywords:\n                                for kw in node.value.keywords:\n                                    args.append( '%s:%s' %(kw.arg, self.visit(kw.value)))\n\n                            return 'let %s =  mut %s{ %s };' %(target, classname, ','.join(args))  ## directly construct struct, this requires all arguments are given.\n\n                        else:\n                            ## RUST DEFAULT create new class instance\n                            ## by calling user constructor __init__\n                            ## SomeClass::new(init-args) takes care of making the struct with\n                            ## default null/empty/zeroed values.\n\n                            ## note: methods are always defined with ` mut self`, this requires that\n                            ## a mutable reference is taken so that methods can be called on the instance.\n\n                            ## old ref style\n                            #value = self._visit_call_helper(node.value, force_name=classname+'::new')\n                            #return 'let %s =  mut %s;' %(target, value)\n\n                            ## new reference counted mutable style\n                            value = self._visit_call_helper(node.value)\n                            return 'let %s : Rc RefCell %s  = %s;' %(target, classname, value)\n                else:\n                    if self._cpp:\n                        if isinstance(node.value, ast.Expr) and isinstance(node.value.value, ast.BinOp) and self.visit(node.value.value.op)==' ':\n                            raise SyntaxError(node.value.value.left)\n                        elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='new':\n                            V = self.visit(node.value.args[0])\n                            if isinstance(V, tuple):\n                                vType, vInit = V\n                                if isinstance(vInit, list):\n                                    return 'auto %s = new %s({%s});' %(target, vType, ','.join(vInit))\n                                else:\n                                    if vType.endswith('*'):\n                                        vType = vType[:-1]\n                                        return 'auto %s = new %s%s;' %(target, vType, vInit)\n                                    else:\n                                        raise RuntimeError('not a pointer?')\n                                        return '%s %s %s;' %(vType, target, vInit)\n\n                            else:\n                                return 'auto %s = %s;           /* new variable*/' % (target, value)\n                        else:\n                            return 'auto %s = %s;           /* new variable*/' % (target, value)\n                    else:\n                        return 'let %s = %s;            /* new variable */' % (target, value)\n\n            else:\n                if self._cpp:\n                    #raise RuntimeError((node.value.left, node.value.right, node.value.op))\n                    if comptarget:\n                        result.append('auto %s = %s;  /* list comprehension */' % (target, comptarget))\n                        return '\\n'.join(result)\n                    elif isinstance(node.value, ast.BinOp) and isinstance(node.value.op, ast.RShift) and isinstance(node.value.left, ast.Name) and node.value.left.id=='__new__':\n                        self._known_instances[target] = self.visit(node.value.right)\n                        return 'auto %s = %s;  /* new object */' % (target, value)\n                    elif isinstance(node.value, ast.Tuple):\n\n                        tupletype = []\n                        for telt in node.value.elts:\n                            if isinstance(telt, ast.Str):  ## TODO test tuple with strings\n                                v = telt.s\n                                if v.startswith(' ') and v.endswith(' '):  ## TODO this looks like a bug\n                                    v = v[1:-1]\n                            elif isinstance(telt, ast.List): #v.startswith('[') and v.endswith(']'):\n                                tsubvec = None\n                                for st in telt.elts:\n                                    if isinstance(st, ast.Num):\n                                        tsubvec = 'float64'\n                                        break\n                                assert tsubvec is not None\n                                v = 'std::vector %s ' %tsubvec\n\n\n                            elif isinstance(telt, ast.Num):\n                                v = 'float64'\n                            elif isinstance(telt, ast.Name):\n                                v = 'decltype(%s)' % self.visit(telt)\n                            else:\n                                v = self.visit(telt)\n\n                            if v.startswith('[]'):\n                                t  = v.split(']')[-1]\n                                if self._memory[-1]=='STACK':\n                                    v = 'std::vector %s ' %t\n                                else:\n                                    v = 'std::vector %s *' %t\n\n                            tupletype.append(v)\n\n\n                        targs = []\n                        for ti,te in enumerate(node.value.elts):\n                            tt = tupletype[ti]\n                            tv = self.visit(te)\n                            if tv.startswith('[') and tv.endswith(']'):\n                                assert tt.startswith('std::vector')\n                                if tt.endswith('*'):\n                                    tv = '(new %s{%s})' %(tt[:-1], tv[1:-1])\n                                else:\n                                    tv = '%s{%s}' %(tt, tv[1:-1])\n                            #elif tv.startswith('std::vector'):  ## never happens?\n                            #   raise RuntimeError(tv)\n\n                            if tt.startswith('std::vector') and self._memory[-1]=='HEAP':\n                                tupletype[ti] = 'std::shared_ptr %s ' %tt\n                                if not tv.startswith('new '):\n                                    raise RuntimeError(self.format_error(tv))\n                                    tv = 'std::shared_ptr %s (new %s)' %(tt, tv)\n                                else:\n                                    tv = 'std::shared_ptr %s (%s)' %(tt, tv)\n\n                            targs.append(tv)\n\n                        if self._memory[-1]=='STACK':\n                            self._known_refs[target] = 'tuple %s ' % ','.join(targs)\n                            return 'auto %s = std::make_tuple(%s); /*new-tuple*/' %(target, ','.join(targs))\n                        else:\n                            return 'auto %s = std::make_shared std::tuple %s (std::make_tuple(%s)); /*new-tuple*/' %(target, ','.join(tupletype), ','.join(targs))\n                    else:\n                        return 'auto %s = %s;  /* auto-fallback %s */' % (target, value, node.value)\n                else:\n                    if value.startswith('Rc::new(RefCell::new('):\n                        #return 'let _RC_%s = %s; let mut %s = _RC_%s.borrow_mut(); /* new array */' % (target, value, target, target)\n                        self._known_arrays[ target ] = 'XXX'  ## TODO get class name\n                        return 'let %s = %s;    /* new array */' % (target, value)\n                    else:\n                        return 'let mut %s = %s;            /* new muatble */' % (target, value)\n\n        else:\n            ## the variable has already be used, and is getting reassigned,\n            ## or its a destructured assignment, or assignment to an attribute, TODO break this apart.\n\n            is_attr = False\n            is_tuple = False\n            if target not in self._known_vars:\n                if isinstance(node.targets[0], ast.Attribute):\n                    is_attr = True\n                elif isinstance(node.targets[0], ast.Tuple):\n                    is_tuple = True\n                elif isinstance(node.targets[0], ast.Name):\n                    ##assert node.targets[0].id in self._globals\n                    pass\n                elif isinstance(node.targets[0], ast.Subscript):\n                    pass\n                else:\n                    raise SyntaxError( self.format_error(node.targets[0]))\n\n            out = []\n            try:\n                value = self.visit(node.value)\n            except GenerateSlice as error:  ## special c++ case for slice syntax\n                assert self._cpp\n                msg = error[0]\n                slice_type = None  ## slice on an unknown type is broken and will segfault - TODO fix this\n                if msg['value'] in self._known_arrays:\n                    slice_type = self._known_arrays[msg['value']]\n                    self._known_arrays[target] = slice_type\n\n                slice = self._gen_slice(\n                    target,\n                    value=msg['value'],\n                    lower=msg['lower'],\n                    upper=msg['upper'],\n                    step =msg['step'],\n                    type=slice_type,\n                )\n                return slice\n\n            isclass = False\n            isglobal = target in self._globals\n            if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id in self._classes:\n                isclass = True\n\n            if self._cpp:\n                if isclass:\n                    classname = node.value.func.id\n                    self._known_instances[ target ] = classname\n\n                    return '%s = %s;' %(target, value)\n                    ## TODO remove below\n                    #constructor_args = value.strip()[ len(classname)+1 :-1] ## strip to just args\n                    #r = ''\n                    #if isglobal:\n                    #   r += '/* global : %s, type:%s */\\n' %(target, classname)\n                    #r += '%s  _ref_%s = %s{};' %(classname, target, classname)\n                    #if constructor_args:\n                    #   r += '_ref_%s.__init__(%s);' %(target, constructor_args)\n                    #if not self._shared_pointers:\n                    #   r += '\\n%s =  _ref_%s;' %(target, target)\n                    #elif self._unique_ptr:\n                    #   r += '\\n%s = std::make_unique %s (_ref_%s);' %(target, classname, target)\n                    #else:\n                    #   r += '\\n%s = std::make_shared %s (_ref_%s);' %(target, classname, target)\n                    #return r\n\n                elif is_attr and target.startswith('PyObject_GetAttrString(') and target.endswith(')'):\n                    pyob = self.visit(node.targets[0].value.value)\n                    attr = node.targets[0].attr\n                    if isinstance(node.value, ast.Num):\n                        if str(node.value.n).isdigit():\n                            return 'PyObject_SetAttrString(%s,  %s , PyInt_FromLong(%s));'%(pyob,attr, value)\n\n                        else:\n                            return 'PyObject_SetAttrString(%s,  %s , PyFloat_FromDouble(%s));'%(pyob,attr, value)\n\n                    elif isinstance(node.value, ast.Str):\n                        raise RuntimeError('TODO assign str to pyobject')\n                    else:\n                        return 'PyObject_SetAttrString(%s,  %s , %s);'%(pyob,attr, value)\n\n                elif target.startswith('PyObject_CallFunction(') and target.endswith(')'):\n                    ## hackish way to support `pyob- somearray[n]\n                    hack = target.replace(\n                        ' __getitem__ ), i ,',\n                        ' __setitem__ ), iO ,'\n                    )\n                    return '%s, %s);' %( hack[:-1], value )\n\n                elif isinstance(value, tuple):\n                    assert isinstance(node.value, ast.BinOp)\n                    assert isinstance(node.value.left, ast.Call)\n                    assert node.value.left.func.id=='__go__array__'\n                    #raise RuntimeError(value)\n                    #raise RuntimeError(node.value.left.args[0].id)\n                    #assert node.value.left.args[0].id=='tuple'\n                    if target in self._vars:\n                        self._vars.remove( target )\n                        self._known_vars.add( target )\n                        return 'auto %s = %s{%s}; /*somearray*/' %(target, value[0], ','.join(value[1]))\n                    else:\n                        return '%s = %s{%s}; /*somearray*/' %(target, value[0], ','.join(value[1]))\n                else:\n                    if value in self._known_arrays and isinstance(self._known_arrays[value], tuple) and self._memory[-1]=='STACK':\n                        atype, fixed_size = self._known_arrays[value]\n\n                        ## unroll loop if possible ##\n                        if '(' in value and ')' in value:  ## do not unroll from a function call\n                            if target in self._vars:\n                                ## first assignment of a known variable, this requires 'auto' in c++11\n                                self._vars.remove( target )\n                                self._known_vars.add( target )\n                                return 'auto %s = %s; /*Assignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n                            else:\n                                return '%s = %s; /*Reassignment to fixed size array: %s[%s]*/' % (target, value, atype, fixed_size)\n\n                        elif fixed_size.isdigit() and int(fixed_size) 512:  ## or in self._macro_constants: TODO\n                            fixed_size = int(fixed_size)\n                            r = []\n                            for i in range(fixed_size):\n                                r.append('%s[%s] = %s[%s];' %(target,i, value,i))\n                            return ' '.join(r)\n                        else:\n                            r = [\n                                'for (int __i=0; __i %s; __i++) {' %fixed_size,\n                                self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                                self.indent()+'}',\n                            ]\n                            return '\\n'.join(r)\n\n                    else:\n                        return '%s = %s;' % (target, value)\n\n            else:\n                assert self._rust\n                ## destructured assignments also fallback here.\n                ## fallback to mutable by default? `let mut (x,y) = z` breaks rustc\n                if isclass:\n                    raise RuntimeError('TODO')\n                if is_attr:\n                    return '%s = %s;' % (target, value)\n                else:\n                    return 'let %s = %s;' % (target, value)", 
            "title": "Assignment"
        }, 
        {
            "location": "/cpptranslator/", 
            "text": "C++ Translator\n\n\n\n\nImports\n\n\n\n\n@import jvm.md\n\n\n@import nim.md\n\n\n@import cppheader.md\n\n\n@import cpython.md\n\n\n@import nuitka.md\n\n\n\n\n\nNUITKA_HEAD = '''\n//PyObject *get_nuitka_module() { return module___main__; }\n//PyDictObject *get_nuitka_module_dict() { return moduledict___main__; }\n\n'''\n\ndef gen_nuitka_header():\n    return NUITKA_HEAD\n\n\n\n\n\nTODO: make inline cpp-channel.h an option.\n\n\n\nclass CppGenerator( RustGenerator, CPythonGenerator ):\n\n    def make_tuple(self, elts):\n        tupletype = []\n        for telt in elts:\n            if isinstance(telt, ast.Str):  ## TODO test tuple with strings\n                v = telt.s\n                if v.startswith('\n') and v.endswith('\n'):  ## TODO this looks like a bug\n                    v = v[1:-1]\n            elif isinstance(telt, ast.List): #v.startswith('[') and v.endswith(']'):\n                tsubvec = None\n                for st in telt.elts:\n                    if isinstance(st, ast.Num):\n                        if str(st.n).isdigit():\n                            tsubvec = 'int'\n                        else:\n                            tsubvec = 'float64'\n                        break\n                assert tsubvec is not None\n                v = 'std::vector\n%s\n' %tsubvec\n\n            elif isinstance(telt, ast.Num):\n                if str(telt.n).isdigit():\n                    v = 'int'\n                else:\n                    v = 'float64'\n            elif isinstance(telt, ast.Name):\n                v = 'decltype(%s)' % self.visit(telt)\n            else:\n                v = self.visit(telt)\n\n            if v.startswith('[]'):\n                t  = v.split(']')[-1]\n                if self._memory[-1]=='STACK':\n                    v = 'std::vector\n%s\n' %t\n                else:\n                    v = 'std::vector\n%s\n*' %t\n\n            tupletype.append(v)\n\n\n        targs = []\n        for ti,te in enumerate(elts):\n            tt = tupletype[ti]\n            tv = self.visit(te)\n            if tv.startswith('[') and tv.endswith(']'):  ## old style\n                assert tt.startswith('std::vector')\n                if tt.endswith('*'):\n                    tv = '(new %s{%s})' %(tt[:-1], tv[1:-1])\n                else:\n                    tv = '%s{%s}' %(tt, tv[1:-1])\n            #elif tv.startswith('std::vector'):  ## never happens?\n            #   raise RuntimeError(tv)\n\n            if tt.startswith('std::vector') and self._memory[-1]=='HEAP':\n                tupletype[ti] = 'std::shared_ptr\n%s\n' %tt\n                #if not tv.startswith('new ') and tt.endswith('*'):  ## TODO test when is this required\n                #   raise RuntimeError(self.format_error(tt))\n                #   tv = 'std::shared_ptr\n%s\n(new %s)' %(tt[:-1], tv)\n                #else:\n                tv = 'std::shared_ptr\n%s\n(%s)' %(tt, tv)\n\n            targs.append(tv)\n\n        return tupletype, targs\n\n    def visit_List(self, node):\n        vectype = None\n        vecinit = []\n        tupletype = None\n        for elt in node.elts:\n            if vectype is None:\n                if isinstance(elt, ast.Num):\n                    if str(elt.n).isdigit():\n                        vectype = 'int'\n                    else:\n                        vectype = 'float64'\n                elif isinstance(elt, ast.Str):\n                    vectype = 'std::string'\n                elif isinstance(elt, ast.Name):\n                    vectype = 'decltype(%s)' %elt.id\n                elif isinstance(elt, ast.Tuple):\n                    if tupletype is None:\n                        tupletype = [None] * len(elt.elts)\n                    for i,sub in enumerate(elt.elts):\n                        if tupletype[i] is None:\n                            if isinstance(sub, ast.Num):\n                                if str(sub.n).isdigit():\n                                    tupletype[i] = 'int'\n                                else:\n                                    tupletype[i] = 'float64'\n                            elif isinstance(sub, ast.Str):\n                                tupletype[i] = 'std::string'\n                            elif isinstance(sub, ast.Name):\n                                tupletype[i] = 'decltype(%s)' %sub.id\n                            else:\n                                tupletype[i] = 'decltype(%s)' %self.visit(sub)\n\n            if isinstance(elt, ast.Tuple):\n                b = self.visit_Tuple(elt, force_make_tuple=True)\n                vecinit.append( b )\n\n            else:\n                b = self.visit(elt)\n                vecinit.append( b )\n        if tupletype:\n            assert None not in tupletype\n            if self._memory[-1]=='STACK':\n                vectype = 'std::tuple\n%s\n' %','.join(tupletype)\n            else:\n                vectype = 'std::shared_ptr\nstd::tuple\n%s\n' %','.join(tupletype)\n\n        if self._memory[-1]=='STACK':\n            return 'std::vector\n%s\n{%s}' % (vectype,','.join(vecinit))\n        else:\n            return 'new std::vector\n%s\n{%s}' % (vectype,','.join(vecinit))\n\n\n    def visit_Return(self, node):\n        if isinstance(node.value, ast.Tuple):\n            ## initializer list ##\n            return 'return {%s};' % ', '.join(map(self.visit, node.value.elts))\n        if node.value:\n            if isinstance(node.value, ast.Name) and node.value.id=='self':\n                if self._memory[-1]=='STACK':\n                    v = '*this;'\n                else:\n                    #v = 'std::make_shared\n%s\n(*this)' %self._class_stack[-1].name\n                    #v = 'shared_from_this()'  ## this breaks subclasses when the base class has a method that returns `self`\n                    v = 'std::static_pointer_cast\n%s\n(shared_from_this())' %self._class_stack[-1].name\n\n            elif isinstance(node.value, ast.Name) and node.value.id=='next':  ## seastar lambda repeat\n                v = 'stop_iteration::no'\n            elif isinstance(node.value, ast.Name) and node.value.id=='stop':  ## seastar lambda repeat\n                v = 'make_ready_future\nstop_iteration\n(stop_iteration::yes)'\n\n            elif isinstance(node.value, ast.Name) and node.value.id=='future':  ## seastar\n                v = 'make_ready_future\n()'\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Subscript):\n                T = self.visit(node.value.func.slice)\n                F = self.visit(node.value.args[0])\n                v = 'make_ready_future\n%s\n(%s)' %(T,F)\n            else:\n                v = self.visit(node.value)\n            try:\n                return 'return %s;' % v\n            except:\n                raise RuntimeError(v)\n        else:\n            return 'return;'\n\n\n    def is_container_type(self, T):\n        ## TODO better parsing\n        if 'std::vector' in T or 'std::map' in T:\n            return True\n        elif self.usertypes and 'vector' in self.usertypes:\n            if self.usertypes['vector']['template'].split('\n')[0] in T:\n                return True\n        return False\n\n    def visit_Assert(self, node):\n        t = ts = self.visit(node.test)\n        ts = ts.replace('\n', '\\\\\n')\n        return 'if (!(%s)) {throw std::runtime_error(\nassertion failed: %s\n); }' %(t,ts)\n\n\n    def visit_ImportFrom(self, node):\n        # print node.module\n        # print node.names[0].name\n        # print node.level\n        if node.module=='runtime':\n            self._use_runtime = True\n        return ''\n\n    def get_user_class_headers(self):\n        return self._user_class_headers\n\n    def visit_Import(self, node):\n        includes = []\n\n        for alias in node.names:\n            name = alias.name.replace('__SLASH__', '/').replace('__DASH__', '-')\n            if alias.asname:\n                self._user_class_headers[ alias.asname ] = {\n                    'file':name,\n                    'source':[]\n                }\n\n            if name == 'jvm':\n                self._has_jvm = True\n            elif name == 'nim':\n                self._has_nim = True\n            elif name == 'nuitka':\n                self._has_nuitka = True\n            elif name == 'cpython':\n                self._has_cpython = True\n            elif name.endswith('.h') or name.endswith('.hh'):\n                includes.append('#include \n%s\n' %name)\n            else:\n                includes.append('#include \n%s\n' %name)\n\n        return '\\n'.join(includes)\n\n\n    def visit_Module(self, node):\n        header = [ CPP_HEADER ]\n        lines = []\n\n        for b in node.body:\n            line = self.visit(b)\n            if line == 'main();':  ## to be compatible with other backends that need to call main directly\n                continue\n\n            if line is not None:\n                for sub in line.splitlines():\n                    if sub==';':\n                        #raise SyntaxError('bad semicolon')\n                        pass\n                    else:\n                        lines.append( sub )\n            else:\n                if isinstance(b, ast.Import):\n                    header.append( self.visit(b) )\n                else:\n                    raise SyntaxError(b)\n\n        if self._has_channels:\n            ## https://github.com/ahorn/cpp-channel\n            #header.append('#include \nchannel\n')\n            ## instead of including, just directly inline cpp-channel source\n            #dirname = os.path.dirname(os.path.abspath(__file__))\n            header.append(\n                open( os.path.join(RUSTHON_LIB_ROOT, 'src/runtime/c++/cpp-channel.h') ).read()\n            )\n\n        if self._has_jvm:\n            header.append( gen_jvm_header(self._java_classpaths) )\n\n        if self._has_nim:\n            header.append( gen_nim_header() )\n\n        if self._has_nuitka:\n            header.append( gen_nuitka_header() )\n\n        if self._has_cpython:\n            header.append( gen_cpython_header() )\n\n        ## forward declare all classes\n        for classname in self._classes:\n            header.append('class %s;' %classname)\n\n        if len(self._kwargs_type_.keys()):\n            #header.append('class _KwArgs_;')\n\n            impl = []\n            header.append('class _KwArgs_ {')\n            header.append(' public:')\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  %s _%s_;' %(type,name))\n                header.append( '  bool __use__%s;' %name)\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  _KwArgs_*  %s(%s %s);' %(name, type, name))\n\n                impl.append( '  _KwArgs_*   _KwArgs_::%s(%s %s) {' %(name, type, name))\n                impl.append( '      this-\n__use__%s = true;' %name)\n                impl.append( '      this-\n_%s_ = %s;' %(name, name))\n                impl.append( '      return this;')\n                impl.append('};')\n            header.append('};')\n            header.extend( impl )\n\n        if self._has_cpython:\n            header.append( self.gen_cpython_helpers() )\n\n\n        self.output_pak = pak = {'c_header':'', 'cpp_header':'', 'main':''}\n        cheader = None\n        cppheader = None\n        if len(self._cheader):\n            cheader = []\n            cppheader = ['extern \nC\n {']\n            for line in self._cheader:\n                cheader.append(line)\n                cppheader.append('\\t'+line)\n            cppheader.append('}')\n\n        if cheader:\n            pak['header.c'] = '\\n'.join( cheader )\n        if cppheader:\n            pak['header.cpp'] = '\\n'.join( cppheader )\n\n        if self._user_class_headers:\n            pass ## see get_user_class_headers\n        else:\n            if 'int main() {' in lines:  ## old hack to insert method defs before main\n                main_index = lines.index('int main() {')\n                for idef in self._cpp_class_impl:\n                    lines.insert(main_index,idef)\n            else:\n                ## option to split this part into the cpp body TODO\n                for idef in self._cpp_class_impl:\n                    lines.append(idef)\n\n        if self._use_runtime:\n            lines = header + list(self._imports) + lines\n        else:\n            lines = list(self._imports) + lines\n\n        if len(self._kwargs_type_.keys()) and False:\n            header = []\n            impl = []\n            header.append('class _KwArgs_ {')\n            header.append(' public:')\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  %s _%s_;' %(type,name))\n                header.append( '  bool __use__%s;' %name)\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  _KwArgs_*  %s(%s %s);' %(name, type, name))\n\n                impl.append( '  _KwArgs_*   _KwArgs_::%s(%s %s) {' %(name, type, name))\n                impl.append( '      this-\n__use__%s = true;' %name)\n                impl.append( '      this-\n_%s_ = %s;' %(name, name))\n                impl.append( '      return this;')\n                impl.append('};')\n            header.append('};')\n            header.extend( impl )\n            lines.extend(header)\n\n\n        pak['main'] = '\\n'.join( lines )\n        return pak['main']\n\n    def visit_Set(self, node):\n        ## c++11 aggregate initialization\n        ## http://en.cppreference.com/w/cpp/language/aggregate_initialization\n        return '{%s}' %','.join([self.visit(elt) for elt in node.elts])\n\n\n\n\n\nlow level \nnew\n for interfacing with external c++.\nAlso used for code that is blocked with \nwith pointers:\n\nto create a class without having to create a temp variable,\n\nf( new(MyClass(x,y)) )\n, directly calls the constructor,\nif MyClass is a Rusthon class then \ninit\n will be called.\nTODO fix mixing with std::shared_ptr by keeping a weak_ptr\nin each object that \ninit\n returns (also fixes the _ref_hacks)\n\n\n\n    def _visit_call_helper_new(self, node):\n        if isinstance(node.args[0], ast.BinOp): # makes an array or map\n            a = self.visit(node.args[0])\n            if type(a) is not tuple:\n                raise SyntaxError(self.format_error('TODO some extended type'))\n\n            atype, avalue = a\n            if atype.endswith('*'): atype = atype[:-1]\n            else: pass  ## this should never happen\n            return '(/*array-or-map*/ new %s %s)' %(atype, avalue)\n\n        ## Pythia User Class ##\n        elif isinstance(node.args[0], ast.Call) and isinstance(node.args[0].func, ast.Name) and node.args[0].func.id in self._classes:\n            classname = node.args[0].func.id\n            args = [self.visit(arg) for arg in node.args[0].args ]\n            if self._classes[classname]._requires_init:\n                if not isinstance(self._stack[-2], ast.Assign):\n                    raise RuntimeError('TODO new(A(new(B))')\n                return '(/*initialize-class*/ new %s)-\n__init__(%s)' %(classname, ','.join(args))\n\n            elif args:  ## a rusthon class that subclasses from an external c++ class ##\n                return '(/*external-parent-class*/ new %s(%s))' %(classname, ','.join(args))\n            else:\n                return '(/*create-class*/ new %s)' %classname\n\n        ## external c++ class ##\n        else:\n            classname = self.visit(node.args[0])\n            return '(/*external-class*/ new %s)' %classname\n\n\n\n\n\nSubclasses from \nRustGenerator\n, see here:\n\nrusttranslator.md\n\nTODO: reverse, \nRustGenerator\n should subclass from \nCppGenerator\n.\n\n\nnote: polymorphic classes are not generated by default, virtual methods are not required,\ncasting works fine with \nstatic_cast\n and \nstd::static_pointer_cast\n.\n\n\n\n    def __init__(self, source=None, requirejs=False, insert_runtime=False, cached_json_files=None, use_try=True):\n        RustGenerator.__init__(self, source=source, requirejs=False, insert_runtime=False)\n        self._cpp = True\n        self._rust = False  ## can not be true at the same time self._cpp is true, conflicts in switch/match hack.\n        self._shared_pointers = True\n        self._noexcept = False\n        self._polymorphic = False  ## by default do not use polymorphic classes (virtual methods)\n        self._has_jvm = False\n        self._jvm_classes = dict()\n        self._has_nim = False\n        self._has_nuitka = False\n        self._has_cpython = False\n        self._known_pyobjects  = dict()\n        self._use_runtime = insert_runtime\n        self.cached_json_files = cached_json_files or dict()\n        self.usertypes = dict()\n        self._user_class_headers = dict()\n        self._finally_id = 0\n        self._use_try = use_try\n        self._has_gnu_stm = False\n\n    def visit_Delete(self, node):\n        targets = [self.visit(t) for t in node.targets]\n        if len(targets)==0:\n            raise RuntimeError('no delete targets')\n        r = []\n        if self.usertypes and 'weakref' in self.usertypes and 'reset' in self.usertypes['weakref']:\n            for t in targets:\n                r.append('%s.%s();' %(t, self.usertypes['weakref']['reset']))\n        elif self.usertypes and 'shared' in self.usertypes and 'reset' in self.usertypes['shared']:\n            for t in targets:\n                r.append('%s.%s();' %(t, self.usertypes['shared']['reset']))\n        elif self._shared_pointers:\n            for t in targets:\n                r.append('%s.reset();' %t)\n        else:\n            for t in targets:\n                if t in self._known_arrays:\n                    r.append('delete[] %s;')\n                else:\n                    r.append('delete %s;')\n\n        return '\\n'.join(r)\n\n    def visit_Str(self, node, wrap=True):\n        s = node.s.replace(\n\\\\\n, \n\\\\\\\\\n).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\n', '\\\\\n')\n        if wrap is False:\n            return s\n        elif self._force_cstr:\n            return '\n%s\n' % s\n\n        elif self.usertypes and 'string' in self.usertypes.keys():\n            if self.usertypes['string'] is None:\n                return '\n%s\n' % s\n            else:\n                return self.usertypes['string']['new'] % '\n%s\n' % s\n        else:\n            return 'std::string(\n%s\n)' % s\n\n    def visit_Print(self, node):\n        r = []\n        for e in node.values:\n            s = self.visit(e)\n            if isinstance(e, ast.List) or isinstance(e, ast.Tuple):\n                for sube in e.elts:\n                    r.append('std::cout \n %s;' %self.visit(sube))\n                if r:\n                    r[-1] += 'std::cout \n std::endl;'\n                else:\n                    r.append('std::cout \n std::endl;')\n            else:\n                r.append('std::cout \n %s \n std::endl;' %s)\n        return '\\n'.join(r)\n\n\n\n\nTODO\n\n\n\n\ntest finally\n\n\n\n\n\n    def visit_TryExcept(self, node, finallybody=None):\n        ## TODO: check why `catch (...)` is not catching file errors\n        out = []\n\n        use_try = self._use_try  ## when building with external tools or platforms -fexceptions can not be enabled.\n\n\n        if use_try:\n            if finallybody:\n                self._finally_id += 1\n                out.append('bool __finally_done_%s = false;' %self._finally_id)\n                out.append( self.indent()+'try {' )\n            else:\n                out.append( 'try {' )\n\n        self.push()\n        for b in node.body:\n            out.append( self.indent()+self.visit(b) )\n\n        self.pull()\n        if use_try:\n            out.append(self.indent()+ '}' )\n\n            handler_types = []\n            for ha in node.handlers:\n                if ha.type:\n                    handler_types.append(self.visit(ha.type))\n\n            if handler_types:\n                out.append( self.indent() + 'catch (std::runtime_error* __error__) {' )\n                self.push()\n                out.append( self.indent() + 'std::string __errorname__ = __parse_error_type__(__error__);')\n            else:\n                out.append( self.indent() + 'catch (...) {' )\n                self.push()\n\n            for h in node.handlers:\n                out.append(\n                    self.indent() + self.visit_ExceptHandler(h, finallybody=finallybody)\n                )\n            self.pull()\n\n            out.append(self.indent()+ '}' )\n\n            ## TODO also catch these error that standard c++ libraries are likely to throw ##\n            #out.append( self.indent() + 'catch (const std::overflow_error\n e) { std::cout \n \nOVERFLOW ERROR\n \n std::endl; }' )\n            #out.append( self.indent() + 'catch (const std::runtime_error\n e) { std::cout \n \nRUNTIME ERROR\n \n std::endl; }' )\n            #out.append( self.indent() + 'catch (const std::exception\n e) {' )\n            #out.append( self.indent() + 'catch (...) { std::cout \n \nUNKNOWN ERROR\n \n std::endl; }' )\n\n\n            ## wrap in another try that is silent\n            if finallybody:\n                out.append(self.indent()+'if (__finally_done_%s == false) {' %self._finally_id )\n                self.push()\n                out.append(self.indent()+'try {     // finally block')\n                self.push()\n                for b in finallybody:\n                    out.append(self.indent()+self.visit(b))\n                self.pull()\n                out.append(self.indent()+'} catch (...) {}')\n                self.pull()\n                out.append(self.indent()+'}')\n\n                self._finally_id -= 1\n\n        return '\\n'.join( out )\n\n    def visit_ExceptHandler(self, node, finallybody=None):\n        #out = ['catch (std::runtime_error* __error__) {']\n        T = 'Error'\n        out = []\n        if node.type:\n            T = self.visit(node.type)\n            out.append('if (__errorname__ == std::string(\n%s\n)) {' %T )\n\n        self.push()\n\n        if node.name:\n            #out.append(self.indent()+'auto %s = *__error__;' % self.visit(node.name))\n            out.append(self.indent()+'auto %s = __error__;' % self.visit(node.name))\n\n        ## this happens before the exception body, while this is not strictly python\n        ## it is close enough, because the main requirement is that the finally body\n        ## is always run, even if there is a return or new exception raised.\n        if finallybody:\n            out.append(self.indent()+'__finally_done_%s = true;' %self._finally_id)\n            self.push()\n            out.append(self.indent()+'try {     // finally block')\n            self.push()\n            for b in finallybody:\n                out.append(self.indent()+self.visit(b))\n            self.pull()\n            out.append(self.indent()+'} catch (...) {}')\n            self.pull()\n\n\n        for b in node.body:\n            out.append(self.indent()+self.visit(b))\n\n        self.pull()\n        if node.type:\n            out.append(self.indent()+'}')\n        return '\\n'.join(out)\n\n\n\n\n\n\nCPython C-API\n\n\nuser syntax \nimport cpython\n and \n-\n\n\n\n    def gen_cpy_call(self, pyob, node):\n        fname = self.visit(node.func)\n        if not node.args and not node.keywords:\n            return 'PyObject_Call(%s, Py_BuildValue(\n()\n), NULL)' %pyob\n        else:\n            lambda_args = [\n                '[\n] {',\n                'auto args = PyTuple_New(%s);' %len(node.args),\n            ]\n            for i,arg in enumerate(node.args):\n                if isinstance(arg, ast.Num):\n                    n = arg.n\n                    if str(n).isdigit():\n                        n = 'PyInt_FromLong(%s)' %n\n                        lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, n))\n                    else:\n                        n = 'PyFloat_FromDouble(%s)' %n\n                        lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, n))\n                elif isinstance(arg, ast.Str):\n                    n = 'PyString_FromString(\n%s\n)' %arg.s\n                    lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, n))\n                else:\n                    lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, self.visit(arg)))\n            lambda_args.append('return args; }()')\n            return 'PyObject_Call(%s, %s, NULL)' %(pyob, '\\n'.join(lambda_args))\n\n    def gen_cpy_get(self, pyob, name):\n        return 'PyObject_GetAttrString(%s,\n%s\n)' %(pyob, name)\n\n\n\n\n\nSlice and List Comprehension \n[:]\n, \n[]int(x for x in range(n))\n\n\nnegative slice is not fully supported, only \n-1\n literal works.\n\n\n\n    def _gen_slice(self, target=None, value=None, lower=None, upper=None, step=None, type=None, result_size=None):\n        assert target\n        assert value\n        fixed_size = None\n        if type and isinstance(type, tuple) and type[1]:\n            fixed_size = type[1]\n            type = type[0]\n\n        elif type and type.startswith('[]'):\n            T = type.split(']')[-1].strip()\n            if self.is_prim_type(T) or self._memory[-1]=='STACK':\n                type = T\n            elif type.count('[')==1:\n                type = 'std::shared_ptr\n%s\n' %T\n            else:\n                raise RuntimeError('TODO md-array slice')\n\n\n        #################################################\n        if fixed_size:\n            slice = ['/* \nfixed size slice\n %s : %s : %s */' %(lower, upper, step)]\n            con = []\n            is_constant = True\n\n            if fixed_size.isdigit():\n                fixed_size = int(fixed_size)\n                if lower and not upper:\n                    if lower.isdigit():\n                        for i in range(int(lower), fixed_size):\n                            con.append('%s[%s]' %(value,i))\n                    else:\n                        is_constant = False\n                elif upper and not lower:\n                    if upper.isdigit():\n                        for i in range(0, int(upper)):\n                            con.append('%s[%s]' %(value,i))\n                    else:\n                        is_constant = False\n                elif not lower and not upper:\n                    if step=='-1':\n                        i = fixed_size-1\n                        while i \n= 0:\n                            con.append('%s[%s]' %(value,i))\n                            i -= 1\n                    else:\n                        for i in range(fixed_size):\n                            con.append('%s[%s]' %(value,i))\n                else:\n                    raise SyntaxError('todo slice fixed size stack array')\n\n                if is_constant:\n                    slice.append(\n                        self.indent()+'%s %s[%s] = {%s};' %(type,target, result_size, ','.join(con))\n                    )\n                else:\n                    pass  ## fallback to for loop\n            else:\n                is_constant = False\n\n            if not is_constant:\n                if not lower and not upper:\n                    if step=='-1':\n                        slice.extend([\n                            self.indent()+'%s %s[%s];' %(type,target, fixed_size),\n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s-1; __i\n=%s; __i--) {' %(fixed_size, lower),\n                            self.indent()+'  %s[__L] = %s[__i];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ])\n                    else:\n                        slice.extend([\n                            self.indent()+'%s %s[%s];' %(type,target, fixed_size),\n                            self.indent()+'for (int __i=0; __i\n%s; __i++) {' %fixed_size,\n                            self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                            self.indent()+'}',\n                        ])\n\n                elif lower and not upper:\n                    if step=='-1':\n                        slice.extend([\n                            self.indent()+'%s %s[%s-%s];' %(type,target, fixed_size, lower),                        \n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s-1; __i\n=%s; __i--) {' %(fixed_size, lower),\n                            self.indent()+'  %s[__L] = %s[__i];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ])\n                    else:\n                        slice.extend([\n                            self.indent()+'%s %s[%s-%s];' %(type,target, fixed_size, lower),                        \n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s; __i\n%s; __i++) {' %(lower, fixed_size),\n                            self.indent()+'  %s[__L] = %s[__i];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ])\n                elif upper and not lower:\n                    slice.extend([\n                        self.indent()+'%s %s[%s];' %(type,target, upper),                       \n                        self.indent()+'int __U = 0;',\n                        self.indent()+'for (int __i=0; __i\n%s; __i++) {' %upper,\n                        self.indent()+'  %s[__U] = %s[__i];' %(target, value),\n                        self.indent()+'  __U ++;',\n                        self.indent()+'}',\n                    ])\n                else:\n                    raise SyntaxError('\\n'.join(slice))\n            return '\\n'.join(slice)\n\n        elif type:\n            slice = ['/*\nslice\n `%s` [%s:%s:%s] %s */' %(value, lower, upper, step, type)]\n            if '\n' in type and '\n' in type:\n                type = type.split('\n')[-1].split('\n')[0]\n                if self._memory[-1]=='HEAP':\n                    if not self.is_prim_type(type):\n                        type = 'std::shared_ptr\n%s\n' %type\n\n            if step==\n-1\n:  ##if step.isdigit() and int(step)\n0: TODO\n                if self._memory[-1]=='STACK':\n                    slice.append(self.indent()+'std::vector\n%s\n %s;' %(type,target))\n                else:\n                    slice.append(self.indent()+'std::vector\n%s\n _ref_%s;' %(type,target))\n\n                step = step[1:]  ## strip `-`\n                if lower and not upper:\n                    if self._memory[-1]=='STACK':\n                        slice.extend([\n                            'for(int _i_=%s;_i_\n=0;_i_-=%s){' %(lower,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}'\n                        ])\n                    else:\n                        slice.extend([\n                            #'for(int _i_=%s-\nsize()-(1+%s);_i_\n=0;_i_-=%s){' %(value,lower,step),\n                            'for(int _i_=%s;_i_\n=0;_i_-=%s){' %(lower,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}'\n                        ])\n                elif upper:\n                    raise RuntimeError('slice todo')\n                else:\n                    if self._memory[-1]=='STACK':\n                        slice.extend([\n                            'for(int _i_=%s.size()-1;_i_\n=0;_i_-=%s){' %(value,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}',\n                        ])\n                    else:\n                        slice.extend([\n                            'for(int _i_=%s-\nsize()-1;_i_\n=0;_i_-=%s){' %(value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}',\n                        ])\n\n            elif step:\n                if self._memory[-1]=='STACK':\n                    slice.append('std::vector\n%s\n %s;' %(type,target))\n                else:\n                    slice.append('std::vector\n%s\n _ref_%s;' %(type,target))\n\n                if lower and not upper:\n                    if self._memory[-1]=='STACK':\n                        slice.append( ''.join([\n                            'if(%s\n0){'%step,\n                            'for(int _i_=%s.size()-%s-1;_i_\n=0;_i_+=%s){' %(value,lower,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}} else {',\n                            'for(int _i_=%s;_i_\n%s.size();_i_+=%s){' %(lower,value,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}}',\n                            ])\n                        )\n                    else:\n                        slice.append( ''.join([\n                            'if(%s\n0){'%step,\n                            'for(int _i_=%s-\nsize()-%s-1;_i_\n=0;_i_+=%s){' %(value,lower,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}} else {',\n                            'for(int _i_=%s;_i_\n%s-\nsize();_i_+=%s){' %(lower,value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}}',\n                            ])\n                        )\n                elif upper:\n                    raise SyntaxError('TODO slice upper with step')\n                else:\n                    if self._memory[-1]=='STACK':\n                        slice.append( ''.join([\n                            'if(%s\n0){'%step,\n                            'for(int _i_=%s.size()-1;_i_\n=0;_i_+=%s){' %(value,step),\n                            ' %s.push_back(%s[_i_]);}' %(target, value),\n                            '} else {',\n                            'for(int _i_=0;_i_\n%s.size();_i_+=%s){' %(value,step),\n                            ' %s.push_back(%s[_i_]);}' %(target, value),\n                            '}',\n                            ])\n                        )\n\n                    else:\n                        slice.append( ''.join([\n                            'if(%s\n0){'%step,\n                            'for(int _i_=%s-\nsize()-1;_i_\n=0;_i_+=%s){' %(value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);}' %(target, value),\n                            '} else {',\n                            'for(int _i_=0;_i_\n%s-\nsize();_i_+=%s){' %(value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);}' %(target, value),\n                            '}',\n                            ])\n                        )\n            else:\n                isptr = False\n                #if value in self._known_arrays and isinstance(self._known_arrays[value], str):\n                #   if self._known_arrays[value].startswith('[]'):\n                #       isptr = True\n                if value in self._known_pointers:\n                    isptr = True\n                    if self._memory[-1]=='HEAP':\n                        self._known_pointers[target] = self._known_pointers[value]\n                if self._memory[-1]=='STACK':\n                    self._known_refs[target] = type\n                ################################\n\n                if isptr and self._memory[-1]=='HEAP':\n                    slice.append(self.indent()+'auto %s = new std::vector\n%s\n(' %(target, type))                    \n                elif self._memory[-1]=='STACK':\n                    slice.append(self.indent()+'std::vector\n%s\n %s(' %(type,target))\n                else:\n                    slice.append(self.indent()+'std::vector\n%s\n _ref_%s(' %(type,target))\n\n                if lower:\n                    if isptr:\n                        slice.append(self.indent()+'%s-\nbegin()+%s,' %(value, lower))\n                    elif self._memory[-1]=='STACK':\n                        slice.append(self.indent()+'%s.begin()+%s,' %(value, lower))\n                    else:\n                        slice.append(self.indent()+'%s-\nbegin()+%s,' %(value, lower))\n                else:\n                    if isptr:\n                        slice.append(self.indent()+'%s-\nbegin(),' %value)\n                    elif self._memory[-1]=='STACK':\n                        slice.append(self.indent()+'%s.begin(),' %value)\n                    else:\n                        slice.append(self.indent()+'%s-\nbegin(),' %value)\n\n                if upper:\n                    if upper \n 0:\n                        if self._memory[-1]=='STACK':\n                            slice.append(self.indent()+'%s.end() %s'%(value, upper))\n                        else:\n                            slice.append(self.indent()+'%s-\nend() %s'%(value, upper))\n                    else:\n                        if self._memory[-1]=='STACK':\n                            slice.append(self.indent()+'%s.begin()+%s'%(value, upper))\n                        else:\n                            slice.append(self.indent()+'%s-\nbegin()+%s'%(value, upper))\n\n                else:\n                    if isptr:\n                        slice.append(self.indent()+'%s-\nend()'%value)\n                    elif self._memory[-1]=='STACK':\n                        slice.append(self.indent()+'%s.end()'%value)\n                    else:\n                        slice.append(self.indent()+'%s-\nend()'%value)\n\n                slice.append(self.indent()+');')\n\n            vectype = 'std::vector\n%s\n' %type\n\n            if self._memory[-1]=='STACK':\n                pass\n            elif not self._shared_pointers:\n                slice.append(self.indent()+'%s* %s = \n_ref_%s);' %(vectype, target, target))\n            elif self._unique_ptr:\n                slice.append(self.indent()+'std::unique_ptr\n%s\n %s = _make_unique\n%s\n(_ref_%s);' %(vectype, target, vectype, target))\n            else:\n                slice.append(self.indent()+'std::shared_ptr\n%s\n %s = std::make_shared\n%s\n(_ref_%s);' %(vectype, target, vectype, target))\n            return '\\n'.join(slice)\n\n        else:  ## slice an unknown type of array ##\n            if not lower and not upper and not step:  ## slice copy `myarr[:]`\n                if self._memory[-1]=='STACK':\n                    return 'std::vector\n decltype(%s-\nbegin())::value_type \n %s( %s-\nbegin(), %s-\nend() );' %(value, target, value, value)\n                else:\n                    vectype = 'std::vector\ndecltype(%s-\nbegin())::value_type\n' %value\n                    return 'auto %s = std::make_shared\n%s\n( %s(%s-\nbegin(),%s-\nend()) );' %(target, vectype,vectype, value, value)\n\n            elif lower and not upper and not step:\n                if self._memory[-1]=='STACK':\n                    return 'std::vector\n decltype(%s-\nbegin())::value_type \n %s( %s-\nbegin()+%s, %s-\nend() );' %(value, target, value, lower, value)\n                else:\n                    vectype = 'std::vector\ndecltype(%s-\nbegin())::value_type\n' %value\n                    return 'auto %s = std::make_shared\n%s\n( %s(%s-\nbegin()+%s,%s-\nend()) );' %(target, vectype,vectype, value, lower, value)\n            elif upper and not lower and not step:\n                if self._memory[-1]=='STACK':\n                    return 'std::vector\n decltype(%s-\nbegin())::value_type \n %s( %s-\nbegin(), %s-\nbegin()+%s );' %(value, target, value, value, upper)\n                else:\n                    vectype = 'std::vector\ndecltype(%s-\nbegin())::value_type\n' %value\n                    return 'auto %s = std::make_shared\n%s\n( %s(%s-\nbegin(),%s-\nbegin()+%s) );' %(target, vectype,vectype, value, value, upper)\n\n            else:\n                raise RuntimeError('TODO slice unknown')\n\n\n\n\n\n\nTranslate to C++\n\n\nTODO save GCC PGO files.\n\n\n\ndef translate_to_cpp(script, insert_runtime=True, cached_json_files=None, use_try=True):\n    if '--debug-inter' in sys.argv:\n        raise RuntimeError(script)\n\n    if '--osv' in sys.argv:\n        osv = open( os.path.join(RUSTHON_LIB_ROOT, 'src/pythia/runtime/osv_builtins.py') ).read()\n        osv = python_to_pythonjs( osv, cpp=True )\n        script = osv + '\\n' + script\n\n    if insert_runtime:\n        runtime = open( os.path.join(RUSTHON_LIB_ROOT, 'src/pythia/runtime/cpp_builtins.py') ).read()\n        runtime = python_to_pythonjs( runtime, cpp=True )\n        script = runtime + '\\n' + script\n\n    try:\n        tree = ast.parse(script)\n    except SyntaxError as err:\n        e = ['%s:   %s'%(i+1, line) for i,line in enumerate(script.splitlines())]\n        sys.stderr.write('\\n'.join(e))\n        raise err\n\n    g = CppGenerator(\n        source=script, \n        insert_runtime=insert_runtime, \n        cached_json_files=cached_json_files,\n        use_try = use_try\n    )\n    g.visit(tree) # first pass gathers classes\n    pass2 = g.visit(tree)\n    g.reset()\n    pass3 = g.visit(tree)\n    userheaders = g.get_user_class_headers()\n    if userheaders:\n        g.output_pak['user-headers'] = userheaders\n    return g.output_pak", 
            "title": "C++Translator"
        }, 
        {
            "location": "/cpptranslator/#c-translator", 
            "text": "", 
            "title": "C++ Translator"
        }, 
        {
            "location": "/cpptranslator/#imports", 
            "text": "@import jvm.md  @import nim.md  @import cppheader.md  @import cpython.md  @import nuitka.md   \nNUITKA_HEAD = '''\n//PyObject *get_nuitka_module() { return module___main__; }\n//PyDictObject *get_nuitka_module_dict() { return moduledict___main__; }\n\n'''\n\ndef gen_nuitka_header():\n    return NUITKA_HEAD  TODO: make inline cpp-channel.h an option.  \nclass CppGenerator( RustGenerator, CPythonGenerator ):\n\n    def make_tuple(self, elts):\n        tupletype = []\n        for telt in elts:\n            if isinstance(telt, ast.Str):  ## TODO test tuple with strings\n                v = telt.s\n                if v.startswith(' ') and v.endswith(' '):  ## TODO this looks like a bug\n                    v = v[1:-1]\n            elif isinstance(telt, ast.List): #v.startswith('[') and v.endswith(']'):\n                tsubvec = None\n                for st in telt.elts:\n                    if isinstance(st, ast.Num):\n                        if str(st.n).isdigit():\n                            tsubvec = 'int'\n                        else:\n                            tsubvec = 'float64'\n                        break\n                assert tsubvec is not None\n                v = 'std::vector %s ' %tsubvec\n\n            elif isinstance(telt, ast.Num):\n                if str(telt.n).isdigit():\n                    v = 'int'\n                else:\n                    v = 'float64'\n            elif isinstance(telt, ast.Name):\n                v = 'decltype(%s)' % self.visit(telt)\n            else:\n                v = self.visit(telt)\n\n            if v.startswith('[]'):\n                t  = v.split(']')[-1]\n                if self._memory[-1]=='STACK':\n                    v = 'std::vector %s ' %t\n                else:\n                    v = 'std::vector %s *' %t\n\n            tupletype.append(v)\n\n\n        targs = []\n        for ti,te in enumerate(elts):\n            tt = tupletype[ti]\n            tv = self.visit(te)\n            if tv.startswith('[') and tv.endswith(']'):  ## old style\n                assert tt.startswith('std::vector')\n                if tt.endswith('*'):\n                    tv = '(new %s{%s})' %(tt[:-1], tv[1:-1])\n                else:\n                    tv = '%s{%s}' %(tt, tv[1:-1])\n            #elif tv.startswith('std::vector'):  ## never happens?\n            #   raise RuntimeError(tv)\n\n            if tt.startswith('std::vector') and self._memory[-1]=='HEAP':\n                tupletype[ti] = 'std::shared_ptr %s ' %tt\n                #if not tv.startswith('new ') and tt.endswith('*'):  ## TODO test when is this required\n                #   raise RuntimeError(self.format_error(tt))\n                #   tv = 'std::shared_ptr %s (new %s)' %(tt[:-1], tv)\n                #else:\n                tv = 'std::shared_ptr %s (%s)' %(tt, tv)\n\n            targs.append(tv)\n\n        return tupletype, targs\n\n    def visit_List(self, node):\n        vectype = None\n        vecinit = []\n        tupletype = None\n        for elt in node.elts:\n            if vectype is None:\n                if isinstance(elt, ast.Num):\n                    if str(elt.n).isdigit():\n                        vectype = 'int'\n                    else:\n                        vectype = 'float64'\n                elif isinstance(elt, ast.Str):\n                    vectype = 'std::string'\n                elif isinstance(elt, ast.Name):\n                    vectype = 'decltype(%s)' %elt.id\n                elif isinstance(elt, ast.Tuple):\n                    if tupletype is None:\n                        tupletype = [None] * len(elt.elts)\n                    for i,sub in enumerate(elt.elts):\n                        if tupletype[i] is None:\n                            if isinstance(sub, ast.Num):\n                                if str(sub.n).isdigit():\n                                    tupletype[i] = 'int'\n                                else:\n                                    tupletype[i] = 'float64'\n                            elif isinstance(sub, ast.Str):\n                                tupletype[i] = 'std::string'\n                            elif isinstance(sub, ast.Name):\n                                tupletype[i] = 'decltype(%s)' %sub.id\n                            else:\n                                tupletype[i] = 'decltype(%s)' %self.visit(sub)\n\n            if isinstance(elt, ast.Tuple):\n                b = self.visit_Tuple(elt, force_make_tuple=True)\n                vecinit.append( b )\n\n            else:\n                b = self.visit(elt)\n                vecinit.append( b )\n        if tupletype:\n            assert None not in tupletype\n            if self._memory[-1]=='STACK':\n                vectype = 'std::tuple %s ' %','.join(tupletype)\n            else:\n                vectype = 'std::shared_ptr std::tuple %s ' %','.join(tupletype)\n\n        if self._memory[-1]=='STACK':\n            return 'std::vector %s {%s}' % (vectype,','.join(vecinit))\n        else:\n            return 'new std::vector %s {%s}' % (vectype,','.join(vecinit))\n\n\n    def visit_Return(self, node):\n        if isinstance(node.value, ast.Tuple):\n            ## initializer list ##\n            return 'return {%s};' % ', '.join(map(self.visit, node.value.elts))\n        if node.value:\n            if isinstance(node.value, ast.Name) and node.value.id=='self':\n                if self._memory[-1]=='STACK':\n                    v = '*this;'\n                else:\n                    #v = 'std::make_shared %s (*this)' %self._class_stack[-1].name\n                    #v = 'shared_from_this()'  ## this breaks subclasses when the base class has a method that returns `self`\n                    v = 'std::static_pointer_cast %s (shared_from_this())' %self._class_stack[-1].name\n\n            elif isinstance(node.value, ast.Name) and node.value.id=='next':  ## seastar lambda repeat\n                v = 'stop_iteration::no'\n            elif isinstance(node.value, ast.Name) and node.value.id=='stop':  ## seastar lambda repeat\n                v = 'make_ready_future stop_iteration (stop_iteration::yes)'\n\n            elif isinstance(node.value, ast.Name) and node.value.id=='future':  ## seastar\n                v = 'make_ready_future ()'\n            elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Subscript):\n                T = self.visit(node.value.func.slice)\n                F = self.visit(node.value.args[0])\n                v = 'make_ready_future %s (%s)' %(T,F)\n            else:\n                v = self.visit(node.value)\n            try:\n                return 'return %s;' % v\n            except:\n                raise RuntimeError(v)\n        else:\n            return 'return;'\n\n\n    def is_container_type(self, T):\n        ## TODO better parsing\n        if 'std::vector' in T or 'std::map' in T:\n            return True\n        elif self.usertypes and 'vector' in self.usertypes:\n            if self.usertypes['vector']['template'].split(' ')[0] in T:\n                return True\n        return False\n\n    def visit_Assert(self, node):\n        t = ts = self.visit(node.test)\n        ts = ts.replace(' ', '\\\\ ')\n        return 'if (!(%s)) {throw std::runtime_error( assertion failed: %s ); }' %(t,ts)\n\n\n    def visit_ImportFrom(self, node):\n        # print node.module\n        # print node.names[0].name\n        # print node.level\n        if node.module=='runtime':\n            self._use_runtime = True\n        return ''\n\n    def get_user_class_headers(self):\n        return self._user_class_headers\n\n    def visit_Import(self, node):\n        includes = []\n\n        for alias in node.names:\n            name = alias.name.replace('__SLASH__', '/').replace('__DASH__', '-')\n            if alias.asname:\n                self._user_class_headers[ alias.asname ] = {\n                    'file':name,\n                    'source':[]\n                }\n\n            if name == 'jvm':\n                self._has_jvm = True\n            elif name == 'nim':\n                self._has_nim = True\n            elif name == 'nuitka':\n                self._has_nuitka = True\n            elif name == 'cpython':\n                self._has_cpython = True\n            elif name.endswith('.h') or name.endswith('.hh'):\n                includes.append('#include  %s ' %name)\n            else:\n                includes.append('#include  %s ' %name)\n\n        return '\\n'.join(includes)\n\n\n    def visit_Module(self, node):\n        header = [ CPP_HEADER ]\n        lines = []\n\n        for b in node.body:\n            line = self.visit(b)\n            if line == 'main();':  ## to be compatible with other backends that need to call main directly\n                continue\n\n            if line is not None:\n                for sub in line.splitlines():\n                    if sub==';':\n                        #raise SyntaxError('bad semicolon')\n                        pass\n                    else:\n                        lines.append( sub )\n            else:\n                if isinstance(b, ast.Import):\n                    header.append( self.visit(b) )\n                else:\n                    raise SyntaxError(b)\n\n        if self._has_channels:\n            ## https://github.com/ahorn/cpp-channel\n            #header.append('#include  channel ')\n            ## instead of including, just directly inline cpp-channel source\n            #dirname = os.path.dirname(os.path.abspath(__file__))\n            header.append(\n                open( os.path.join(RUSTHON_LIB_ROOT, 'src/runtime/c++/cpp-channel.h') ).read()\n            )\n\n        if self._has_jvm:\n            header.append( gen_jvm_header(self._java_classpaths) )\n\n        if self._has_nim:\n            header.append( gen_nim_header() )\n\n        if self._has_nuitka:\n            header.append( gen_nuitka_header() )\n\n        if self._has_cpython:\n            header.append( gen_cpython_header() )\n\n        ## forward declare all classes\n        for classname in self._classes:\n            header.append('class %s;' %classname)\n\n        if len(self._kwargs_type_.keys()):\n            #header.append('class _KwArgs_;')\n\n            impl = []\n            header.append('class _KwArgs_ {')\n            header.append(' public:')\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  %s _%s_;' %(type,name))\n                header.append( '  bool __use__%s;' %name)\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  _KwArgs_*  %s(%s %s);' %(name, type, name))\n\n                impl.append( '  _KwArgs_*   _KwArgs_::%s(%s %s) {' %(name, type, name))\n                impl.append( '      this- __use__%s = true;' %name)\n                impl.append( '      this- _%s_ = %s;' %(name, name))\n                impl.append( '      return this;')\n                impl.append('};')\n            header.append('};')\n            header.extend( impl )\n\n        if self._has_cpython:\n            header.append( self.gen_cpython_helpers() )\n\n\n        self.output_pak = pak = {'c_header':'', 'cpp_header':'', 'main':''}\n        cheader = None\n        cppheader = None\n        if len(self._cheader):\n            cheader = []\n            cppheader = ['extern  C  {']\n            for line in self._cheader:\n                cheader.append(line)\n                cppheader.append('\\t'+line)\n            cppheader.append('}')\n\n        if cheader:\n            pak['header.c'] = '\\n'.join( cheader )\n        if cppheader:\n            pak['header.cpp'] = '\\n'.join( cppheader )\n\n        if self._user_class_headers:\n            pass ## see get_user_class_headers\n        else:\n            if 'int main() {' in lines:  ## old hack to insert method defs before main\n                main_index = lines.index('int main() {')\n                for idef in self._cpp_class_impl:\n                    lines.insert(main_index,idef)\n            else:\n                ## option to split this part into the cpp body TODO\n                for idef in self._cpp_class_impl:\n                    lines.append(idef)\n\n        if self._use_runtime:\n            lines = header + list(self._imports) + lines\n        else:\n            lines = list(self._imports) + lines\n\n        if len(self._kwargs_type_.keys()) and False:\n            header = []\n            impl = []\n            header.append('class _KwArgs_ {')\n            header.append(' public:')\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  %s _%s_;' %(type,name))\n                header.append( '  bool __use__%s;' %name)\n\n            for name in self._kwargs_type_:\n                type = self._kwargs_type_[name]\n                header.append( '  _KwArgs_*  %s(%s %s);' %(name, type, name))\n\n                impl.append( '  _KwArgs_*   _KwArgs_::%s(%s %s) {' %(name, type, name))\n                impl.append( '      this- __use__%s = true;' %name)\n                impl.append( '      this- _%s_ = %s;' %(name, name))\n                impl.append( '      return this;')\n                impl.append('};')\n            header.append('};')\n            header.extend( impl )\n            lines.extend(header)\n\n\n        pak['main'] = '\\n'.join( lines )\n        return pak['main']\n\n    def visit_Set(self, node):\n        ## c++11 aggregate initialization\n        ## http://en.cppreference.com/w/cpp/language/aggregate_initialization\n        return '{%s}' %','.join([self.visit(elt) for elt in node.elts])  low level  new  for interfacing with external c++.\nAlso used for code that is blocked with  with pointers: \nto create a class without having to create a temp variable, f( new(MyClass(x,y)) ) , directly calls the constructor,\nif MyClass is a Rusthon class then  init  will be called.\nTODO fix mixing with std::shared_ptr by keeping a weak_ptr\nin each object that  init  returns (also fixes the _ref_hacks)  \n    def _visit_call_helper_new(self, node):\n        if isinstance(node.args[0], ast.BinOp): # makes an array or map\n            a = self.visit(node.args[0])\n            if type(a) is not tuple:\n                raise SyntaxError(self.format_error('TODO some extended type'))\n\n            atype, avalue = a\n            if atype.endswith('*'): atype = atype[:-1]\n            else: pass  ## this should never happen\n            return '(/*array-or-map*/ new %s %s)' %(atype, avalue)\n\n        ## Pythia User Class ##\n        elif isinstance(node.args[0], ast.Call) and isinstance(node.args[0].func, ast.Name) and node.args[0].func.id in self._classes:\n            classname = node.args[0].func.id\n            args = [self.visit(arg) for arg in node.args[0].args ]\n            if self._classes[classname]._requires_init:\n                if not isinstance(self._stack[-2], ast.Assign):\n                    raise RuntimeError('TODO new(A(new(B))')\n                return '(/*initialize-class*/ new %s)- __init__(%s)' %(classname, ','.join(args))\n\n            elif args:  ## a rusthon class that subclasses from an external c++ class ##\n                return '(/*external-parent-class*/ new %s(%s))' %(classname, ','.join(args))\n            else:\n                return '(/*create-class*/ new %s)' %classname\n\n        ## external c++ class ##\n        else:\n            classname = self.visit(node.args[0])\n            return '(/*external-class*/ new %s)' %classname  Subclasses from  RustGenerator , see here: rusttranslator.md \nTODO: reverse,  RustGenerator  should subclass from  CppGenerator .  note: polymorphic classes are not generated by default, virtual methods are not required,\ncasting works fine with  static_cast  and  std::static_pointer_cast .  \n    def __init__(self, source=None, requirejs=False, insert_runtime=False, cached_json_files=None, use_try=True):\n        RustGenerator.__init__(self, source=source, requirejs=False, insert_runtime=False)\n        self._cpp = True\n        self._rust = False  ## can not be true at the same time self._cpp is true, conflicts in switch/match hack.\n        self._shared_pointers = True\n        self._noexcept = False\n        self._polymorphic = False  ## by default do not use polymorphic classes (virtual methods)\n        self._has_jvm = False\n        self._jvm_classes = dict()\n        self._has_nim = False\n        self._has_nuitka = False\n        self._has_cpython = False\n        self._known_pyobjects  = dict()\n        self._use_runtime = insert_runtime\n        self.cached_json_files = cached_json_files or dict()\n        self.usertypes = dict()\n        self._user_class_headers = dict()\n        self._finally_id = 0\n        self._use_try = use_try\n        self._has_gnu_stm = False\n\n    def visit_Delete(self, node):\n        targets = [self.visit(t) for t in node.targets]\n        if len(targets)==0:\n            raise RuntimeError('no delete targets')\n        r = []\n        if self.usertypes and 'weakref' in self.usertypes and 'reset' in self.usertypes['weakref']:\n            for t in targets:\n                r.append('%s.%s();' %(t, self.usertypes['weakref']['reset']))\n        elif self.usertypes and 'shared' in self.usertypes and 'reset' in self.usertypes['shared']:\n            for t in targets:\n                r.append('%s.%s();' %(t, self.usertypes['shared']['reset']))\n        elif self._shared_pointers:\n            for t in targets:\n                r.append('%s.reset();' %t)\n        else:\n            for t in targets:\n                if t in self._known_arrays:\n                    r.append('delete[] %s;')\n                else:\n                    r.append('delete %s;')\n\n        return '\\n'.join(r)\n\n    def visit_Str(self, node, wrap=True):\n        s = node.s.replace( \\\\ ,  \\\\\\\\ ).replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace(' ', '\\\\ ')\n        if wrap is False:\n            return s\n        elif self._force_cstr:\n            return ' %s ' % s\n\n        elif self.usertypes and 'string' in self.usertypes.keys():\n            if self.usertypes['string'] is None:\n                return ' %s ' % s\n            else:\n                return self.usertypes['string']['new'] % ' %s ' % s\n        else:\n            return 'std::string( %s )' % s\n\n    def visit_Print(self, node):\n        r = []\n        for e in node.values:\n            s = self.visit(e)\n            if isinstance(e, ast.List) or isinstance(e, ast.Tuple):\n                for sube in e.elts:\n                    r.append('std::cout   %s;' %self.visit(sube))\n                if r:\n                    r[-1] += 'std::cout   std::endl;'\n                else:\n                    r.append('std::cout   std::endl;')\n            else:\n                r.append('std::cout   %s   std::endl;' %s)\n        return '\\n'.join(r)", 
            "title": "Imports"
        }, 
        {
            "location": "/cpptranslator/#todo", 
            "text": "test finally   \n    def visit_TryExcept(self, node, finallybody=None):\n        ## TODO: check why `catch (...)` is not catching file errors\n        out = []\n\n        use_try = self._use_try  ## when building with external tools or platforms -fexceptions can not be enabled.\n\n\n        if use_try:\n            if finallybody:\n                self._finally_id += 1\n                out.append('bool __finally_done_%s = false;' %self._finally_id)\n                out.append( self.indent()+'try {' )\n            else:\n                out.append( 'try {' )\n\n        self.push()\n        for b in node.body:\n            out.append( self.indent()+self.visit(b) )\n\n        self.pull()\n        if use_try:\n            out.append(self.indent()+ '}' )\n\n            handler_types = []\n            for ha in node.handlers:\n                if ha.type:\n                    handler_types.append(self.visit(ha.type))\n\n            if handler_types:\n                out.append( self.indent() + 'catch (std::runtime_error* __error__) {' )\n                self.push()\n                out.append( self.indent() + 'std::string __errorname__ = __parse_error_type__(__error__);')\n            else:\n                out.append( self.indent() + 'catch (...) {' )\n                self.push()\n\n            for h in node.handlers:\n                out.append(\n                    self.indent() + self.visit_ExceptHandler(h, finallybody=finallybody)\n                )\n            self.pull()\n\n            out.append(self.indent()+ '}' )\n\n            ## TODO also catch these error that standard c++ libraries are likely to throw ##\n            #out.append( self.indent() + 'catch (const std::overflow_error  e) { std::cout    OVERFLOW ERROR    std::endl; }' )\n            #out.append( self.indent() + 'catch (const std::runtime_error  e) { std::cout    RUNTIME ERROR    std::endl; }' )\n            #out.append( self.indent() + 'catch (const std::exception  e) {' )\n            #out.append( self.indent() + 'catch (...) { std::cout    UNKNOWN ERROR    std::endl; }' )\n\n\n            ## wrap in another try that is silent\n            if finallybody:\n                out.append(self.indent()+'if (__finally_done_%s == false) {' %self._finally_id )\n                self.push()\n                out.append(self.indent()+'try {     // finally block')\n                self.push()\n                for b in finallybody:\n                    out.append(self.indent()+self.visit(b))\n                self.pull()\n                out.append(self.indent()+'} catch (...) {}')\n                self.pull()\n                out.append(self.indent()+'}')\n\n                self._finally_id -= 1\n\n        return '\\n'.join( out )\n\n    def visit_ExceptHandler(self, node, finallybody=None):\n        #out = ['catch (std::runtime_error* __error__) {']\n        T = 'Error'\n        out = []\n        if node.type:\n            T = self.visit(node.type)\n            out.append('if (__errorname__ == std::string( %s )) {' %T )\n\n        self.push()\n\n        if node.name:\n            #out.append(self.indent()+'auto %s = *__error__;' % self.visit(node.name))\n            out.append(self.indent()+'auto %s = __error__;' % self.visit(node.name))\n\n        ## this happens before the exception body, while this is not strictly python\n        ## it is close enough, because the main requirement is that the finally body\n        ## is always run, even if there is a return or new exception raised.\n        if finallybody:\n            out.append(self.indent()+'__finally_done_%s = true;' %self._finally_id)\n            self.push()\n            out.append(self.indent()+'try {     // finally block')\n            self.push()\n            for b in finallybody:\n                out.append(self.indent()+self.visit(b))\n            self.pull()\n            out.append(self.indent()+'} catch (...) {}')\n            self.pull()\n\n\n        for b in node.body:\n            out.append(self.indent()+self.visit(b))\n\n        self.pull()\n        if node.type:\n            out.append(self.indent()+'}')\n        return '\\n'.join(out)", 
            "title": "TODO"
        }, 
        {
            "location": "/cpptranslator/#cpython-c-api", 
            "text": "user syntax  import cpython  and  -  \n    def gen_cpy_call(self, pyob, node):\n        fname = self.visit(node.func)\n        if not node.args and not node.keywords:\n            return 'PyObject_Call(%s, Py_BuildValue( () ), NULL)' %pyob\n        else:\n            lambda_args = [\n                '[ ] {',\n                'auto args = PyTuple_New(%s);' %len(node.args),\n            ]\n            for i,arg in enumerate(node.args):\n                if isinstance(arg, ast.Num):\n                    n = arg.n\n                    if str(n).isdigit():\n                        n = 'PyInt_FromLong(%s)' %n\n                        lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, n))\n                    else:\n                        n = 'PyFloat_FromDouble(%s)' %n\n                        lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, n))\n                elif isinstance(arg, ast.Str):\n                    n = 'PyString_FromString( %s )' %arg.s\n                    lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, n))\n                else:\n                    lambda_args.append('PyTuple_SetItem(args, %s, %s);' %(i, self.visit(arg)))\n            lambda_args.append('return args; }()')\n            return 'PyObject_Call(%s, %s, NULL)' %(pyob, '\\n'.join(lambda_args))\n\n    def gen_cpy_get(self, pyob, name):\n        return 'PyObject_GetAttrString(%s, %s )' %(pyob, name)", 
            "title": "CPython C-API"
        }, 
        {
            "location": "/cpptranslator/#slice-and-list-comprehension-intx-for-x-in-rangen", 
            "text": "negative slice is not fully supported, only  -1  literal works.  \n    def _gen_slice(self, target=None, value=None, lower=None, upper=None, step=None, type=None, result_size=None):\n        assert target\n        assert value\n        fixed_size = None\n        if type and isinstance(type, tuple) and type[1]:\n            fixed_size = type[1]\n            type = type[0]\n\n        elif type and type.startswith('[]'):\n            T = type.split(']')[-1].strip()\n            if self.is_prim_type(T) or self._memory[-1]=='STACK':\n                type = T\n            elif type.count('[')==1:\n                type = 'std::shared_ptr %s ' %T\n            else:\n                raise RuntimeError('TODO md-array slice')\n\n\n        #################################################\n        if fixed_size:\n            slice = ['/*  fixed size slice  %s : %s : %s */' %(lower, upper, step)]\n            con = []\n            is_constant = True\n\n            if fixed_size.isdigit():\n                fixed_size = int(fixed_size)\n                if lower and not upper:\n                    if lower.isdigit():\n                        for i in range(int(lower), fixed_size):\n                            con.append('%s[%s]' %(value,i))\n                    else:\n                        is_constant = False\n                elif upper and not lower:\n                    if upper.isdigit():\n                        for i in range(0, int(upper)):\n                            con.append('%s[%s]' %(value,i))\n                    else:\n                        is_constant = False\n                elif not lower and not upper:\n                    if step=='-1':\n                        i = fixed_size-1\n                        while i  = 0:\n                            con.append('%s[%s]' %(value,i))\n                            i -= 1\n                    else:\n                        for i in range(fixed_size):\n                            con.append('%s[%s]' %(value,i))\n                else:\n                    raise SyntaxError('todo slice fixed size stack array')\n\n                if is_constant:\n                    slice.append(\n                        self.indent()+'%s %s[%s] = {%s};' %(type,target, result_size, ','.join(con))\n                    )\n                else:\n                    pass  ## fallback to for loop\n            else:\n                is_constant = False\n\n            if not is_constant:\n                if not lower and not upper:\n                    if step=='-1':\n                        slice.extend([\n                            self.indent()+'%s %s[%s];' %(type,target, fixed_size),\n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s-1; __i =%s; __i--) {' %(fixed_size, lower),\n                            self.indent()+'  %s[__L] = %s[__i];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ])\n                    else:\n                        slice.extend([\n                            self.indent()+'%s %s[%s];' %(type,target, fixed_size),\n                            self.indent()+'for (int __i=0; __i %s; __i++) {' %fixed_size,\n                            self.indent()+'  %s[__i] = %s[__i];' %(target, value),\n                            self.indent()+'}',\n                        ])\n\n                elif lower and not upper:\n                    if step=='-1':\n                        slice.extend([\n                            self.indent()+'%s %s[%s-%s];' %(type,target, fixed_size, lower),                        \n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s-1; __i =%s; __i--) {' %(fixed_size, lower),\n                            self.indent()+'  %s[__L] = %s[__i];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ])\n                    else:\n                        slice.extend([\n                            self.indent()+'%s %s[%s-%s];' %(type,target, fixed_size, lower),                        \n                            self.indent()+'int __L = 0;',\n                            self.indent()+'for (int __i=%s; __i %s; __i++) {' %(lower, fixed_size),\n                            self.indent()+'  %s[__L] = %s[__i];' %(target, value),\n                            self.indent()+'  __L ++;',\n                            self.indent()+'}',\n                        ])\n                elif upper and not lower:\n                    slice.extend([\n                        self.indent()+'%s %s[%s];' %(type,target, upper),                       \n                        self.indent()+'int __U = 0;',\n                        self.indent()+'for (int __i=0; __i %s; __i++) {' %upper,\n                        self.indent()+'  %s[__U] = %s[__i];' %(target, value),\n                        self.indent()+'  __U ++;',\n                        self.indent()+'}',\n                    ])\n                else:\n                    raise SyntaxError('\\n'.join(slice))\n            return '\\n'.join(slice)\n\n        elif type:\n            slice = ['/* slice  `%s` [%s:%s:%s] %s */' %(value, lower, upper, step, type)]\n            if ' ' in type and ' ' in type:\n                type = type.split(' ')[-1].split(' ')[0]\n                if self._memory[-1]=='HEAP':\n                    if not self.is_prim_type(type):\n                        type = 'std::shared_ptr %s ' %type\n\n            if step== -1 :  ##if step.isdigit() and int(step) 0: TODO\n                if self._memory[-1]=='STACK':\n                    slice.append(self.indent()+'std::vector %s  %s;' %(type,target))\n                else:\n                    slice.append(self.indent()+'std::vector %s  _ref_%s;' %(type,target))\n\n                step = step[1:]  ## strip `-`\n                if lower and not upper:\n                    if self._memory[-1]=='STACK':\n                        slice.extend([\n                            'for(int _i_=%s;_i_ =0;_i_-=%s){' %(lower,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}'\n                        ])\n                    else:\n                        slice.extend([\n                            #'for(int _i_=%s- size()-(1+%s);_i_ =0;_i_-=%s){' %(value,lower,step),\n                            'for(int _i_=%s;_i_ =0;_i_-=%s){' %(lower,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}'\n                        ])\n                elif upper:\n                    raise RuntimeError('slice todo')\n                else:\n                    if self._memory[-1]=='STACK':\n                        slice.extend([\n                            'for(int _i_=%s.size()-1;_i_ =0;_i_-=%s){' %(value,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}',\n                        ])\n                    else:\n                        slice.extend([\n                            'for(int _i_=%s- size()-1;_i_ =0;_i_-=%s){' %(value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}',\n                        ])\n\n            elif step:\n                if self._memory[-1]=='STACK':\n                    slice.append('std::vector %s  %s;' %(type,target))\n                else:\n                    slice.append('std::vector %s  _ref_%s;' %(type,target))\n\n                if lower and not upper:\n                    if self._memory[-1]=='STACK':\n                        slice.append( ''.join([\n                            'if(%s 0){'%step,\n                            'for(int _i_=%s.size()-%s-1;_i_ =0;_i_+=%s){' %(value,lower,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}} else {',\n                            'for(int _i_=%s;_i_ %s.size();_i_+=%s){' %(lower,value,step),\n                            ' %s.push_back(%s[_i_]);' %(target, value),\n                            '}}',\n                            ])\n                        )\n                    else:\n                        slice.append( ''.join([\n                            'if(%s 0){'%step,\n                            'for(int _i_=%s- size()-%s-1;_i_ =0;_i_+=%s){' %(value,lower,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}} else {',\n                            'for(int _i_=%s;_i_ %s- size();_i_+=%s){' %(lower,value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);' %(target, value),\n                            '}}',\n                            ])\n                        )\n                elif upper:\n                    raise SyntaxError('TODO slice upper with step')\n                else:\n                    if self._memory[-1]=='STACK':\n                        slice.append( ''.join([\n                            'if(%s 0){'%step,\n                            'for(int _i_=%s.size()-1;_i_ =0;_i_+=%s){' %(value,step),\n                            ' %s.push_back(%s[_i_]);}' %(target, value),\n                            '} else {',\n                            'for(int _i_=0;_i_ %s.size();_i_+=%s){' %(value,step),\n                            ' %s.push_back(%s[_i_]);}' %(target, value),\n                            '}',\n                            ])\n                        )\n\n                    else:\n                        slice.append( ''.join([\n                            'if(%s 0){'%step,\n                            'for(int _i_=%s- size()-1;_i_ =0;_i_+=%s){' %(value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);}' %(target, value),\n                            '} else {',\n                            'for(int _i_=0;_i_ %s- size();_i_+=%s){' %(value,step),\n                            ' _ref_%s.push_back((*%s)[_i_]);}' %(target, value),\n                            '}',\n                            ])\n                        )\n            else:\n                isptr = False\n                #if value in self._known_arrays and isinstance(self._known_arrays[value], str):\n                #   if self._known_arrays[value].startswith('[]'):\n                #       isptr = True\n                if value in self._known_pointers:\n                    isptr = True\n                    if self._memory[-1]=='HEAP':\n                        self._known_pointers[target] = self._known_pointers[value]\n                if self._memory[-1]=='STACK':\n                    self._known_refs[target] = type\n                ################################\n\n                if isptr and self._memory[-1]=='HEAP':\n                    slice.append(self.indent()+'auto %s = new std::vector %s (' %(target, type))                    \n                elif self._memory[-1]=='STACK':\n                    slice.append(self.indent()+'std::vector %s  %s(' %(type,target))\n                else:\n                    slice.append(self.indent()+'std::vector %s  _ref_%s(' %(type,target))\n\n                if lower:\n                    if isptr:\n                        slice.append(self.indent()+'%s- begin()+%s,' %(value, lower))\n                    elif self._memory[-1]=='STACK':\n                        slice.append(self.indent()+'%s.begin()+%s,' %(value, lower))\n                    else:\n                        slice.append(self.indent()+'%s- begin()+%s,' %(value, lower))\n                else:\n                    if isptr:\n                        slice.append(self.indent()+'%s- begin(),' %value)\n                    elif self._memory[-1]=='STACK':\n                        slice.append(self.indent()+'%s.begin(),' %value)\n                    else:\n                        slice.append(self.indent()+'%s- begin(),' %value)\n\n                if upper:\n                    if upper   0:\n                        if self._memory[-1]=='STACK':\n                            slice.append(self.indent()+'%s.end() %s'%(value, upper))\n                        else:\n                            slice.append(self.indent()+'%s- end() %s'%(value, upper))\n                    else:\n                        if self._memory[-1]=='STACK':\n                            slice.append(self.indent()+'%s.begin()+%s'%(value, upper))\n                        else:\n                            slice.append(self.indent()+'%s- begin()+%s'%(value, upper))\n\n                else:\n                    if isptr:\n                        slice.append(self.indent()+'%s- end()'%value)\n                    elif self._memory[-1]=='STACK':\n                        slice.append(self.indent()+'%s.end()'%value)\n                    else:\n                        slice.append(self.indent()+'%s- end()'%value)\n\n                slice.append(self.indent()+');')\n\n            vectype = 'std::vector %s ' %type\n\n            if self._memory[-1]=='STACK':\n                pass\n            elif not self._shared_pointers:\n                slice.append(self.indent()+'%s* %s =  _ref_%s);' %(vectype, target, target))\n            elif self._unique_ptr:\n                slice.append(self.indent()+'std::unique_ptr %s  %s = _make_unique %s (_ref_%s);' %(vectype, target, vectype, target))\n            else:\n                slice.append(self.indent()+'std::shared_ptr %s  %s = std::make_shared %s (_ref_%s);' %(vectype, target, vectype, target))\n            return '\\n'.join(slice)\n\n        else:  ## slice an unknown type of array ##\n            if not lower and not upper and not step:  ## slice copy `myarr[:]`\n                if self._memory[-1]=='STACK':\n                    return 'std::vector  decltype(%s- begin())::value_type   %s( %s- begin(), %s- end() );' %(value, target, value, value)\n                else:\n                    vectype = 'std::vector decltype(%s- begin())::value_type ' %value\n                    return 'auto %s = std::make_shared %s ( %s(%s- begin(),%s- end()) );' %(target, vectype,vectype, value, value)\n\n            elif lower and not upper and not step:\n                if self._memory[-1]=='STACK':\n                    return 'std::vector  decltype(%s- begin())::value_type   %s( %s- begin()+%s, %s- end() );' %(value, target, value, lower, value)\n                else:\n                    vectype = 'std::vector decltype(%s- begin())::value_type ' %value\n                    return 'auto %s = std::make_shared %s ( %s(%s- begin()+%s,%s- end()) );' %(target, vectype,vectype, value, lower, value)\n            elif upper and not lower and not step:\n                if self._memory[-1]=='STACK':\n                    return 'std::vector  decltype(%s- begin())::value_type   %s( %s- begin(), %s- begin()+%s );' %(value, target, value, value, upper)\n                else:\n                    vectype = 'std::vector decltype(%s- begin())::value_type ' %value\n                    return 'auto %s = std::make_shared %s ( %s(%s- begin(),%s- begin()+%s) );' %(target, vectype,vectype, value, value, upper)\n\n            else:\n                raise RuntimeError('TODO slice unknown')", 
            "title": "Slice and List Comprehension [:], []int(x for x in range(n))"
        }, 
        {
            "location": "/cpptranslator/#translate-to-c", 
            "text": "TODO save GCC PGO files.  \ndef translate_to_cpp(script, insert_runtime=True, cached_json_files=None, use_try=True):\n    if '--debug-inter' in sys.argv:\n        raise RuntimeError(script)\n\n    if '--osv' in sys.argv:\n        osv = open( os.path.join(RUSTHON_LIB_ROOT, 'src/pythia/runtime/osv_builtins.py') ).read()\n        osv = python_to_pythonjs( osv, cpp=True )\n        script = osv + '\\n' + script\n\n    if insert_runtime:\n        runtime = open( os.path.join(RUSTHON_LIB_ROOT, 'src/pythia/runtime/cpp_builtins.py') ).read()\n        runtime = python_to_pythonjs( runtime, cpp=True )\n        script = runtime + '\\n' + script\n\n    try:\n        tree = ast.parse(script)\n    except SyntaxError as err:\n        e = ['%s:   %s'%(i+1, line) for i,line in enumerate(script.splitlines())]\n        sys.stderr.write('\\n'.join(e))\n        raise err\n\n    g = CppGenerator(\n        source=script, \n        insert_runtime=insert_runtime, \n        cached_json_files=cached_json_files,\n        use_try = use_try\n    )\n    g.visit(tree) # first pass gathers classes\n    pass2 = g.visit(tree)\n    g.reset()\n    pass3 = g.visit(tree)\n    userheaders = g.get_user_class_headers()\n    if userheaders:\n        g.output_pak['user-headers'] = userheaders\n    return g.output_pak", 
            "title": "Translate to C++"
        }, 
        {
            "location": "/typedpython/", 
            "text": "USE_UNICODE_VARS = '--literate-unicode' in sys.argv\nOBFUSCATE_UNICODE = '--obfuscate' in sys.argv\n\nObfuscationMap = {}  ## unichar : random string\n\nMathematicalAlphabet = {\n    u'\ud835\udc00' : 'A',\n    u'\ud835\udc01' : 'B',\n    u'\ud835\udc02' : 'C',\n    u'\ud835\udc03' : 'D',\n    u'\ud835\udc04' : 'E',\n    u'\ud835\udc05' : 'F',\n    u'\ud835\udc06' : 'G',\n    u'\ud835\udc07' : 'H',\n    u'\ud835\udc08' : 'I',\n    u'\ud835\udc09' : 'J',\n    u'\ud835\udc0a' : 'K',\n    u'\ud835\udc0b' : 'L',\n    u'\ud835\udc0c' : 'M',\n    u'\ud835\udc0d' : 'N',\n    u'\ud835\udc0e' : 'O',\n    u'\ud835\udc0f' : 'P',\n    u'\ud835\udc10' : 'Q',\n    u'\ud835\udc11' : 'R',\n    u'\ud835\udc12' : 'S',\n    u'\ud835\udc13' : 'T',\n    u'\ud835\udc14' : 'U',\n    u'\ud835\udc15' : 'V',\n    u'\ud835\udc16' : 'W',\n    u'\ud835\udc17' : 'X',\n    u'\ud835\udc18' : 'Y',\n    u'\ud835\udc19' : 'Z',\n    u'\ud835\udc1a' : 'a',\n    u'\ud835\udc1b' : 'b',\n    u'\ud835\udc1c' : 'c',\n    u'\ud835\udc1d' : 'd',\n    u'\ud835\udc1e' : 'e',\n    u'\ud835\udc1f' : 'f',\n    u'\ud835\udc20' : 'g',\n    u'\ud835\udc21' : 'h',\n    u'\ud835\udc22' : 'i',\n    u'\ud835\udc23' : 'j',\n    u'\ud835\udc24' : 'k',\n    u'\ud835\udc25' : 'l',\n    u'\ud835\udc26' : 'm',\n    u'\ud835\udc27' : 'n',\n    u'\ud835\udc28' : 'o',\n    u'\ud835\udc29' : 'p',\n    u'\ud835\udc2a' : 'q',\n    u'\ud835\udc2b' : 'r',\n    u'\ud835\udc2c' : 's',\n    u'\ud835\udc2d' : 't',\n    u'\ud835\udc2e' : 'u',\n    u'\ud835\udc2f' : 'v',\n    u'\ud835\udc30' : 'w',\n    u'\ud835\udc31' : 'x',\n    u'\ud835\udc32' : 'y',\n    u'\ud835\udc33' : 'z',\n    u'\ud835\udc34' : 'A',\n    u'\ud835\udc35' : 'B',\n    u'\ud835\udc36' : 'C',\n    u'\ud835\udc37' : 'D',\n    u'\ud835\udc38' : 'E',\n    u'\ud835\udc39' : 'F',\n    u'\ud835\udc3a' : 'G',\n    u'\ud835\udc3b' : 'H',\n    u'\ud835\udc3c' : 'I',\n    u'\ud835\udc3d' : 'J',\n    u'\ud835\udc3e' : 'K',\n    u'\ud835\udc3f' : 'L',\n    u'\ud835\udc40' : 'M',\n    u'\ud835\udc41' : 'N',\n    u'\ud835\udc42' : 'O',\n    u'\ud835\udc43' : 'P',\n    u'\ud835\udc44' : 'Q',\n    u'\ud835\udc45' : 'R',\n    u'\ud835\udc46' : 'S',\n    u'\ud835\udc47' : 'T',\n    u'\ud835\udc48' : 'U',\n    u'\ud835\udc49' : 'V',\n    u'\ud835\udc4a' : 'W',\n    u'\ud835\udc4b' : 'X',\n    u'\ud835\udc4c' : 'Y',\n    u'\ud835\udc4d' : 'Z',\n    u'\ud835\udc4e' : 'a',\n    u'\ud835\udc4f' : 'b',\n    u'\ud835\udc50' : 'c',\n    u'\ud835\udc51' : 'd',\n    u'\ud835\udc52' : 'e',\n    u'\ud835\udc53' : 'f',\n    u'\ud835\udc54' : 'g',\n    u'\ud835\udc56' : 'i',\n    u'\ud835\udc57' : 'j',\n    u'\ud835\udc58' : 'k',\n    u'\ud835\udc59' : 'l',\n    u'\ud835\udc5a' : 'm',\n    u'\ud835\udc5b' : 'n',\n    u'\ud835\udc5c' : 'o',\n    u'\ud835\udc5d' : 'p',\n    u'\ud835\udc5e' : 'q',\n    u'\ud835\udc5f' : 'r',\n    u'\ud835\udc60' : 's',\n    u'\ud835\udc61' : 't',\n    u'\ud835\udc62' : 'u',\n    u'\ud835\udc63' : 'v',\n    u'\ud835\udc64' : 'w',\n    u'\ud835\udc65' : 'x',\n    u'\ud835\udc66' : 'y',\n    u'\ud835\udc67' : 'z',\n    u'\ud835\udc68' : 'A',\n    u'\ud835\udc69' : 'B',\n    u'\ud835\udc6a' : 'C',\n    u'\ud835\udc6b' : 'D',\n    u'\ud835\udc6c' : 'E',\n    u'\ud835\udc6d' : 'F',\n    u'\ud835\udc6e' : 'G',\n    u'\ud835\udc6f' : 'H',\n    u'\ud835\udc70' : 'I',\n    u'\ud835\udc71' : 'J',\n    u'\ud835\udc72' : 'K',\n    u'\ud835\udc73' : 'L',\n    u'\ud835\udc74' : 'M',\n    u'\ud835\udc75' : 'N',\n    u'\ud835\udc76' : 'O',\n    u'\ud835\udc77' : 'P',\n    u'\ud835\udc78' : 'Q',\n    u'\ud835\udc79' : 'R',\n    u'\ud835\udc7a' : 'S',\n    u'\ud835\udc7b' : 'T',\n    u'\ud835\udc7c' : 'U',\n    u'\ud835\udc7d' : 'V',\n    u'\ud835\udc7e' : 'W',\n    u'\ud835\udc7f' : 'X',\n    u'\ud835\udc80' : 'Y',\n    u'\ud835\udc81' : 'Z',\n    u'\ud835\udc82' : 'a',\n    u'\ud835\udc83' : 'b',\n    u'\ud835\udc84' : 'c',\n    u'\ud835\udc85' : 'd',\n    u'\ud835\udc86' : 'e',\n    u'\ud835\udc87' : 'f',\n    u'\ud835\udc88' : 'g',\n    u'\ud835\udc89' : 'h',\n    u'\ud835\udc8a' : 'i',\n    u'\ud835\udc8b' : 'j',\n    u'\ud835\udc8c' : 'k',\n    u'\ud835\udc8d' : 'l',\n    u'\ud835\udc8e' : 'm',\n    u'\ud835\udc8f' : 'n',\n    u'\ud835\udc90' : 'o',\n    u'\ud835\udc91' : 'p',\n    u'\ud835\udc92' : 'q',\n    u'\ud835\udc93' : 'r',\n    u'\ud835\udc94' : 's',\n    u'\ud835\udc95' : 't',\n    u'\ud835\udc96' : 'u',\n    u'\ud835\udc97' : 'v',\n    u'\ud835\udc98' : 'w',\n    u'\ud835\udc99' : 'x',\n    u'\ud835\udc9a' : 'y',\n    u'\ud835\udc9b' : 'z',\n    u'\ud835\udc9c' : 'A',\n    u'\ud835\udc9e' : 'C',\n    u'\ud835\udc9f' : 'D',\n    u'\ud835\udca2' : 'G',\n    u'\ud835\udca5' : 'J',\n    u'\ud835\udca6' : 'K',\n    u'\ud835\udca9' : 'N',\n    u'\ud835\udcaa' : 'O',\n    u'\ud835\udcab' : 'P',\n    u'\ud835\udcac' : 'Q',\n    u'\ud835\udcae' : 'S',\n    u'\ud835\udcaf' : 'T',\n    u'\ud835\udcb0' : 'U',\n    u'\ud835\udcb1' : 'V',\n    u'\ud835\udcb2' : 'W',\n    u'\ud835\udcb3' : 'X',\n    u'\ud835\udcb4' : 'Y',\n    u'\ud835\udcb5' : 'Z',\n    u'\ud835\udcb6' : 'a',\n    u'\ud835\udcb7' : 'b',\n    u'\ud835\udcb8' : 'c',\n    u'\ud835\udcb9' : 'd',\n    u'\ud835\udcbb' : 'f',\n    u'\ud835\udcbb\ud835\udcbd' : 'h',\n    u'\ud835\udcbe' : 'i',\n    u'\ud835\udcbf' : 'j',\n    u'\ud835\udcc0' : 'k',\n    u'\ud835\udcc1' : 'l',\n    u'\ud835\udcc2' : 'm',\n    u'\ud835\udcc3' : 'n',\n    u'\ud835\udcc5' : 'p',\n    u'\ud835\udcc6' : 'q',\n    u'\ud835\udcc7' : 'r',\n    u'\ud835\udcc8' : 's',\n    u'\ud835\udcc9' : 't',\n    u'\ud835\udcca' : 'u',\n    u'\ud835\udccb' : 'v',\n    u'\ud835\udccc' : 'w',\n    u'\ud835\udccd' : 'x',\n    u'\ud835\udcce' : 'y',\n    u'\ud835\udccf' : 'z',\n    u'\ud835\udcd0' : 'A',\n    u'\ud835\udcd1' : 'B',\n    u'\ud835\udcd2' : 'C',\n    u'\ud835\udcd3' : 'D',\n    u'\ud835\udcd4' : 'E',\n    u'\ud835\udcd5' : 'F',\n    u'\ud835\udcd6' : 'G',\n    u'\ud835\udcd7' : 'H',\n    u'\ud835\udcd8' : 'I',\n    u'\ud835\udcd9' : 'J',\n    u'\ud835\udcda' : 'K',\n    u'\ud835\udcdb' : 'L',\n    u'\ud835\udcdc' : 'M',\n    u'\ud835\udcdd' : 'N',\n    u'\ud835\udcde' : 'O',\n    u'\ud835\udcdf' : 'P',\n    u'\ud835\udce0' : 'Q',\n    u'\ud835\udce1' : 'R',\n    u'\ud835\udce2' : 'S',\n    u'\ud835\udce3' : 'T',\n    u'\ud835\udce4' : 'U',\n    u'\ud835\udce5' : 'V',\n    u'\ud835\udce6' : 'W',\n    u'\ud835\udce7' : 'X',\n    u'\ud835\udce8' : 'Y',\n    u'\ud835\udce9' : 'Z',\n    u'\ud835\udcea' : 'a',\n    u'\ud835\udceb' : 'b',\n    u'\ud835\udcec' : 'c',\n    u'\ud835\udced' : 'd',\n    u'\ud835\udcee' : 'e',\n    u'\ud835\udcef' : 'f',\n    u'\ud835\udcf0' : 'g',\n    u'\ud835\udcf1' : 'h',\n    u'\ud835\udcf2' : 'i',\n    u'\ud835\udcf3' : 'j',\n    u'\ud835\udcf4' : 'k',\n    u'\ud835\udcf5' : 'l',\n    u'\ud835\udcf6' : 'm',\n    u'\ud835\udcf7' : 'n',\n    u'\ud835\udcf8' : 'o',\n    u'\ud835\udcf9' : 'p',\n    u'\ud835\udcfa' : 'q',\n    u'\ud835\udcfb' : 'r',\n    u'\ud835\udcfc' : 's',\n    u'\ud835\udcfd' : 't',\n    u'\ud835\udcfe' : 'u',\n    u'\ud835\udcff' : 'v',\n    u'\ud835\udd00' : 'w',\n    u'\ud835\udd01' : 'x',\n    u'\ud835\udd02' : 'y',\n    u'\ud835\udd03' : 'z',\n    u'\ud835\udd04' : 'A',\n    u'\ud835\udd05' : 'B',\n    u'\ud835\udd07' : 'D',\n    u'\ud835\udd08' : 'E',\n    u'\ud835\udd09' : 'F',\n    u'\ud835\udd0a' : 'G',\n    u'\ud835\udd0d' : 'J',\n    u'\ud835\udd0e' : 'K',\n    u'\ud835\udd0f' : 'L',\n    u'\ud835\udd10' : 'W',\n    u'\ud835\udd1b' : 'X',\n    u'\ud835\udd1c' : 'Y',\n    u'\ud835\udd1e' : 'a',\n    u'\ud835\udd1f' : 'b',\n    u'\ud835\udd20' : 'c',\n    u'\ud835\udd21' : 'd',\n    u'\ud835\udd22' : 'e',\n    u'\ud835\udd23' : 'f',\n    u'\ud835\udd24' : 'g',\n    u'\ud835\udd25' : 'h',\n    u'\ud835\udd26' : 'i',\n    u'\ud835\udd27' : 'j',\n    u'\ud835\udd28' : 'k',\n    u'\ud835\udd29' : 'l',\n    u'\ud835\udd2a' : 'm',\n    u'\ud835\udd2b' : 'n',\n    u'\ud835\udd2c' : 'o',\n    u'\ud835\udd2d' : 'p',\n    u'\ud835\udd2e' : 'q',\n    u'\ud835\udd2f' : 'r',\n    u'\ud835\udd30' : 's',\n    u'\ud835\udd31' : 't',\n    u'\ud835\udd32' : 'u',\n    u'\ud835\udd33' : 'v',\n    u'\ud835\udd34' : 'w',\n    u'\ud835\udd35' : 'x',\n    u'\ud835\udd36' : 'y',\n    u'\ud835\udd37' : 'z',\n    u'\ud835\udd38' : 'A',\n    u'\ud835\udd39' : 'B',\n    u'\ud835\udd3b' : 'D',\n    u'\ud835\udd3c' : 'E',\n    u'\ud835\udd3d' : 'F',\n    u'\ud835\udd3e' : 'G',\n    u'\ud835\udd40' : 'I',\n    u'\ud835\udd41' : 'J',\n    u'\ud835\udd42' : 'K',\n    u'\ud835\udd43' : 'L',\n    u'\ud835\udd44' : 'M',\n    u'\ud835\udd46' : 'O',\n    u'\ud835\udd4a' : 'S',\n    u'\ud835\udd4b' : 'T',\n    u'\ud835\udd4c' : 'U',\n    u'\ud835\udd4d' : 'V',\n    u'\ud835\udd4e' : 'W',\n    u'\ud835\udd4f' : 'X',\n    u'\ud835\udd50' : 'Y',\n    u'\ud835\udd52' : 'a',\n    u'\ud835\udd53' : 'b',\n    u'\ud835\udd54' : 'c',\n    u'\ud835\udd55' : 'd',\n    u'\ud835\udd56' : 'e',\n    u'\ud835\udd57' : 'f',\n    u'\ud835\udd58' : 'g',\n    u'\ud835\udd59' : 'h',\n    u'\ud835\udd5a' : 'i',\n    u'\ud835\udd5b' : 'j',\n    u'\ud835\udd5c' : 'k',\n    u'\ud835\udd5d' : 'l',\n    u'\ud835\udd5e' : 'm',\n    u'\ud835\udd5f' : 'n',\n    u'\ud835\udd60' : 'o',\n    u'\ud835\udd61' : 'p',\n    u'\ud835\udd62' : 'q',\n    u'\ud835\udd63' : 'r',\n    u'\ud835\udd64' : 's',\n    u'\ud835\udd65' : 't',\n    u'\ud835\udd66' : 'u',\n    u'\ud835\udd67' : 'v',\n    u'\ud835\udd68' : 'w',\n    u'\ud835\udd69' : 'x',\n    u'\ud835\udd6a' : 'y',\n    u'\ud835\udd6b' : 'z',\n    u'\ud835\udd6c' : 'A',\n    u'\ud835\udd6d' : 'B',\n    u'\ud835\udd6e' : 'C',\n    u'\ud835\udd6f' : 'D',\n    u'\ud835\udd70' : 'E',\n    u'\ud835\udd71' : 'F',\n    u'\ud835\udd72' : 'G',\n    u'\ud835\udd73' : 'H',\n    u'\ud835\udd73' : 'I',\n    u'\ud835\udd75' : 'J',\n    u'\ud835\udd76' : 'K',\n    u'\ud835\udd77' : 'L',\n    u'\ud835\udd78' : 'M',\n    u'\ud835\udd79' : 'N',\n    u'\ud835\udd7a' : 'O',\n    u'\ud835\udd7b' : 'P',\n    u'\ud835\udd7c' : 'Q',\n    u'\ud835\udd7d' : 'R',\n    u'\ud835\udd7e' : 'S',\n    u'\ud835\udd7f' : 'T',\n    u'\ud835\udd80' : 'U',\n    u'\ud835\udd81' : 'V',\n    u'\ud835\udd82' : 'W',\n    u'\ud835\udd83' : 'X',\n    u'\ud835\udd84' : 'Y',\n    u'\ud835\udd85' : 'E',\n    u'\ud835\udd86' : 'a',\n    u'\ud835\udd87' : 'b',\n    u'\ud835\udd88' : 'c',\n    u'\ud835\udd89' : 'd',\n    u'\ud835\udd8a' : 'e',\n    u'\ud835\udd8b' : 'f',\n    u'\ud835\udd8c' : 'g',\n    u'\ud835\udd8d' : 'h',\n    u'\ud835\udd8e' : 'i',\n    u'\ud835\udd8f' : 'j',\n    u'\ud835\udd90' : 'k',\n    u'\ud835\udd91' : 'l',\n    u'\ud835\udd92' : 'm',\n    u'\ud835\udd93' : 'n',\n    u'\ud835\udd94' : 'o',\n    u'\ud835\udd95' : 'p',\n    u'\ud835\udd96' : 'q',\n    u'\ud835\udd97' : 'r',\n    u'\ud835\udd98' : 's',\n    u'\ud835\udd99' : 't',\n    u'\ud835\udd9a' : 'u',\n    u'\ud835\udd9b' : 'v',\n    u'\ud835\udd9c' : 'w',\n    u'\ud835\udd9d' : 'x',\n    u'\ud835\udd9e' : 'y',\n    u'\ud835\udd9f' : 'z',\n}\n\nUnicodeEscapeMap = {}  ## number : unichar\n\ndef _gen_random_id(size=16):\n    import random, string\n    chars = string.ascii_uppercase + string.digits\n    return ''.join(random.choice(chars) for _ in range(size))\n\nclass typedpython:\n    unicode_vars = USE_UNICODE_VARS\n    types = ['string', 'str', 'list', 'dict', 'bool']\n    native_number_types = ['int', 'float', 'double']  ## float and double are the same\n    simd_types = ['float32x4', 'int32x4']  ## dart\n    vector_types = ['float32vec']\n    vector_types.extend( simd_types )\n    number_types = ['long']  ## requires https://github.com/dcodeIO/Long.js\n    number_types.extend( native_number_types )\n    types.extend( number_types)\n    types.extend( vector_types )\n\n    __whitespace = [' ', '\\t']\n\n    GO_SPECIAL_CALLS = {\n        'go'         : '__go__',\n        'spawn'      : '__go__',\n        'channel'    : '__go_make_chan__',\n        'go.channel' : '__go_make_chan__',\n        'go.array'   : '__go__array__',\n        'go.make'    : '__go_make__',\n        'go.addr'    : '__go__addr__',\n        'go.func'    : '__go__func__',\n    }\n\n    @classmethod\n    def needs_escape(cls,txt):\n        return '__x0s0x__' in txt\n\n    @classmethod\n    def escape_text(cls,txt):\n        escape_hack_start = '__x0s0x__'\n        escape_hack_end = '__x0e0x__'\n        parts = []\n        chunks = txt.split(escape_hack_start)\n        if len(chunks)==1:\n            raise RuntimeError('invalid sequence')\n\n        for p in chunks:\n            if escape_hack_end in p:\n                #if p.endswith( escape_hack_end ):\n                id = int(p.split(escape_hack_end)[0].strip())\n                assert id in UnicodeEscapeMap.keys()\n                uchar = UnicodeEscapeMap[ id ]\n                #if '__x0' in uchar:\n                #   print UnicodeEscapeMap\n                #   raise RuntimeError('bad:'+uchar)\n                parts.append(uchar)\n                parts.append(p.split(escape_hack_end)[1])\n            else:\n                #if '__x0' in p:\n                #   raise RuntimeError('bad escape:'+p)\n                if not p:\n                    continue\n                    print chunks\n                parts.append(p)\n\n        res = ''.join(parts)\n        return res.encode('utf-8')\n\n\n    @classmethod\n    def get_indent(cls, s):\n        indent = []\n        for char in s:\n            if char in cls.__whitespace:\n                indent.append( char )\n            else:\n                break\n        return ''.join(indent)\n\n    @classmethod\n    def transform_source(cls, source, strip=False, allow_tabs_and_spaces=True ):\n        output = []\n        output_post = None\n        asm_block = False\n        asm_block_indent = 0\n        indent_unit = '' # indent sensitive\n\n        for line in source.splitlines():\n            if line.strip().startswith('#'):\n                continue\n\n            if asm_block:\n                dent = cls.get_indent(line)\n                if asm_block==True:\n                    asm_block = 'OK'\n                    asm_block_indent = len(dent)\n\n                if len(dent) \n asm_block_indent:\n                    asm_block = False\n                    asm_block_indent = 0\n                elif len(dent) \n asm_block_indent:\n                    raise SyntaxError('invalid asm indentation level')\n                else:\n                    assert len(dent)==asm_block_indent\n                    if line.strip():\n                        output.append( '%s\n%s\n' %(dent,line.strip()) )\n                    else:\n                        asm_block = False\n                        asm_block_indent = 0\n                    continue\n\n            a = []\n            hit_go_typedef = False\n            hit_go_funcdef = False\n            gotype = None\n            isindef = False\n            isinlet = False\n            inline_wrap = False\n            inline_ptr = False\n            prevchar = None\n\n            if line.strip().startswith('cdef '):  ## cython syntax ##\n                line = line.replace('cdef ', 'cdef(\n') + '\n)'\n\n            for i,char in enumerate(line):\n\n                if isindef is False and len(a) and ''.join(a).strip().startswith('def '):\n                    isindef = True\n                if isinlet is False and len(a) and ''.join(a).strip().startswith('let '):\n                    isinlet = True\n\n                nextchar = None\n                j = i+1\n                while j \n len(line):\n                    nextchar = line[j]\n                    if nextchar.strip(): break\n                    j += 1\n\n                if char in MathematicalAlphabet.keys():\n                    if USE_UNICODE_VARS or OBFUSCATE_UNICODE:\n                        ## note with unicode characters they can not\n                        ## be restored wth chr(ord(char))\n                        if OBFUSCATE_UNICODE:\n                            if char not in ObfuscationMap:\n                                ObfuscationMap[ char ] = _gen_random_id()\n                            ucord = ObfuscationMap[ char ]\n                        else:\n                            ucord = ord(char)\n\n                        if ucord not in UnicodeEscapeMap:\n                            UnicodeEscapeMap[ ucord ] = char\n\n                        ## escape syntax ##\n                        char = '__x0s0x__%s__x0e0x__' % ucord\n                    else:\n                        char = MathematicalAlphabet[ char ]\n\n                elif ord(char) \n 255:\n                    if OBFUSCATE_UNICODE:\n                        if char not in ObfuscationMap:\n                            ObfuscationMap[ char ] = _gen_random_id()\n                        ucord = ObfuscationMap[ char ]\n                    else:\n                        ucord = ord(char)\n                    if ucord not in UnicodeEscapeMap:\n                        UnicodeEscapeMap[ ucord ] = char\n                    char = '__x0s0x__%s__x0e0x__' % ucord\n\n                ##################################\n\n                if prevchar=='=' and char in '\n*~':\n                    inline_ptr = True\n                    a.append('__inline__[\n' + char)\n                elif inline_ptr and char not in '\n*~':\n                    inline_ptr = False\n                    a.append('\n] \n ')\n                    a.append( char )\n\n                #elif char == '(' and nextchar in ('\n','@'):  ## DEPRECATED\n                #   inline_wrap = True\n                #   a.append('(inline(\n')\n                elif char in '),' and inline_wrap:\n                    inline_wrap = False\n                    for u,_ in enumerate(a):\n                        if _=='@':\n                            a[u] = 'ref '  ## old rust syntax\n                    if char == ')':\n                        a.append('\n))')\n                    else:\n                        a.append('\n),')\n\n                ## go array and map syntax ##\n                #elif (not isindef and not isinlet) and len(a) and char==']' and j==i+1 and nextchar!=None and nextchar in '[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                elif not isindef and len(a) and char==']' and j==i+1 and nextchar!=None and nextchar in '[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    assert '[' in a\n                    hit_go_typedef = True\n\n                    gotype = []\n                    restore = list(a)\n                    b = a.pop()\n                    while b != '[':\n                        gotype.append(b)\n                        b = a.pop()\n                    gotype.reverse()\n                    gotype = ''.join(gotype).strip()  ## fixes spaces inside brackets `[ 1 ]string()`\n                    if not gotype:\n                        if nextchar=='[':\n                            a.append('__go__array__\n')\n                        else:\n                            a.append('__go__array__(')\n                    elif gotype.isdigit():\n                        p = ''.join(a).split()[-1].strip()\n                        if p.startswith('[') or p.startswith('='):\n                            a.append('__go__arrayfixed__(%s,' %gotype)\n                        else:\n                            hit_go_typedef = False\n                            restore.append(char)\n                            a = restore\n\n                    elif ''.join(a[-3:])=='map' and gotype != 'func' and a[-4] in cls.__whitespace+['=']:\n                        a.pop(); a.pop(); a.pop()\n                        a.append('__go__map__(%s,' %gotype)\n                    else:\n                        hit_go_typedef = False\n                        restore.append(char)\n                        a = restore\n\n                elif hit_go_funcdef and char==')' and ')' in ''.join(a).split('func(')[-1] and not ''.join(a).strip().startswith('def '):\n                    hit_go_funcdef = False\n                    a.append('))\n')\n                elif hit_go_typedef and char=='(':\n                    if ''.join(a).endswith('func'):\n                        hit_go_funcdef = True\n                        a.append( '(' )\n                    else:\n                        a.append(')\n(')\n                    hit_go_typedef = False\n                elif hit_go_typedef and char=='{':\n                    a.append(')\n{')\n                    hit_go_typedef = False\n                elif hit_go_typedef and char==',':\n                    #a.append(', type=True),')  ## this breaks function annotations that splits on ','\n                    a.append('\ntypedef),')\n                    hit_go_typedef = False\n                elif hit_go_typedef and char in (' ', '\\t'):\n                    hit_go_typedef = False\n                    if isinlet:\n                        a.append(')')\n                    else:\n                        aa = []\n                        for xx in a:\n                            if xx == '__go__array__(':\n                                aa.append('__go__array__[')\n                            else:\n                                aa.append( xx )\n                        a = aa\n                        a.append(']=\\t\\t\\t\\t')\n\n\n                elif a and char in cls.__whitespace:\n                    b = ''.join(a)\n                    b = b.strip()\n                    is_class_type = b.startswith('class:') and len(b.split(':'))==2\n                    is_pointer = b.startswith('*')\n                    is_func = b.startswith('func(') and not ''.join(a).strip().startswith('func(')\n                    if (b in cls.types or is_class_type or is_pointer or is_func) and nextchar != '=':\n                        if strip:\n                            a = a[ : -len(b) ]\n                        elif is_class_type:\n                            cls = b.split(':')[-1]\n                            a = a[ : -len('class:')-len(cls)]\n                            a.append('__go__class__[%s]=\\t\\t\\t\\t' %cls)\n\n                        elif is_pointer:\n                            cls = b.split('*')[-1]\n                            a = a[ : -len('*')-len(cls)]\n                            a.append('__go__pointer__[%s]=\\t\\t\\t\\t' %cls)\n                        elif is_func:\n                            u = ''.join(a)\n                            u = u.replace('func(', '__go__func__[\nfunc(')\n                            u += '\n]=\\t\\t\\t\\t'\n                            raise RuntimeError(u)\n                            a = [w for w in u]\n\n                        else:\n                            #if a[-1]=='*':\n                            #   a.pop()\n                            #   a.append('POINTER')\n                            #a.append('=\\t\\t\\t\\t')\n                            a.append( char )\n\n                    else:\n                        a.append( char )\n                else:\n                    a.append( char )\n\n                if char.strip():\n                    prevchar = char\n\n\n            c = ''.join(a)\n            cs = c.strip()\n\n            if cs.startswith('//'):\n                continue\n            elif cs.startswith('inline(') or cs.startswith('JS('):\n                output.append(c)\n                continue\n\n\n            if cs.startswith('var '):\n                c = c.replace('var ', '')\n\n            if cs.startswith('let '):\n                mut = False\n                if cs.startswith('let mut '):\n                    c = c.replace('let mut ', '__let__(')\n                    mut = True\n                else:\n                    c = c.replace('let ', '__let__(')\n\n                if ':' in c:  ## `let x:T`\n                    ct = c[ c.index(':')+1 : ].strip()\n                    c  = c[ : c.index(':') ]\n                    cv = None\n                    if '=' in ct:\n                        ct, cv = ct.split('=')\n                        ct = ct.strip()\n                        cv = cv.strip()\n\n                    c += ',\n%s\n' %ct\n                    if cv:\n                        c += ',' + cv\n\n                if mut:\n                    c += ',mutable=True)'\n                else:\n                    c += ')'\n\n            ## this conflicts with inline javascript and lua,\n            ## TODO make the parser smarter, and skip quoted strings\n            #if '= function(' in c:\n            #   k = '= function('\n            #   a,b = c.split(k)\n            #   output.append( '@expression(%s)' %a.strip())\n            #   c = 'def __NAMELESS__(' + b\n\n            indent = []\n            for char in c:\n                if char in cls.__whitespace:\n                    indent.append( char )\n                else:\n                    break\n            indent = ''.join(indent)\n\n\n            if ' except ' in c and ':' in c:  ## PEP 463 - exception expressions\n                s = c.split(' except ')\n                if len(s) == 2 and '=' in s[0] and ':' in s[1]:\n                    s0 = s[0].strip()\n                    output.append('%stry: %s' %(indent, s0) )\n                    exception, default = s[1].split(':')\n                    output.append('%sexcept %s: %s=%s' %(indent, exception, s0.split('=')[0], default) )\n                    c = ''\n\n            if not allow_tabs_and_spaces:  ## TODO fixme, this is not safe now because we do not skip quoted text\n                indent = len(c) - len(c.lstrip())\n                if indent_unit == '' and indent:\n                    indent_unit = c[0]\n                elif c:\n                    if indent and c[0] != indent_unit:\n                        raise TabError('inconsistent use of tabs and spaces in indentation in line:', str(i+1) + '\\n'+ c)\n                    indent = indent_unit*indent\n\n            if ' def(' in c or ' def (' in c:\n                if ' def(' in c:\n                    a,b = c.split(' def(')\n                else:\n                    a,b = c.split(' def (')\n\n                if '=' in a:\n                    output.append( indent + '@expression(%s)' %a.split('=')[0])\n                    c = indent + 'def __NAMELESS__(' + b \n\n\n\n            if c.strip().startswith('def ') and '-\n' in c:  ## python3 syntax\n                c, rtype = c.split('-\n')\n                c += ':'\n                rtype = rtype.strip()[:-1].strip()\n                if rtype.endswith('*') or rtype.endswith('\n'):\n                    rtype = '\n%s\n' %rtype\n                elif rtype.startswith('[') or rtype.endswith('\n'):\n                    rtype = '\n%s\n' %rtype\n\n                if not strip:\n                    output.append( indent + '@returns(%s)' %rtype)\n\n            if c.startswith('import '):\n                if '-' in c:\n                    c = c.replace('-', '__DASH__')\n                if '/' in c:\n                    c = c.replace('/', '__SLASH__')\n                if '\n' in c:\n                    c = c.replace('\n', '')\n\n\n            if ' new ' in c:\n                c = c.replace(' new ', ' __new__\n')\n            if '\\tnew ' in c:\n                c = c.replace('\\tnew ', ' __new__\n')\n\n            ## return-block-lambda syntax, helper syntax for c++14 seastar ##\n            if c.strip().startswith('return ') and c.strip().endswith(':'):\n                c = c.replace('return ', 'with return_')\n\n            ## golang\n\n            if c.strip().startswith('switch '):\n                c = c.replace('switch ', 'with __switch__(').replace(':', '):')\n\n            if c.strip().startswith('default:'):\n                c = c.replace('default:', 'with __default__:')\n\n            if c.strip().startswith('select:'):\n                c = c.replace('select:', 'with __select__:')\n\n            if c.strip().startswith('case ') and c.strip().endswith(':'):\n                c = c.replace('case ', 'with __case__(').replace(':', '):')\n\n            if '\n-' in c:\n                if '=' in c and c.index('=') \n c.index('\n-'):\n                    c = c.replace('\n-', '__go__receive__\n')\n                else:\n                    ## keeping `=` allows for compatible transform to stacklessPython API,\n                    ## this is not used now because it is not required by the Go backend.\n                    c = c.replace('\n-', '= __go__send__\n')\n                    #c = c.replace('\n-', '\n__go__send__\n')\n\n\n            ## c++/libpython `-\n` gets translated to a CPython C-API call. \n            ## TODO: could also be specialized or other backends, or by user  `with syntax('-\n', USER_MACRO):` ##\n            if '-\n' in c:\n                #a,b = c.split('-\n')\n                #this_name = a.split()[-1].split('=')[-1].split(':')[-1].split(',')[-1]\n                #method_name = b.split()[0].split('(')[0]\n                #c = c.replace('-\n'+method_name, '.__right_arrow__\n'+method_name)\n\n                c = c.replace('-\n(', '.__right_arrow__(')\n                c = c.replace('-\n[', '.__right_arrow__[')\n                c = c.replace('-\n', '.__right_arrow__.')\n\n\n            ## python3 annotations\n            if 'def ' in c and c.count(':') \n 1:\n                #head, tail = c.split('(')\n                head = c[ : c.index('(') ]\n                tail = c[ c.index('(')+1 : ]\n                args = []\n                #tail, tailend = tail.split(')')\n                tailend = tail[ tail.rindex(')')+1 : ]\n                tail = tail[ : tail.rindex(')') ]\n\n\n                for x in tail.split(','):\n                    y = x\n                    if ':' in y:\n                        kw = None\n                        if '=' in y:\n                            y, kw = y.split('=')\n                        #arg, typedef = y.split(':')\n                        arg = y[ : y.index(':') ]\n                        typedef = y[ y.index(':')+1 : ]\n                        typedef = typedef.strip()\n\n                        chan = False\n                        T = False\n                        if len(typedef.strip().split()) \n= 2 and not typedef.startswith('func('):\n                            parts = typedef.strip().split()\n                            if 'chan' in parts:  ## go syntax\n                                chan = True\n                            else:                ## rust or c++ syntax\n                                T = ' '.join(parts[:-1])\n\n                            #typedef = typedef.strip().split()[-1]\n                            typedef = parts[-1]\n\n                        if '*' in arg:\n                            arg_name = arg.split('*')[-1]\n                        else:\n                            arg_name = arg\n\n                        if typedef.startswith('[]'):\n                            typedef = '__arg_array__(\n%s\n)' %typedef.strip()  ## this parses the go syntax and converts it for each backend\n                        elif typedef.startswith('['):\n                            typedef = '\n%s\n' %typedef.strip()\n\n                        elif typedef.startswith('map['):\n                            typedef = '__arg_map__(\n%s\n)' %typedef.strip()  ## this parses the go syntax and converts it for each backend\n\n                        elif typedef.endswith('*'):\n                            typedef = '\n%s\n' %typedef.strip()\n                        elif typedef.endswith('\n'):\n                            typedef = '\n%s\n' %typedef.strip()\n                        elif typedef.startswith('func('):\n                            typedef = '\n%s\n' %typedef.strip()\n                            if ' ' in typedef or '\\t' in typedef:\n                                ## TODO deprecate this old pipe-sep hack\n                                typedef = '|'.join(typedef.split())\n\n                        elif typedef.startswith('lambda('):\n                            typedef = '\n%s\n' %typedef.strip()\n                        elif '::' in typedef:\n                            typedef = '\n%s\n' %typedef.strip()\n                        elif '\n' in typedef and '\n' in typedef: ## rust and c++ template/generics syntax\n                            typedef = '\n%s\n' %typedef.strip()\n                        elif ':' in typedef and typedef.strip().startswith('[') and typedef.strip().endswith(']'): ## verilog [bit:index] syntax\n                            typedef = '\n%s\n' %typedef.strip()\n\n                        if not strip:\n                            if T:  ## rust or c++ syntax\n                                output.append('%s@__typedef__(%s, %s, \n%s\n)' %(indent, arg_name, typedef, T))\n                            elif chan:\n                                output.append('%s@typedef_chan(%s=%s)' %(indent, arg_name, typedef))\n                            else:\n                                output.append('%s@typedef(%s=%s)' %(indent, arg_name, typedef))\n\n                        if kw:\n                            arg += '=' + kw\n                        args.append(arg)\n                    else:\n                        args.append(x)\n                c = head +'(' + ','.join(args) + ')'+tailend  ## restores to python2 syntax\n\n            #elif '::' in c or ('\n' in c and '\n' in c and c.count('\n')==c.count('\n')):  ## c++ syntax `('std::bla\nT\n')(foo)`\n            #   ##  could auto quote here so `(std::\nT\n)` becomes `('std::\nT\n')\n            #   left = c.index('::')\n            #   while c[left]!='`':\n            #       left -= 1\n            #   if \n`\n in c:\n            #       c = c.replace(\n`\n, \n')\n)\n            #   elif c.endswith('`'):\n            #       c = c[:-1] + \n')\n\n            #   c = c[ :left-1 ] + \n inline('\n + c[left+1:]\n\n            #if '::' in c:\n            #   c = c.replace('::', '.__doublecolon__.')\n            #   ## this easily breaks - example: \nmyarray[ ::x]\n\n            #   ugly = '[.__doublecolon__.'\n            #   if ugly in c: c = c.replace(ugly, '[::')\n            #   ugly = '.__doublecolon__.]'\n            #   if ugly in c: c = c.replace(ugly, '::]')\n            #   for n in range(-9, 9):\n            #       nasty = '.__doublecolon__.%s]' %n\n            #       if nasty in c:\n            #           c = c.replace(nasty, '::%s]'%n)\n\n            if c.strip().startswith('with ') and ' as ' in c and c.endswith(':'):\n                x,y = c.split(' as ')\n                if \n'\n in y or '\n' in y:\n                    y = y[:-1] + '[MACRO]:'\n                    c = ' as '.join([x,y])\n            elif not c.startswith('except ') and ' as ' in c:\n                if (c.strip().startswith('return ') or '(' in c or ')' in c or '=' in c or c.strip().startswith('print')):\n                    c = c.replace(' as ', '\n__as__\n')\n                elif c.strip().startswith('for '):\n                    c = c.replace('for ', 'for (').replace(' in ', ') in ').replace(' as ', ',__as__,')\n\n\n            ## jquery ##\n            ## TODO ensure this is not inside quoted text\n            #if '$(' in c:\n            #   c = c.replace('$(', '__DOLLAR__(')\n            #if '$' in c and 'def ' in c:  ## $ as function parameter\n            #   c = c.replace('$', '__DOLLAR__')\n            #if '$.' in c:\n            #   c = c.replace('$.', '__DOLLAR__.')\n            if '$' in c:\n                c = c.replace('$', '__DOLLAR__')\n\n            if c.strip().startswith('nonlocal '):  ## Python3 syntax\n                c = c.replace('nonlocal ', 'global ')  ## fake nonlocal with global\n\n            if c.strip().startswith('with asm('):\n                asm_block = True\n\n            if strip and c.strip().startswith('with ('):\n                c = c.split('with (')[0] + 'if True:'\n\n            ## regular output\n            output.append( c )\n\n\n        parse_and_fix_code('\\n'.join(output), output)\n        return '\\n'.join(output)\n\n\ndef parse_and_fix_code(r, output):\n    try:\n        ast.parse(r)\n    except SyntaxError as e:\n        errmsg = str(e)\n        #print errmsg\n        eline = output[e.lineno-1]\n        echar = None\n        echar_prev = None\n        if e.offset is not None and e.offset \n len(eline):\n            echar = eline[ e.offset ]\n            echar_next = None\n            echar_prev = None\n            if e.offset+1 \n len(eline):\n                echar_next = eline[ e.offset+1 ]\n            if e.offset-1 \n 0:\n                echar_prev = eline[ e.offset-1 ]\n\n        #####################################\n        if errmsg.startswith('invalid syntax (\nunknown\n,') and '.finally(' in eline:\n            output[e.lineno-1] = eline.replace('.finally(', '.__finally__(')\n            parse_and_fix_code('\\n'.join(output), output)\n\n        elif errmsg.startswith('invalid syntax (\nunknown\n,') and 'then(' in eline:\n            if eline.strip().startswith('and then('):\n                output[e.lineno-1] = eline.replace('and then(', 'with chain_then(')\n                parse_and_fix_code('\\n'.join(output), output)\n\n            else:\n                nline = []\n                hit = False\n                for c in eline:\n                    if c.strip() and not hit:\n                        nline.append('with ')\n                        hit = True\n                    nline.append(c)\n                eline = ''.join(nline)\n                output[e.lineno-1] = eline\n                parse_and_fix_code('\\n'.join(output), output)\n\n        elif errmsg.startswith('invalid syntax') and echar_prev=='.':\n            if eline.count('..')==1:\n                output[e.lineno-1] = eline.replace('..', '.__doubledot__.')\n                parse_and_fix_code('\\n'.join(output), output)\n            else:\n                nline = list(eline)\n                nline[ e.offset-1: e.offset+1 ] = '.__doubledot__.'\n                output[e.lineno-1] = ''.join(nline)\n                parse_and_fix_code('\\n'.join(output), output)\n\n\n        elif errmsg.startswith('invalid syntax') and echar==':' and echar_prev==':':\n            if eline.count('::')==1:\n                output[e.lineno-1] = eline.replace('::', '.__doublecolon__.')\n                parse_and_fix_code('\\n'.join(output), output)\n            else:\n                nline = list(eline)\n                nline[ e.offset-1: e.offset+1 ] = '.__doublecolon__.'\n                output[e.lineno-1] = ''.join(nline)\n                parse_and_fix_code('\\n'.join(output), output)\n\n\n        elif errmsg.startswith('only named arguments may follow *expression'):\n            nline = []\n            infunc = False\n            hitptr = 0\n            for i,char in enumerate(eline):\n                if char=='(':\n                    infunc = True\n                elif infunc and char=='*':\n                    hitptr += 1\n                elif hitptr and (char==',' or char==')'):\n                    nline.append('[...]'*hitptr)\n                    hitptr = 0\n                elif hitptr and char==' ' and i\n0 and nline[i-1] != '*':\n                    nline.append('[...]'*hitptr)\n                    hitptr = 0\n\n                if char=='*' and hitptr:\n                    pass\n                else:\n                    nline.append(char)\n\n            if hitptr:\n                nline.append('[...]'*hitptr)\n\n            output[e.lineno-1] = ''.join(nline)\n            parse_and_fix_code('\\n'.join(output), output)\n\n        elif echar=='(' and '[' in eline and ']' in eline and '=' in eline:\n            varname = eline.strip().split()[0].split('=')[0]\n            eline = eline.replace('(', ',(').replace(varname, '__array__(%s,'%varname).replace('=','')\n            eline = eline.replace('[', '').replace(']', ',')\n            earr = list(eline)\n            earr.insert( eline.rindex(')'), ')' )\n            eline = ''.join(earr)\n            output[e.lineno-1] = eline\n            parse_and_fix_code('\\n'.join(output), output)\n        elif echar_prev=='s' and ' as ' in eline:\n            output[e.lineno-1] = eline.replace(' as ','\n__as__\n' )\n            parse_and_fix_code('\\n'.join(output), output)\n\n        else:\n            print '-'*80\n            print 'Syntax Error on this line:'\n            if eline.strip().startswith('def '):\n                funcname = eline.strip().split('(')[0].split('def ')[-1]\n                print 'SyntaxError in function definition: \n%s\n' % funcname\n                for i,eln in enumerate(r.splitlines()):\n                    if 'def '+funcname in eln:\n                        print 'line number: %s' %(i+1)\n                        print eln\n                        if 'func(' or 'lambda(' in eln:\n                            if ')(' in eline:\n                                print 'note: the syntax for typed callback functions is \nfunc(arg1 arg2)(return_type)\n'\n                                print 'the arguments are space separated, not comma separated.'\n                                print 'example: \nfunc(int int)()\n is a callback that takes two ints and returns nothing.'\n                                sys.exit(1)\n            else:\n                print eline\n            print '-'*80\n            print 'echar: ', echar\n            print 'echar-prev: ', echar_prev\n\n            raise e\n\n\n\n\n\nSimple Syntax Test\n\n\n\n__test_typedpython__ = u'''\n\nif True:\n    d = a[ 'somekey' ] except KeyError: 'mydefault'\n\n## \n- becomes __go__send__\na\ng \n- a\n## = \n- becomes __go__receive__\nb\ng = \n- b\n\ndef call_method( cb:func(int)(int) ) -\nint:\n    return cb(3)\n\ndef wrapper(a:int, c:chan int):\n    result = longCalculation(a)\n    c \n- result\n\nswitch a.f():\n    case 1:\n        print(x)\n    case 2:\n        print(y)\n    default:\n        break\n\nselect:\n    case x = \n- a:\n        y += x\n    case x = \n- b:\n        y += x\n\n\n\ndef f(a:int, b:int, c:int) -\nint:\n    return a+b+c\n\ndef f(a:int=100, b:int=100) -\nint:\n    return a+b\n\ndef f(*args:int, **kwargs:int) -\nint:\n    return a+b\n\na = []int(x for x in range(3))\n\ny = go.make([]float64, 1000)\n\ndef plot(id:string, latency:[]float64, xlabel:string, title:string ):\n    pass\n\ndef f( x:*ABC ) -\n *XXX:\n    pass\n\ndef listpass( a:[]int ):\n    pass\n\ndef mappass( a:map[string]int ):\n    return ConvertDataUnits[unit_type][unit][1][0]\n\nm = map[int]string{ a:'xxx' for a in range(10)}\n\n\nfunctions = map[string]func(int)(int){}\n[]int a = go( f() for f in funtions )\n\n## in go becomes: map[string]int{x,y,z}\n## becomes: __go__map__(string, int) \n {'x':x, 'y':y, 'z':z}\na = map[string]int{\n    \nx\n:x, \n    \ny\n:y, \n    \nz\n:z\n}\n\ndef f():\n    return [[0]]\nprint f()[0][0]\n\n## in go becomes: []string{x,y,z}\n## becomes: __go__array__(string) \n (x,y,z)\na = []string(x,y,z)\n\n## in go becomes: [3]int{x,y,z}\n## becomes: __go__arrayfixed__(3, string) \n (x,y,z)\na = [ 3 ]int(x,y,z)\n\n## Rust - DEPRECATED (replaced by minimacro with syntax)\n## f(inline('\nmut *x'))\n#f(\nmut *x)\n## f(inline('ref mut *x'), y.z())\n#f(@mut *x, y.z())\n\n\n## f(x \n __as__ \n uint)\nf(x as uint)\n\n## __let__[x :\n Vec\n(uint, Y\nint\n)\n \n]= range(0,1).map().collect()\nlet x : Vec\n(uint, Y\nint\n)\n = range(0,1).map().collect()\nlet i\ni = \n**x\n\ndef f(a:\nmut int) -\nint:\n    return a\n\ndef f():\n    with asm( outputs=b, inputs=a, volatile=True ):\n        movl %1, %%ebx;\n        movl %%ebx, %0;\n    return x\n\nlet mut x : int = 1\nlet x : int\ndef __init__():\n    let self.x : int = x\n    let mut self.y : int = y\n\n\ndef call_method( cb:lambda(int)(int) ) -\nint:\n    return cb(3)\n\nif self.__map[r][c] in (WALL,PERM_WALL): pass\n\n## allow func to be used as a function name, because it is pretty commom and allowed by most backends.\ndef func(x=None, callback=None):\n    func( callback=xxx )\n    x.func( xx=yy )\n\nlet mut x = 0\n\ndef templated( x : Type\nT\n ):\n    pass\ndef templated( x : namespace::Type\nT\n ):\n    pass\n\nc.x[0] = def(xx,yy) -\nint:\n    return xx+yy\n\nmdarray = [][]int()\ndef F() -\n[][]int:\n    pass\n\ndef f():\n    return A as B\n\nprint `std::chrono::duration_cast\nstd::chrono::microseconds\n`clock().count()\n\nwith (some, stuff):\n    pass\ndef f():\n    let x : map[string]int = {}\n\n'''\n\ndef test_typedpython():\n    out = typedpython.transform_source(__test_typedpython__)\n    print(out)\n    import ast\n    print( ast.parse(out) )", 
            "title": "PreProcessor"
        }, 
        {
            "location": "/typedpython/#simple-syntax-test", 
            "text": "__test_typedpython__ = u'''\n\nif True:\n    d = a[ 'somekey' ] except KeyError: 'mydefault'\n\n##  - becomes __go__send__ a\ng  - a\n## =  - becomes __go__receive__ b\ng =  - b\n\ndef call_method( cb:func(int)(int) ) - int:\n    return cb(3)\n\ndef wrapper(a:int, c:chan int):\n    result = longCalculation(a)\n    c  - result\n\nswitch a.f():\n    case 1:\n        print(x)\n    case 2:\n        print(y)\n    default:\n        break\n\nselect:\n    case x =  - a:\n        y += x\n    case x =  - b:\n        y += x\n\n\n\ndef f(a:int, b:int, c:int) - int:\n    return a+b+c\n\ndef f(a:int=100, b:int=100) - int:\n    return a+b\n\ndef f(*args:int, **kwargs:int) - int:\n    return a+b\n\na = []int(x for x in range(3))\n\ny = go.make([]float64, 1000)\n\ndef plot(id:string, latency:[]float64, xlabel:string, title:string ):\n    pass\n\ndef f( x:*ABC ) -  *XXX:\n    pass\n\ndef listpass( a:[]int ):\n    pass\n\ndef mappass( a:map[string]int ):\n    return ConvertDataUnits[unit_type][unit][1][0]\n\nm = map[int]string{ a:'xxx' for a in range(10)}\n\n\nfunctions = map[string]func(int)(int){}\n[]int a = go( f() for f in funtions )\n\n## in go becomes: map[string]int{x,y,z}\n## becomes: __go__map__(string, int)   {'x':x, 'y':y, 'z':z}\na = map[string]int{\n     x :x, \n     y :y, \n     z :z\n}\n\ndef f():\n    return [[0]]\nprint f()[0][0]\n\n## in go becomes: []string{x,y,z}\n## becomes: __go__array__(string)   (x,y,z)\na = []string(x,y,z)\n\n## in go becomes: [3]int{x,y,z}\n## becomes: __go__arrayfixed__(3, string)   (x,y,z)\na = [ 3 ]int(x,y,z)\n\n## Rust - DEPRECATED (replaced by minimacro with syntax)\n## f(inline(' mut *x'))\n#f( mut *x)\n## f(inline('ref mut *x'), y.z())\n#f(@mut *x, y.z())\n\n\n## f(x   __as__   uint)\nf(x as uint)\n\n## __let__[x :  Vec (uint, Y int )   ]= range(0,1).map().collect()\nlet x : Vec (uint, Y int )  = range(0,1).map().collect()\nlet i\ni =  **x\n\ndef f(a: mut int) - int:\n    return a\n\ndef f():\n    with asm( outputs=b, inputs=a, volatile=True ):\n        movl %1, %%ebx;\n        movl %%ebx, %0;\n    return x\n\nlet mut x : int = 1\nlet x : int\ndef __init__():\n    let self.x : int = x\n    let mut self.y : int = y\n\n\ndef call_method( cb:lambda(int)(int) ) - int:\n    return cb(3)\n\nif self.__map[r][c] in (WALL,PERM_WALL): pass\n\n## allow func to be used as a function name, because it is pretty commom and allowed by most backends.\ndef func(x=None, callback=None):\n    func( callback=xxx )\n    x.func( xx=yy )\n\nlet mut x = 0\n\ndef templated( x : Type T  ):\n    pass\ndef templated( x : namespace::Type T  ):\n    pass\n\nc.x[0] = def(xx,yy) - int:\n    return xx+yy\n\nmdarray = [][]int()\ndef F() - [][]int:\n    pass\n\ndef f():\n    return A as B\n\nprint `std::chrono::duration_cast std::chrono::microseconds `clock().count()\n\nwith (some, stuff):\n    pass\ndef f():\n    let x : map[string]int = {}\n\n'''\n\ndef test_typedpython():\n    out = typedpython.transform_source(__test_typedpython__)\n    print(out)\n    import ast\n    print( ast.parse(out) )", 
            "title": "Simple Syntax Test"
        }, 
        {
            "location": "/intermediateform/", 
            "text": "Python to Intermediate Form\n\n\nby Amirouche Boubekki and Brett Hartshorn - copyright 2013\nLicense: \"New BSD\"\n\n\n\n\n@import fakestdlib.md\n\n\n\n\n\n\nimport os, sys, copy\nfrom types import GeneratorType\n\nimport ast\nfrom ast import Str\nfrom ast import Call\nfrom ast import Name\nfrom ast import Tuple\nfrom ast import Assign\nfrom ast import keyword\nfrom ast import Subscript\nfrom ast import Attribute\nfrom ast import FunctionDef\nfrom ast import BinOp\nfrom ast import Pass\nfrom ast import Global\nfrom ast import With\n\nfrom ast import parse\nfrom ast import NodeVisitor\n\n\n\nPOWER_OF_TWO = [ 2**i for i in range(32) ]\n\nwriter = writer_main = CodeWriter()\n\n__webworker_writers = dict()\ndef get_webworker_writer( jsfile ):\n    if jsfile not in __webworker_writers:\n        __webworker_writers[ jsfile ] = CodeWriter()\n    return __webworker_writers[ jsfile ]\n\n\n\nclass Typedef(object):\n    # http://docs.python.org/2/reference/datamodel.html#emulating-numeric-types\n    _opmap = dict(\n        __add__ = '+',\n        __iadd__ = '+=',\n        __sub__ = '-',\n        __isub__ = '-=',\n        __mul__ = '*',\n        __imul__ = '*=',\n        __div__ = '/',\n        __idiv__ = '/=',\n        __mod__ = '%',\n        __imod__ = '%=',\n        __lshift__ = '\n',\n        __ilshift__ = '\n=',\n        __rshift__ = '\n',\n        __irshift__ = '\n=',\n        __and__ = '\n',\n        __iand__ = '\n=',\n        __xor__ = '^',\n        __ixor__ = '^=',\n        __or__ = '|',\n        __ior__ = '|=',\n    )\n\n    def __init__(self, **kwargs):\n        for name in kwargs.keys():  ## name, methods, properties, attributes, class_attributes, parents\n            setattr( self, name, kwargs[name] )\n\n        self.operators = dict()\n        for name in self.methods:\n            if name in self._opmap:\n                op = self._opmap[ name ]\n                self.operators[ op ] = self.get_pythonjs_function_name( name )\n\n    def get_pythonjs_function_name(self, name):\n        assert name in self.methods\n        return '__%s_%s' %(self.name, name) ## class name\n\n    def check_for_parent_with(self, method=None, property=None, operator=None, class_attribute=None):\n\n        for parent_name in self.parents:\n            if not self.compiler.is_known_class_name( parent_name ):\n                continue\n\n            typedef = self.compiler.get_typedef( class_name=parent_name )\n            if method and method in typedef.methods:\n                return typedef\n            elif property and property in typedef.properties:\n                return typedef\n            elif operator and typedef.operators:\n                return typedef\n            elif class_attribute in typedef.class_attributes:\n                return typedef\n            elif typedef.parents:\n                res = typedef.check_for_parent_with(\n                    method=method, \n                    property=property, \n                    operator=operator,\n                    class_attribute=class_attribute\n                )\n                if res:\n                    return res\n\n\n\n\nclass PythonToPythonJS(NodeVisitorBase):\n\n    identifier = 0  ## clean up\n    _func_typedefs = ()  ## TODO clean up\n\n    def __init__(self, source=None, modules=False, module_path=None, dart=False, coffee=False, go=False, rust=False, cpp=False, fast_javascript=False, pure_javascript=False):\n        #super(PythonToPythonJS, self).__init__()\n        NodeVisitorBase.__init__(self, source)  ## note self._source gets changed below\n\n        ## lowlevel is code within a `with lowlevel:` block\n        ## this is used to define some builtin methods for each backend,\n        ## where the user wants the most direct translation possible to\n        ## the target backend.  This is only for special cases.\n        self._with_ll = False   ## lowlevel\n\n        self._modules = modules          ## split into mutiple files by class\n        self._module_path = module_path  ## used for user `from xxx import *` to load .py files in the same directory.\n        self._with_coffee = coffee\n        self._with_dart = dart\n        self._with_go = go\n        self._with_gojs = False\n        self._with_rust = rust\n        self._with_cpp = cpp\n        self._fast_js = fast_javascript\n        self._strict_mode = pure_javascript\n\n        ## TODO _with_js should be renamed to _with_restricted_python, or _with_rpy.\n        ## originally this option was only used to switch modes from the original\n        ## full python mode to the faster more restricted python mode.\n        ## The older full python mode requires a backend that is very dynamic, like: javascript or lua\n        ## full python mode maps all calls through a generic `__get__` method that takes care of all\n        ## dynamic mapping at runtime, this basically emulates what CPython is doing in C in a slower VM.\n        ## full python mode also breaks down classes into flat function calls, for backends that do not\n        ## directly support classes like Lua and JavaScript.\n        ## The JavaScript backend now defaults to restricted python mode, because it is much faster,\n        ## and classes are now translated to JavaScript prototypes and constructed by calling new,\n        ## this also provides much better interop with external JS libraries.\n        ## Since restricted python mode became default the new backends: rust and c++ now require that mode,\n        ## and it makes the last stage of translation simpler and more generic.\n        ## However, the Lua backend still requires the old style full python mode, because in Lua classes\n        ## must be fully broken down into flat functions.\n        self._with_js = True\n\n\n        if self._with_rust or self._with_go:\n            self._use_destructured_assignment = True\n        else:\n            self._use_destructured_assignment = False\n\n        self._html_tail = []; script = False\n        if source.strip().startswith('\nhtml'):\n            lines = source.splitlines()\n            for line in lines:\n                if line.strip().startswith('\nscript'):\n                    if 'type=\ntext/python\n' in line:\n                        writer.write( '\nscript type=\ntext/python\n')\n                        script = list()\n                    elif 'src=' in line and '~/' in line:  ## external javascripts installed in users home folder\n                        x = line.split('src=\n')[-1].split('\n')[0]\n                        if os.path.isfile(os.path.expanduser(x)):\n                            o = []\n                            o.append( '\nscript type=\ntext/javascript\n' )\n                            if x.lower().endswith('.coffee'):\n                                import subprocess\n                                proc = subprocess.Popen(\n                                    ['coffee','--bare', '--print', os.path.expanduser(x)], \n                                    stdout=subprocess.PIPE\n                                )\n                                o.append( proc.stdout.read() )\n                            else:\n                                o.append( open(os.path.expanduser(x), 'rb').read() )\n                            o.append( '\n/script\n')\n                            if script is True:\n                                self._html_tail.extend( o )\n                            else:\n                                for y in o:\n                                    writer.write(y)\n\n                    else:\n                        writer.write(line)\n\n                elif line.strip() == '\n/script\n':\n                    if type(script) is list and len(script):\n                        source = '\\n'.join(script)\n                        script = True\n                        self._html_tail.append( '\n/script\n')\n                    else:\n                        writer.write( line )\n\n                elif isinstance( script, list ):\n                    script.append( line )\n\n                elif script is True:\n                    self._html_tail.append( line )\n\n                else:\n                    writer.write( line )\n\n        ## preprocess the input source that may contain extended syntax\n        ## that the python AST parser can not deal with.\n        ## note: `transform_source` translates into an intermediate form\n        ## that is python AST compatible.\n        source = typedpython.transform_source( source )\n\n\n        ## optimize \n+\n and \n*\n operator, for python syntax like 'a'*3 becomes 'aaa'\n        if fast_javascript:\n            self._direct_operators = set( ['+', '*'] )\n        else:\n            self._direct_operators = set()\n\n        self._in_catch_exception = False\n        self._in_lambda = False\n        self._in_while_test = False\n        self._use_threading = False\n        self._use_sleep = False  ## only for the js backend, makes while loops `sleep` using setTimeOut\n        self._use_array = False\n        self._webworker_functions = dict()\n        self._webworker_imports = list()\n        self._with_webworker = False\n        self._with_rpc = None\n        self._with_rpc_name = None\n        self._with_direct_keys = fast_javascript\n\n        self._with_glsl = False  ## TODO dep\n\n        self._source = source.splitlines()\n        self._class_stack = list()\n        self._classes = dict()    ## class name : [method names]\n        self._class_parents = dict()  ## class name : parents\n        self._instance_attributes = dict()  ## class name : [attribute names]\n        self._class_attributes = dict()\n        self._catch_attributes = None\n        self._typedef_vars = dict()\n\n        #self._names = set() ## not used?\n        ## inferred class instances, TODO regtests to confirm that this never breaks ##\n        self._instances = dict()  ## instance name : class name\n\n        self._decorator_properties = dict()\n        self._decorator_class_props = dict()\n        self._function_return_types = dict()\n        self._return_type = None\n\n\n        self._typedefs = dict()  ## class name : typedef  (deprecated - part of the old static type finder)\n\n        self._globals = dict()\n        self._global_nodes = dict()\n        self._with_static_type = None\n        self._global_typed_lists = dict()  ## global name : set  (if len(set)==1 then we know it is a typed list)\n        self._global_typed_dicts = dict()\n        self._global_typed_tuples = dict()\n        self._global_functions = dict()\n        self._autotyped_dicts  = dict()\n\n        self._js_classes = dict()\n        self._in_js_class = False\n        self._in_assign_target = False\n        self._with_runtime_exceptions = True  ## this is only used in full python mode.\n\n        self._iter_ids = 0\n        self._addop_ids = 0\n\n        self._cache_while_body_calls = False\n        self._comprehensions = []\n        self._generator_functions = set()\n\n        self._in_loop_with_else = False\n        self._introspective_functions = False\n\n        self._custom_operators = {}\n        self._injector = []  ## advanced meta-programming hacks\n        self._in_class = None\n        self._with_fastdef = False\n        self.setup_builtins()\n\n        source = self.preprocess_custom_operators( source )\n        tree = ast.parse( source )\n\n        self._generator_function_nodes = collect_generator_functions( tree )\n\n        for node in tree.body:\n            ## skip module level doc strings ##\n            if isinstance(node, ast.Expr) and isinstance(node.value, ast.Str):\n                pass\n            else:\n                self.visit(node)\n\n        if self._html_tail:\n            for line in self._html_tail:\n                writer.write(line)\n\n    def get_webworker_imports(self):\n        return self._webworker_imports\n\n    def has_webworkers(self):\n        return len(self._webworker_functions.keys())\n\n    def get_webworker_file_names(self):\n        return set(self._webworker_functions.values())\n\n    def preprocess_custom_operators(self, data):\n        '''\n        custom operators must be defined before they are used\n        '''\n        code = []\n        for line in data.splitlines():\n            if line.strip().startswith('@custom_operator'):\n                l = line.replace('\n', \n'\n)\n                a,b,c = l.split(\n'\n)\n                op = b.decode('utf-8')\n                self._custom_operators[ op ] = None\n            else:\n                for op in self._custom_operators:\n                    op = op.encode('utf-8')\n                    line = line.replace(op, '|\n%s\n|'%op)\n\n            code.append( line )\n\n        data = '\\n'.join( code )\n        return data\n\n    def setup_builtins(self):\n        self._classes['dict'] = set(['__getitem__', '__setitem__'])\n        self._classes['list'] = set() #['__getitem__', '__setitem__'])\n        self._classes['tuple'] = set() #['__getitem__', '__setitem__'])\n        self._builtin_classes = set(['dict', 'list', 'tuple'])\n        self._builtin_functions = {\n            'ord':'%s.charCodeAt(0)',\n            'chr':'String.fromCharCode(%s)',\n            'abs':'Math.abs(%s)',\n            'cos':'Math.cos(%s)',\n            'sin':'Math.sin(%s)',\n            'sqrt':'Math.sqrt(%s)'\n        }\n        self._builtin_functions_dart = {\n            'ord':'%s.codeUnitAt(0)',\n            'chr':'new(String.fromCharCode(%s))',\n        }\n\n    def is_known_class_name(self, name):\n        return name in self._classes\n\n    def get_typedef(self, instance=None, class_name=None):\n        assert instance or class_name\n        if isinstance(instance, Name) and instance.id in self._instances:\n            class_name = self._instances[ instance.id ]\n\n        if class_name:\n            #assert class_name in self._classes\n            if class_name not in self._classes:\n                #raise RuntimeError('class name: %s - not found in self._classes - node:%s '%(class_name, instance))\n                return None  ## TODO hook into self._typedef_vars\n\n            if class_name not in self._typedefs:\n                self._typedefs[ class_name ] = Typedef(\n                    name = class_name,\n                    methods = self._classes[ class_name ],\n                    #properties = self._decorator_class_props[ class_name ],\n                    #attributes = self._instance_attributes[ class_name ],\n                    #class_attributes = self._class_attributes[ class_name ],\n                    #parents = self._class_parents[ class_name ],\n                    properties = self._decorator_class_props.get(  class_name, set()),\n                    attributes = self._instance_attributes.get(    class_name, set()),\n                    class_attributes = self._class_attributes.get( class_name, set()),\n                    parents = self._class_parents.get(             class_name, set()),\n\n                    compiler = self,\n                )\n            return self._typedefs[ class_name ]\n\n    def visit_Delete(self, node):\n        writer.write('del %s' %','.join([self.visit(t) for t in node.targets]))\n\n    def visit_Import(self, node):\n        '''\n        fallback to requirejs or if in webworker importScripts.\n        some special modules from pythons stdlib can be faked here like:\n            . threading\n\n        nodejs only:\n            . tornado\n            . os\n\n        '''\n\n        tornado = ['tornado', 'tornado.web', 'tornado.ioloop']\n\n        for alias in node.names:\n            if self._with_go or self._with_rust or self._with_cpp:\n                if alias.asname:\n                    writer.write('import %s as %s' %(alias.name, alias.asname))\n                else:\n                    writer.write('import %s' %alias.name)\n            elif self._with_webworker:\n                self._webworker_imports.append( alias.name )\n            elif alias.name in tornado:\n                pass  ## pythonjs/fakelibs/tornado.py\n            elif alias.name == 'tempfile':\n                pass  ## pythonjs/fakelibs/tempfile.py\n            elif alias.name == 'sys':\n                pass  ## pythonjs/fakelibs/sys.py\n            elif alias.name == 'subprocess':\n                pass  ## pythonjs/fakelibs/subprocess.py\n            elif alias.name == 'numpy':\n                pass\n\n            elif alias.name == 'json' or alias.name == 'os':\n                pass  ## part of builtins.py\n            elif alias.name == 'threading':\n                self._use_threading = True\n                #writer.write( 'Worker = require(\n/usr/local/lib/node_modules/workerjs\n)')\n\n                ## note: nodewebkit includes Worker, but only from the main script context,\n                ## there might be a bug in requirejs or nodewebkit where Worker gets lost\n                ## when code is loaded into main as a module using requirejs, as a workaround\n                ## allow \nworkerjs\n to be loaded as a fallback, however this appears to not work in nodewebkit.\n                writer.write( 'if __NODEJS__==True and typeof(Worker)==\nundefined\n: Worker = require(\nworkerjs\n)')\n\n            #elif alias.asname:\n            #   #writer.write( '''inline(\nvar %s = requirejs('%s')\n)''' %(alias.asname, alias.name) )\n            #   writer.write( '''inline(\nvar %s = require('%s')\n)''' %(alias.asname, alias.name.replace('__DASH__', '-')) )\n            #elif '.' in alias.name:\n            #   raise NotImplementedError('import with dot not yet supported: line %s' % node.lineno)\n            #else:\n            #   #writer.write( '''inline(\nvar %s = requirejs('%s')\n)''' %(alias.name, alias.name) )\n            #   writer.write( '''inline(\nvar %s = require('%s')\n)''' %(alias.name, alias.name) )\n\n            elif alias.asname:\n                writer.write('import %s as %s' %(alias.name, alias.asname))\n            else:\n                writer.write('import %s' %alias.name)\n\n\n    def visit_ImportFrom(self, node):\n        if self._with_go:\n            lib = fakestdlib.GO\n        elif self._with_cpp:\n            lib = fakestdlib.CPP\n        elif self._with_rust:\n            lib = {}\n        else:\n            lib = fakestdlib.JS\n\n        if self._module_path:\n            path = os.path.join( self._module_path, node.module+'.py')\n        else:\n            path = os.path.join( './', node.module+'.py')\n\n        if node.module == 'time' and node.names[0].name == 'sleep':\n            if not (self._with_cpp or self._with_rust or self._with_go or self._with_ll):\n                self._use_sleep = True\n\n        ############################################################\n        if node.module == 'array' and node.names[0].name == 'array':\n            self._use_array = True ## this is just a hint that calls to array call the builtin array\n\n        elif node.module == 'bisect' and node.names[0].name == 'bisect':\n            ## bisect library is part of the stdlib,\n            ## in pythonjs it is a builtin function defined in builtins.py\n            pass\n        elif node.module == '__future__':\n            pass\n\n        elif node.module in lib:\n            imported = False\n            for n in node.names:\n                if n.name in lib[ node.module ]:\n                    if not imported:\n                        imported = True\n                        if fakestdlib.REQUIRES in lib[node.module]:\n                            writer.write('import %s' %','.join(lib[node.module][fakestdlib.REQUIRES]))\n\n                    writer.write( 'inline(\n%s\n)' %lib[node.module][n.name] )\n                    if n.name not in self._builtin_functions:\n                        self._builtin_functions[ n.name ] = n.name + '()'\n\n        elif os.path.isfile(path):\n            ## user import `from mymodule import *` TODO support files from other folders\n            ## this creates a sub-translator, because they share the same `writer` object (a global),\n            ## there is no need to call `writer.write` here.\n            ## note: the current pythonjs.configure mode here maybe different from the subcontext.\n            data = open(path, 'rb').read()\n            subtrans = PythonToPythonJS(\n                data,\n                module_path     = self._module_path,\n                fast_javascript = self._fast_js,\n                modules         = self._modules,\n                pure_javascript = self._strict_mode,\n            )\n            self._js_classes.update( subtrans._js_classes ) ## TODO - what other typedef info needs to be copied here?\n\n        elif self._with_rust:  ## allow `import xx` to be translated to `extern crate xx`\n            writer.write('from %s import %s' %(node.module, ','.join([n.name for n in node.names])))\n        elif node.module == 'runtime':\n            writer.write('from runtime import *')\n        elif node.module == 'nodejs':\n            writer.write('from nodejs import *')\n        elif node.module == 'nodejs.tornado':\n            writer.write('from nodejs.tornado import *')\n        elif self._with_js:\n            inames = [n.name for n in node.names]\n            writer.write('from %s import %s' %(node.module, ','.join(inames)))\n        else:\n            msg = 'invalid import - file not found: %s'%path\n            raise SyntaxError( self.format_error(msg) )\n\n    def visit_Assert(self, node):\n        writer.write('assert %s' %self.visit(node.test))\n\n    def visit_Set(self, node):  ## new python3 style `a={1,2,3}`\n        return '{%s}' %','.join([self.visit(elt) for elt in node.elts])\n\n    def visit_Dict(self, node):\n        node.returns_type = 'dict'\n        keytype = None\n        a = []\n        alt = []\n        for i in range( len(node.keys) ):\n            if isinstance(node.keys[i], ast.Num):\n                if type(node.keys[i].n) is int:\n                    if keytype is None:\n                        keytype = 'int'\n                    elif keytype != 'int':\n                        raise SyntaxError(self.format_error('dictionary can not have mixed string and number keys'))\n            elif isinstance(node.keys[i], ast.Str):\n                if keytype is None:\n                    keytype = 'string'\n                elif keytype != 'string':\n                    raise SyntaxError(self.format_error('dictionary can not have mixed string and number keys'))\n\n\n            k = self.visit( node.keys[ i ] )\n            v = node.values[i]\n\n\n            if isinstance(v, ast.Lambda):\n                v.keep_as_lambda = True\n            v = self.visit( v )\n            if self._with_ll or self._with_go or self._with_rust or self._with_cpp:\n                a.append( '%s:%s'%(k,v) )\n            elif self._fast_js:\n                if not isinstance(node.keys[i], ast.Name):\n                    if isinstance(node.keys[i], ast.List):\n                        if len(node.keys[i].elts) != 1:\n                            raise SyntaxError(\n                                self.format_error('JavaScript ES6 Error: computed property name, `[]` wrapper not of length one.')\n                            )\n                        k = self.visit(node.keys[i].elts[0])\n                    alt.append( '[%s, %s]' %(k,v) )\n                else:\n                    a.append( '%s:%s'%(k,v) )\n            elif self._with_js:\n                ## TODO remove this\n                a.append( '[%s,%s]'%(k,v) )\n            else:\n                raise RuntimeError( self.format_error('invalid backend') )\n\n\n        if self._with_ll or self._with_go or self._with_rust or self._with_cpp:\n            b = ','.join( a )\n            return '{%s}' %b\n        elif self._fast_js:\n            b = ','.join( a )\n            opts = '{copy:False,'\n            if keytype is not None:\n                opts += 'keytype:\n%s\n,' %keytype\n            if len(alt):\n                opts += 'iterable:[%s]' %','.join(alt)\n            opts += '}'\n            return 'dict({%s}, %s )' %(b, opts)\n\n        elif self._with_js:  ## DEPRECATED - note: this allowed for python style dict literals\n            b = ','.join( a )\n            return '__jsdict( [%s] )' %b\n        else:\n            raise RuntimeError('dict - unknown backend')\n\n    def visit_Tuple(self, node):\n        node.returns_type = 'tuple'\n        #a = '[%s]' % ', '.join(map(self.visit, node.elts))\n        a = []\n        for e in node.elts:\n            if isinstance(e, ast.Lambda):\n                e.keep_as_lambda = True\n            v = self.visit(e)\n            assert v is not None\n            a.append( v )\n\n        if self._with_rust or self._with_cpp:\n            if len(a)==1:\n                return '(%s,)' % a[0]\n            else:\n                return '(%s)' % ', '.join(a)\n        else:\n            return '[%s]' % ', '.join(a)\n\n    def visit_List(self, node):\n        node.returns_type = 'list'\n\n        a = []\n        for e in node.elts:\n            if isinstance(e, ast.Lambda):  ## inlined and called lambda \n(lambda x: x)(y)\n\n                e.keep_as_lambda = True\n            v = self.visit(e)\n            assert v is not None\n            a.append( v )\n\n        return '[%s]' % ', '.join(a)\n\n    def visit_GeneratorExp(self, node):\n        return self.visit_ListComp(node)\n\n    _comp_id = 0\n\n    def visit_DictComp(self, node):\n        '''\n        node.key is key name\n        node.value is value\n        '''\n        #raise SyntaxError(self.visit(node.key))  ## key, value, generators\n\n        node.returns_type = 'dict'\n\n        if len(self._comprehensions) == 0:\n            comps = collect_dict_comprehensions( node )\n            for i,cnode in enumerate(comps):\n                cname = '__comp__%s' % self._comp_id\n                cnode._comp_name = cname\n                self._comprehensions.append( cnode )\n                self._comp_id += 1\n\n\n        cname = node._comp_name\n        writer.write('var(%s)'%cname)\n\n        length = len( node.generators )\n        a = ['idx%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['iter%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['get%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n\n        if self._with_go:\n            assert node.go_dictcomp_type\n            k,v = node.go_dictcomp_type\n            writer.write('%s = __go__map__(%s, %s)\n{}' %(cname, k,v))\n        else:\n            writer.write('%s = {}'%cname)\n\n        generators = list( node.generators )\n        generators.reverse()\n        self._gen_comp( generators, node )\n\n        self._comprehensions.remove( node )\n        return cname\n\n\n    def visit_ListComp(self, node):\n        node.returns_type = 'list'\n        if self._with_rust or self._with_cpp:\n            ## pass directly to next translation stage\n            gen = node.generators[0]\n            a = self.visit(node.elt)\n            b = self.visit(gen.target)\n            c = self.visit(gen.iter)\n            return '[%s for %s in %s]' %(a,b,c)\n        else:\n            compname = self._visit_listcomp_helper(node)\n            return compname\n\n    def _visit_listcomp_helper(self, node):\n        ## TODO - move this logic to the next translation stage for each backend.\n        ## TODO - check if there was a bug here, why only when self._comprehensions is zero?\n        #if len(self._comprehensions) == 0 or True:\n        comps = collect_comprehensions( node )\n        assert comps\n        for i,cnode in enumerate(comps):\n            cname = '__comp__%s' % self._comp_id\n            cnode._comp_name = cname\n            self._comprehensions.append( cnode )\n            self._comp_id += 1\n\n        cname = node._comp_name\n        writer.write('var(%s)'%cname)\n        #writer.write('var(__comp__%s)'%self._comp_id)\n\n        length = len( node.generators ) + (len(self._comprehensions)-1)\n        a = ['idx%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['iter%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['get%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n\n        if self._with_go:\n            assert node.go_listcomp_type\n            #writer.write('__comp__%s = __go__array__(%s)' %(self._comp_id, node.go_listcomp_type))\n            writer.write('%s = __go__array__(%s)' %(cname, node.go_listcomp_type))\n        else:\n            writer.write('%s = JSArray()'%cname)\n\n        generators = list( node.generators )\n        generators.reverse()\n        self._gen_comp( generators, node )\n\n        #if node in self._comprehensions:\n        #   self._comprehensions.remove( node )\n\n        if self._with_go:\n            #return '__go__addr__(__comp__%s)' %self._comp_id\n            return '__go__addr__(%s)' %cname\n        else:\n            #return '__comp__%s' %self._comp_id\n            return cname\n\n\n    def _gen_comp(self, generators, node):\n        #self._comp_id += 1\n        #id = self._comp_id\n\n        gen = generators.pop()\n        id = len(generators) + self._comprehensions.index( node )\n        assert isinstance(gen.target, Name)\n        writer.write('idx%s = 0'%id)\n\n        is_range = False\n        if isinstance(gen.iter, ast.Call) and isinstance(gen.iter.func, ast.Name) and gen.iter.func.id in ('range', 'xrange'):\n            is_range = True\n\n            writer.write('iter%s = %s' %(id, self.visit(gen.iter.args[0])) )\n            writer.write('while idx%s \n iter%s:' %(id,id) )\n            writer.push()\n\n            writer.write('var(%s)'%gen.target.id)\n            writer.write('%s=idx%s' %(gen.target.id, id) )\n\n        elif self._with_js:  ## only works with arrays in javascript mode\n            writer.write('iter%s = %s' %(id, self.visit(gen.iter)) )\n            writer.write('while idx%s \n iter%s.length:' %(id,id) )\n            writer.push()\n            writer.write('var(%s)'%gen.target.id)\n            writer.write('%s=iter%s[idx%s]' %(gen.target.id, id,id) )\n\n        else:\n            raise SyntaxError('deprecated - lua backend')\n\n        if generators:\n            self._gen_comp( generators, node )\n        else:\n            cname = node._comp_name #self._comprehensions[-1]\n            #cname = '__comp__%s' % self._comp_id\n\n            if len(gen.ifs):\n                test = []\n                for compare in gen.ifs:\n                    test.append( self.visit(compare) )\n\n                writer.write('if %s:' %' and '.join(test))\n                writer.push()\n                self._gen_comp_helper(cname, node)\n                writer.pull()\n\n            else:\n                self._gen_comp_helper(cname, node)\n\n        writer.write('idx%s+=1' %id )\n        writer.pull()\n\n    def _gen_comp_helper(self, cname, node):\n        if isinstance(node, ast.DictComp):\n            key = self.visit(node.key)\n            val = self.visit(node.value)\n            if self._with_go:\n                writer.write('%s[ %s ] = %s' %(cname, key, val) )\n            else:\n                writer.write('%s[ %s ] = %s' %(cname, key, val) )\n\n        elif self._with_go:\n            writer.write('%s = append(%s, %s )' %(cname, cname,self.visit(node.elt)) )\n        else:\n            writer.write('%s.push( %s )' %(cname,self.visit(node.elt)) )\n\n    def visit_In(self, node):\n        return ' in '\n\n    def visit_NotIn(self, node):\n        #return ' not in '\n        raise RuntimeError('\nnot in\n is only allowed in if-test: see method - visit_Compare')\n\n    ## TODO check if the default visit_Compare always works ##\n    #def visit_Compare(self, node):\n    #   raise NotImplementedError( node )\n\n\n    def visit_AugAssign(self, node):\n        self._in_assign_target = True\n        target = self.visit( node.target )\n        self._in_assign_target = False\n\n        op = '%s=' %self.visit( node.op )\n\n        if op == '//=':\n            if isinstance(node.target, ast.Attribute):\n                name = self.visit(node.target.value)\n                attr = node.target.attr\n                target = '%s.%s' %(name, attr)\n\n            if self._with_go:\n                a = '%s /= %s' %(target, self.visit(node.value))\n            elif self._with_cpp:\n                a = '%s /= %s' %(target, self.visit(node.value))\n            else:\n                a = '%s = Math.floor(%s/%s)' %(target, target, self.visit(node.value))\n            writer.write(a)\n\n\n        elif self._with_js:  ## no operator overloading in with-js mode\n            a = '%s %s %s' %(target, op, self.visit(node.value))\n            writer.write(a)\n\n        elif isinstance(node.target, ast.Attribute):\n            name = self.visit(node.target.value)\n            attr = node.target.attr\n            a = '%s.%s %s %s' %(name, attr, op, self.visit(node.value))\n            writer.write(a)\n\n        elif isinstance(node.target, ast.Subscript):\n            name = self.visit(node.target.value)\n            slice = self.visit(node.target.slice)\n            #if self._with_js:\n            #   a = '%s[ %s ] %s %s'\n            #   writer.write(a %(name, slice, op, self.visit(node.value)))\n            #else:\n            op = self.visit(node.op)\n            value = self.visit(node.value)\n            #a = '__get__(%s, \n__setitem__\n)( [%s, __get__(%s, \n__getitem__\n)([%s], {}) %s (%s)], {} )'\n            fallback = '__get__(%s, \n__setitem__\n)( [%s, __get__(%s, \n__getitem__\n)([%s], {}) %s (%s)], {} )'%(name, slice, name, slice, op, value)\n            if isinstance(node.target.value, ast.Name):\n                ## TODO also check for arr.remote (RPC) if defined then __setitem__ can not be bypassed\n\n                ## the overhead of checking if target is an array,\n                ## and calling __setitem__ directly bypassing a single __get__,\n                ## is greather than simply calling the fallback\n                #writer.write('if instanceof(%s, Array): %s.__setitem__([%s, %s[%s] %s (%s) ], __NULL_OBJECT__)' %(name, name, slice, name,slice, op, value))\n\n                writer.write('if instanceof(%s, Array): %s[%s] %s= %s' %(name, name,slice, op, value))\n                writer.write('else: %s' %fallback)\n            else:\n                writer.write(fallback)\n\n        else:\n            ## TODO extra checks to make sure the operator type is valid in this context\n            a = '%s %s %s' %(target, op, self.visit(node.value))\n            writer.write(a)\n\n    def visit_Yield(self, node):\n        return 'yield %s' % self.visit(node.value)\n\n    def _get_js_class_base_init(self, node ):\n        for base in node.bases:\n            bid = self.visit(base).replace('.','_')\n            if bid == 'object':\n                continue\n\n            if bid not in self._js_classes:\n                print 'WARNING: can not find base class in translation unit \n%s\n' %bid\n                return None\n\n            n = self._js_classes[ bid ]\n\n            if hasattr(n, '_cached_init'):\n                return n._cached_init\n            else:\n                return self._get_js_class_base_init( n )  ## TODO fixme\n\n    def _visit_typed_classdef(self, node): ## this should be called visit_multibackend_classdef\n        name = node.name\n        node._struct_vars = dict()\n        self._js_classes[ name ] = node\n\n        comments = []\n        methods  = {}\n        method_list = []  ## getter/setters can have the same name\n        props = set()     ## type info for the backend and Dart (old)\n        struct_types = dict()\n\n        body_macros = []\n\n        for item in node.body:\n            if isinstance(item, ast.Expr) and isinstance(item.value, ast.Str):\n                comments.append(item.value.s)\n\n            elif isinstance(item, FunctionDef):\n                methods[ item.name ] = item\n                finfo = inspect_method( item )\n                props.update( finfo['properties'] )\n\n                if item.name != '__init__':\n                    method_list.append( item )\n\n                #if item.name == '__init__': continue\n                continue\n\n                item.args.args = item.args.args[1:]  ## remove self\n                for n in finfo['name_nodes']:\n                    if n.id == 'self':\n                        n.id = 'this'\n\n            elif isinstance(item, ast.Expr) and isinstance(item.value, ast.Dict):\n                sdef = []\n                for i in range( len(item.value.keys) ):\n                    k = self.visit( item.value.keys[ i ] )\n                    v = self.visit( item.value.values[i] )\n                    sdef.append( '%s=%s'%(k,v) )\n\n                writer.write('@__struct__(%s)' %','.join(sdef))\n\n            elif isinstance(item, ast.Expr) and isinstance(item.value, ast.Call) and isinstance(item.value.func, ast.Name) and item.value.func.id=='macro':\n                body_macros.append(\nmacro('%s')\n %item.value.args[0].s)\n\n\n        if comments:\n            # Get comment lines.\n            comment_lines = comments[0].splitlines()\n\n            # Remove the first and last comment line, if they are empty (could be caused by a multi-line string).\n            if len(comment_lines[0].strip()) == 0:\n                comment_lines = comment_lines[1:]\n            if len(comment_lines) \n 1 and len(comment_lines[-1].strip()) == 0:\n                comment_lines = comment_lines[:-1]\n\n            # Determine the number of leading whitespaces for the first comment line.\n            number_of_leading_whitespaces = len(comment_lines[0]) - len(comment_lines[0].lstrip())\n\n            stripped_comment_lines = []\n\n            # Remove the leading whitespaces from every line (assuming every whitespace starts with the same whitespaces).\n            for line in comment_lines:\n\n                # The comment line is too short.\n                if len(line) \n number_of_leading_whitespaces:\n                    stripped_comment_lines.append(line.lstrip())\n                    continue\n\n                # The first part of the comment line does not contain only whitespaces.\n                if len(line[:number_of_leading_whitespaces].strip()) \n 0:\n                    stripped_comment_lines.append(line.lstrip())\n                    continue\n\n                stripped_comment_lines.append(line[number_of_leading_whitespaces:])\n\n\n            comments = ['\\n'.join(stripped_comment_lines)]\n\n        ## pass along all class decorators to the backend ##\n        for dec in node.decorator_list:\n            writer.write('@%s'%self.visit(dec))\n\n\n        bases = []\n        for base in node.bases:\n            bases.append( self.visit(base) )\n        if bases:\n            writer.write('class %s( %s ):'%(node.name, ','.join(bases)))\n\n        else:\n            writer.write('class %s:' %node.name)\n\n        init = methods.get( '__init__', None)\n\n        writer.push()\n\n        if comments:\n            writer.write(\n'''%s'''\n %comments[0])\n        if body_macros:\n            for macro in body_macros:\n                writer.write(macro)\n\n        ## constructor\n        if init:\n            methods.pop( '__init__' )\n            #if self._with_dart:\n            #   init.name = node.name\n\n            if not self._with_rust:\n                ## this is used for which backend? ##\n                writer.write('@returns(self)')\n\n            self.visit(init)\n            node._struct_vars.update( init._typed_args )\n\n            for item in init.body:\n                if isinstance(item, ast.Assign) and isinstance(item.targets[0], ast.Attribute):\n                    if isinstance(item.targets[0].value, ast.Name) and item.targets[0].value.id=='self':\n                        attr = item.targets[0].attr\n                        if attr not in node._struct_vars:\n                            if self._with_go:\n                                node._struct_vars[ attr ] = 'interface'\n                            elif self._with_cpp:\n                                pass\n                            else:\n                                err = [ \n                                    'error: unknown type for attribute `self.%s`'%attr,\n                                    'init typed args:' + ', '.join(init._typed_args.keys()),\n                                    'struct members :' + ', '.join(node._struct_vars.keys())\n\n                                ]\n                                raise SyntaxError( self.format_error('\\n'.join(err)) )\n\n                elif isinstance(item, ast.Expr) and isinstance(item.value, ast.Call) and isinstance(item.value.func, ast.Name) and item.value.func.id=='__let__':\n                    if isinstance(item.value.args[0], ast.Attribute) and item.value.args[0].value.id=='self':\n                        #node._struct_vars[ item.value.args[0].attr ] = item.value.args[1].s\n                        node._struct_vars[ item.value.args[0].attr ] = self.visit(item.value.args[1])\n\n        ## methods\n        for method in method_list:\n            self.visit(method)\n\n        for item in node.body:\n            if isinstance(item, ast.With):\n                s = self.visit(item)\n                if s: writer.write( s )\n\n\n        if not init and not method_list:\n            writer.write( 'pass' )\n\n        ## this special dict is picked up in the second stage of `pythonjs_to_xxx` to build structs or classes\n        if node._struct_vars:\n            writer.write('{')\n            for k in node._struct_vars:\n                v = node._struct_vars[k]\n                writer.write('  %s : %s,' %(k,v))\n            writer.write('}')\n\n        writer.pull()\n\n\n    def _visit_js_classdef(self, node):\n        name = node.name\n\n        ## nested classes \n        if hasattr(node, 'is_nested_class') and node.is_nested_class:\n            name = '_'.join( [s.name for s in self._class_stack] )\n\n        self._js_classes[ name ] = node\n        self._in_js_class = True\n        class_decorators = []\n\n        for decorator in node.decorator_list:  ## class decorators\n            class_decorators.append( decorator )\n\n        method_names = []  ## write back in order (required by GLSL)\n        methods      = {}  ## same named functions get squashed in here (like getter/setters)\n        methods_all  = []  ## all methods of class\n        __call__     = None\n        class_vars = []\n        post_class_write = [\n            '%s.prototype.__class__ = %s' %(name, name),\n            '%s.__name__ = \n%s\n' %(name,name),\n            '%s.__bases__ = []' %name,\n        ]\n        node._post_class_write = post_class_write\n        for item in node.body:\n            if isinstance(item, FunctionDef):\n                if item.name == '__getattr__':\n                    raise SyntaxError(self.format_error('__getattr__ is not allowed'))\n                ## only remove `self` if it is the first argument,\n                ## python actually allows `self` to be any name (whatever the first argument is named)\n                ## but that is very bad style, and basically never used.\n                ## by dropping that bad style we can assume that any method whose first argument is\n                ## not self is a static method, this way the user can omit using the decorator `@staticmethod`\n\n                item._has_self = False  ## used below to check if it is a staticmethod\n                if len(item.args.args):\n                    item._has_self = self.visit(item.args.args[0]) in ('self', 'this')\n                if item._has_self:\n                    item.args.args = item.args.args[1:]  ## removes self\n\n\n                finfo = inspect_function( item )\n\n                if item.name == '__call__':\n                    for n in finfo['name_nodes']:\n                        if n.id == 'self':\n                            n.id = '__call__'\n\n                    __call__ = item\n                else:\n                    for n in finfo['name_nodes']:\n                        if n.id == 'self':\n                            n.id = 'this'\n\n                    method_names.append(item.name)\n                    methods[ item.name ] = item\n                    methods_all.append( item )\n\n            elif isinstance(item, ast.Expr) and isinstance(item.value, Str):  ## skip doc strings\n                pass\n            elif isinstance(item, ast.ClassDef):\n                ## support subclass namespaces ##\n                item.is_nested_class = True\n                self.visit(item)\n                sets_namespace = '.'.join( [s.name for s in self._class_stack+[item]] )\n                sub_name = '_'.join( [s.name for s in self._class_stack+[item]] )\n                if len(self._class_stack) \n 1:\n                    self._class_stack[0]._post_class_write.insert(0, '%s = %s' %(sets_namespace, sub_name) )\n                else:\n                    post_class_write.insert(0, '%s = %s' %(sets_namespace, sub_name) )\n\n            else:\n                class_vars.append( item )\n\n\n        init = methods.get( '__init__', None)\n        if init:\n            args = [self.visit(arg) for arg in init.args.args]\n            node._cached_init = init\n            if init.args.kwarg:\n                args.append( init.args.kwarg )\n\n        else:\n            args = []\n            init = self._get_js_class_base_init( node )\n            if init:\n                args = [self.visit(arg) for arg in init.args.args]\n                node._cached_init = init\n\n        writer.write('def %s(%s):' %(name,','.join(args)))\n        writer.push()\n\n        if __call__:\n            line = self.visit(__call__)\n            if line: writer.write( line )\n            writer.write('inline(\n__call__.__$UID$__ = __$UID$__ ++\n)')\n            #writer.write('__call__.__proto__ = this.__proto__')  ## not valid in all browsers\n            ## this works in all browsers, and is only slightly slower than using `__proto__`\n\n            for mname in method_names:\n                writer.write('__call__.%s = this.%s' %(mname, mname))\n\n            writer.write('__call__.__call__ = __call__')  ## for the rare case, where the user directly call `__call__`\n            writer.write('__call__.__class__ = %s' %node.name)  ## so that builtin `isinstance` can still work.\n\n            if init:\n                if hasattr(init, '_code'):  ## cached - is this valid here with __call__? ##\n                    code = init._code\n                elif args:\n                    code = '__call__.__init__(%s)'%(', '.join(args))\n                    init._code = code\n                else:\n                    code = '__call__.__init__()'\n                    init._code = code\n                writer.write(code)\n\n            writer.write('return __call__')\n\n\n            if False:\n                ## this way of implementing a callable functor is 200x slower than above,\n                ## what is likely killing the JIT here is dynamically binding `__call__` to `this`,\n                ## looping over the values in `this` and reassigning them to `__callbound__` appears\n                ## to break V8\n                writer.write('var(__callbound__)')\n                writer.write('@bind(__callbound__, this)')\n                line = self.visit(__call__)\n                if line: writer.write( line )\n                ## note: Object.keys is even slower in this case ##\n                #writer.write('inline(\nfor (var _ in Object.keys(this)) {__callbound__[_]=this[_];}\n)')\n                #writer.write('__callbound__.__proto__ = this.__proto__')\n                #writer.write('__callbound__.__call__ = __callbound__')\n                for mname in method_names:\n                    writer.write('__callbound__.%s = this.%s.bind(this)' %(mname, mname))\n                writer.write('return __callbound__')\n\n\n        elif init:\n            writer.write('inline(\nthis.__$UID$__ = __$UID$__ ++\n)')\n\n            tail = ''  ## what was tail used for?\n\n            ## note: this is just the constructor, the actual __init__\n            ## body is moved along with all the other methods to functions\n            ## that bind to CLASSNAME.prototype.METHODNAME\n            ##for b in init.body:\n            ##  line = self.visit(b)\n            ##  if line: writer.write( line )\n\n            if hasattr(init, '_code'):  ## cached ##\n                code = init._code\n            elif args:\n                code = 'this.__init__(%s); %s'%(', '.join(args), tail)\n                init._code = code\n            else:\n                code = 'this.__init__();     %s' % tail\n                init._code = code\n\n            writer.write(code)\n\n        else:\n            writer.write('inline(\nthis.__$UID$__ = __$UID$__ ++\n)')\n\n        writer.pull()\n\n        if post_class_write:\n            for postline in post_class_write:\n                writer.write(postline)\n\n\n        writer.write('@__prototype__(%s)'%name)\n        writer.write('def toString(): return inline(\nthis.__$UID$__\n)')\n\n        for method in methods_all:\n            mname = method.name\n\n            ## this hack is required to assign the function to the class prototype `A.prototype.method=function`\n            writer.write('@__prototype__(%s)'%name)\n            if not method._has_self:\n                writer.write('@staticmethod')\n\n            line = self.visit(method)\n            if line: writer.write( line )\n            #writer.write('%s.prototype.%s = %s'%(name,mname,mname))  ## this also works, but is not as humanreadable\n\n            ## allows subclass method to extend the parents method by calling the parent by class name,\n            ## `MyParentClass.some_method(self)`\n            f = 'function () { return %s.prototype.%s.apply(arguments[0], Array.prototype.slice.call(arguments,1)) }' %(name, mname)\n            writer.write('%s.%s = inline(\n%s\n)'%(name,mname,f))\n\n        for base in node.bases:\n            base = self.visit(base)\n            if base == 'object': continue\n            a = [\n                'for (var n in %s.prototype) {'%base,\n                '  if (!(n in %s.prototype)) {'%name,\n                '    %s.prototype[n] = %s.prototype[n]'%(name,base),\n                '  }',\n                '}'\n            ]\n            a = ''.join(a)\n            writer.write( \ninline('%s')\n %a )\n            writer.write( '%s.__bases__.push(%s)' %(name,base))\n\n        ## class attributes\n        for item in class_vars:\n            if isinstance(item, Assign) and isinstance(item.targets[0], Name):\n                item_name = item.targets[0].id\n                #item.targets[0].id = '__%s_%s' % (name, item_name)\n                #self.visit(item)  # this will output the code for the assign\n                #writer.write('%s.prototype.%s = %s' % (name, item_name, item.targets[0].id))\n                writer.write('%s.%s = %s' % (name, item_name, self.visit(item.value)))\n\n        self._in_js_class = False\n\n    def visit_ClassDef(self, node):\n        self._class_stack.append( node )\n\n        if self._modules:\n            writer.write('__new_module__(%s)' %node.name) ## triggers a new file in final stage of translation.\n\n        ######## c++ and typed backends ########\n        if self._with_go or self._with_rust or self._with_cpp:\n            self._visit_typed_classdef(node)\n            self._class_stack.pop()\n            return\n\n        elif self._with_js:  ######## javascript backend #######\n            self._visit_js_classdef(node)\n            self._class_stack.pop()\n            return\n\n\n    def visit_And(self, node):\n        return ' and '\n\n    def visit_Or(self, node):\n        return ' or '\n\n    def visit_BoolOp(self, node):\n        op = self.visit(node.op)\n        #raise SyntaxError(op)\n        return '('+ op.join( [self.visit(v) for v in node.values] ) + ')'\n\n    def visit_If(self, node):\n        if writer.is_at_global_level() and (self._with_rust or self._with_rust or self._with_cpp):\n            raise SyntaxError( self.format_error('if statements can not be used at module level when transpiling to typed language') )\n\n        elif isinstance(node.test, ast.Dict):\n            if self._with_js:\n                writer.write('if Object.keys(%s).length:' % self.visit(node.test))\n            else:\n                writer.write('if %s.keys().length:' % self.visit(node.test))\n\n        elif isinstance(node.test, ast.List):\n            writer.write('if %s.length:' % self.visit(node.test))\n\n        elif self._with_ll or self._with_rust or self._with_cpp or self._fast_js:\n            writer.write('if %s:' % self.visit(node.test))\n        elif isinstance(node.test, ast.Compare):\n            writer.write('if %s:' % self.visit(node.test))\n        else:\n            writer.write('if __test_if_true__(%s):' % self.visit(node.test))\n\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n        if node.orelse:\n            writer.write('else:')\n            writer.push()\n            map(self.visit, node.orelse)\n            writer.pull()\n\n    def visit_TryExcept(self, node):\n        if len(node.handlers)==0:\n            raise SyntaxError(self.format_error('no except handlers'))\n\n        ## by default in js-mode some expections will not be raised,\n        ## this allows those cases to throw proper errors.\n        if node.handlers[0].type:\n            self._in_catch_exception = self.visit(node.handlers[0].type)\n        else:\n            self._in_catch_exception = None\n\n        writer.write('try:')\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n        map(self.visit, node.handlers)\n\n    def visit_TryFinally(self, node):\n        #raise SyntaxError(node.body)\n        assert len(node.body)==1\n        self.visit_TryExcept(node.body[0])\n        writer.write('finally:')\n        writer.push()\n        for b in node.finalbody:\n            a = self.visit(b)\n            if a: writer.write(a)\n        writer.pull()\n\n    def visit_Raise(self, node):\n        if isinstance(node.type, ast.Name):\n            writer.write('raise %s' % node.type.id)\n\n        elif isinstance(node.type, ast.Call):\n            if len(node.type.args) \n 1:\n                raise SyntaxError( self.format_error('raise Error(x) can only have a single argument') )\n\n            if node.type.args:\n                writer.write( 'raise %s(%s)' %(self.visit(node.type.func), self.visit(node.type.args[0])) )\n            elif node.type.keywords:\n                kw = []\n                for k in node.type.keywords:\n                    kw.append('%s=%s' %(k.arg, self.visit(k.value)))\n                writer.write( 'raise %s(%s)' %(self.visit(node.type.func), ','.join(kw)) )\n            else:\n                writer.write( 'raise %s()' %self.visit(node.type.func) )\n\n    def visit_ExceptHandler(self, node):\n        if node.type and node.name:\n            writer.write('except %s, %s:' % (self.visit(node.type), self.visit(node.name)))\n        elif node.type and not node.name:\n            writer.write('except %s:' % self.visit(node.type))\n        else:\n            writer.write('except:')\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n\n    def visit_Pass(self, node):\n        writer.write('pass')\n\n    def visit_Name(self, node):\n        if self._with_js:\n            if node.id == 'True':\n                return 'true'\n            elif node.id == 'False':\n                return 'false'\n            elif node.id == 'None':\n                if self._with_go:\n                    return 'nil'\n                else:\n                    return 'null'\n\n        return node.id\n\n    def visit_Num(self, node):\n        return str(node.n)\n\n    def visit_Return(self, node):\n        if node.value:\n            if isinstance(node.value, Call) and isinstance(node.value.func, Name) and node.value.func.id in self._classes:\n                self._return_type = node.value.func.id\n            elif isinstance(node.value, Name) and node.value.id == 'self' and 'self' in self._instances:\n                self._return_type = self._instances['self']\n            ###################\n\n            if isinstance(node.value, ast.Lambda):\n                self.visit( node.value )\n                writer.write( 'return __lambda__' )\n\n            elif isinstance(node.value, ast.Tuple):\n                writer.write( 'return %s;' % ','.join([self.visit(e) for e in node.value.elts]) )\n\n            else:\n                writer.write('return %s' % self.visit(node.value))\n\n        else:\n            writer.write('return')  ## empty return\n\n    def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n\n        is_go_listcomp = False\n        if self._with_go:\n            if op == '\n':\n                if isinstance(node.left, ast.Subscript) and isinstance(node.left.value, ast.Name) and node.left.value.id=='__inline__':\n                    return 'inline(\n%s %s\n)' %(node.left.slice.value.s, self.visit(node.right))\n\n                elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name):\n                    if node.left.func.id=='__go__array__' and isinstance(node.right, ast.GeneratorExp):\n                        is_go_listcomp = True\n                        node.right.go_listcomp_type = node.left.args[0].id\n                    elif node.left.func.id=='__go__map__':\n                        if isinstance(node.left.args[1], ast.Call):  ## map comprehension\n                            is_go_listcomp = True\n                            node.right.go_dictcomp_type =  ( node.left.args[0].id, self.visit(node.left.args[1]) )\n                        else:\n                            node.right.go_dictcomp_type =  ( node.left.args[0].id, node.left.args[1].id )\n\n\n        right = self.visit(node.right)\n\n        if self._with_go:\n            if op == '//': op = '/'\n\n            if is_go_listcomp:\n                return right\n            else:\n                return '(%s %s %s)' % (left, op, right)\n\n        elif op == '%' and isinstance(node.left, ast.Str) and self._with_js:\n            return '__sprintf( %s, %s )' %(left, right)  ## assumes that right is a tuple, or list.\n\n        elif op == '*' and isinstance(node.left, ast.List) and self._with_js:\n            if len(node.left.elts) == 1 and isinstance(node.left.elts[0], ast.Name) and node.left.elts[0].id == 'None':\n                return 'inline(\nnew Array(%s)\n)' %self.visit(node.right)\n            else:\n                return '%s.__mul__(%s)' %(left, right)\n\n        elif op == '**' and self._with_cpp:\n            return 'std.__doublecolon__.pow(%s,%s)' %(left, right)\n\n        elif op == '//' and self._with_cpp:\n            ## note: std::floor(int,int) returns a double,\n            ## because in C, with typed variables there is no need for\n            ## two different division operators `/` (float) and `//` (integer)\n            #return 'std.__doublecolon__.floor(%s/%s)' %(left, right)\n            return '(%s / %s)' % (left, right)\n\n        elif op == '//' and self._with_js:  ## TODO, c++ and typed modes should not set _with_js to true\n            return 'Math.floor(%s/%s)' %(left, right)\n\n        elif op == '**' and self._with_js:\n            return 'Math.pow(%s,%s)' %(left, right)\n\n\n        return '(%s %s %s)' % (left, op, right)\n\n    def visit_Eq(self, node):\n        return '=='\n\n    def visit_NotEq(self, node):\n        return '!='\n\n    def visit_Is(self, node):\n        return 'is'\n\n    def visit_Pow(self, node):\n        return '**'\n\n    def visit_Mult(self, node):\n        return '*'\n\n    def visit_Add(self, node):\n        return '+'\n\n    def visit_Sub(self, node):\n        return '-'\n\n    def visit_FloorDiv(self, node):\n        return '//'\n    def visit_Div(self, node):\n        return '/'\n    def visit_Mod(self, node):\n        return '%'\n    def visit_LShift(self, node):\n        return '\n'\n    def visit_RShift(self, node):\n        return '\n'\n    def visit_BitXor(self, node):\n        return '^'\n    def visit_BitOr(self, node):\n        return '|'\n    def visit_BitAnd(self, node):\n        return '\n'\n\n    def visit_Lt(self, node):\n        return '\n'\n\n    def visit_Gt(self, node):\n        return '\n'\n\n    def visit_GtE(self, node):\n        return '\n='\n\n    def visit_LtE(self, node):\n        return '\n='\n\n    def visit_Compare(self, node):\n        left = self.visit(node.left)\n        comp = [ left ]\n        for i in range( len(node.ops) ):\n            if i==0 and isinstance(node.left, ast.Name) and node.left.id in self._typedef_vars and self._typedef_vars[node.left.id] == 'long':\n                if isinstance(node.ops[i], ast.Eq):\n                    comp = ['%s.equals(%s)' %(left, self.visit(node.comparators[i]))]\n                elif isinstance(node.ops[i], ast.Lt):\n                    comp = ['%s.lessThan(%s)' %(left, self.visit(node.comparators[i]))]\n                elif isinstance(node.ops[i], ast.Gt):\n                    comp = ['%s.greaterThan(%s)' %(left, self.visit(node.comparators[i]))]\n\n                elif isinstance(node.ops[i], ast.LtE):\n                    comp = ['%s.lessThanOrEqual(%s)' %(left, self.visit(node.comparators[i]))]\n                elif isinstance(node.ops[i], ast.GtE):\n                    comp = ['%s.greaterThanOrEqual(%s)' %(left, self.visit(node.comparators[i]))]\n\n                else:\n                    raise NotImplementedError( node.ops[i] )\n\n            elif isinstance(node.ops[i], ast.In) or isinstance(node.ops[i], ast.NotIn):\n                if comp[-1] == left:\n                    comp.pop()\n                else:\n                    comp.append( ' and ' )\n\n                if isinstance(node.ops[i], ast.NotIn):\n                    comp.append( ' not (')\n\n                a = ( self.visit(node.comparators[i]), left )\n\n                if self._with_cpp or self._with_rust or self._with_go:\n                    comp.append('%s in %s' %(a[1], a[0]))\n\n                elif self._with_js:\n                    ## this makes \nif 'x' in Array\n work like Python: \nif 'x' in list\n - TODO fix this for js-objects\n                    ## note javascript rules are confusing: \n1 in [1,2]\n is true, this is because a \nin test\n in javascript tests for an index\n                    comp.append( '__contains__(%s, %s)' %(a[0],a[1]))\n                else:\n                    raise RuntimeError( self.format_error('invalid backend') )\n\n                if isinstance(node.ops[i], ast.NotIn):\n                    comp.append( ' )')  ## it is not required to enclose NotIn\n\n            else:\n                comp.append( self.visit(node.ops[i]) )\n                comp.append( self.visit(node.comparators[i]) )\n\n        try:\n            out = ' '.join(comp)\n        except UnicodeDecodeError as err:\n            print comp\n            for c in comp:\n                print c\n            raise err\n        return ' '.join( comp )\n\n    def visit_Not(self, node):\n        return ' not '\n\n    def visit_IsNot(self, node):\n        return ' is not '\n\n    def visit_UnaryOp(self, node):\n        op = self.visit(node.op)\n        if op is None: raise RuntimeError( node.op )\n        operand = self.visit(node.operand)\n        if operand is None: raise RuntimeError( node.operand )\n        return op + operand\n\n    def visit_USub(self, node):\n        return '-'\n    def visit_UAdd(self, node):\n        return '+'\n\n\n    def visit_Attribute(self, node):\n        node_value = self.visit(node.value)\n\n        if self._with_ll or self._with_go:\n            return '%s.%s' %(node_value, node.attr)\n\n        elif self._with_js:\n            ## TODO enable get attribute - move to js backend ##\n            #if self._in_catch_exception == 'AttributeError':\n            #   return '__getfast__(%s, \n%s\n)' % (node_value, node.attr)\n            #else:\n            return '%s.%s' %(node_value, node.attr)\n\n        elif hasattr(node, 'lineno'):\n            src = self._source[ node.lineno-1 ]\n            src = src.replace('\n', '\\\\\n')\n            err = 'missing attribute `%s` - line %s: %s'    %(node.attr, node.lineno, src.strip())\n            return '__get__(%s, \n%s\n, \n%s\n)' % (node_value, node.attr, err)\n        else:\n            return '__get__(%s, \n%s\n)' % (node_value, node.attr)\n\n\n    def visit_Index(self, node):\n        return self.visit(node.value)\n\n    def visit_Subscript(self, node):\n        name = self.visit(node.value)\n\n        if isinstance(node.slice, ast.Ellipsis):\n            return '%s[...]' %name\n\n        elif self._with_ll or self._with_rust or self._with_go or self._with_cpp:\n            return '%s[%s]' %(name, self.visit(node.slice))\n\n        elif self._with_js:\n            if isinstance(node.slice, ast.Slice):  ## allow slice on Array\n                if not node.slice.lower and not node.slice.upper and not node.slice.step:\n                    return '%s.copy()' %name\n                elif not node.slice.upper and node.slice.step:\n                    slice = self.visit(node.slice).split(',')\n                    slice = '%s,%s' %(slice[0], slice[2])\n                    return '%s.__getslice_lowerstep__(%s)'%(name, slice)\n                else:\n                    return '%s.__getslice__(%s)'%(name, self.visit(node.slice))\n\n\n            elif isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.Num):\n                if node.slice.value.n \n 0:\n                    ## the problem with this is it could be a dict with negative numbered keys\n                    return '%s[ %s.length+%s ]' %(name, name, self.visit(node.slice))\n                else:\n                    return '%s[ %s ]' %(name, self.visit(node.slice))\n\n\n            else:  ## ------------------ old javascript mode ------------------------\n                ## TODO clean this up ##\n\n                if self._in_catch_exception == 'KeyError':\n                    value = self.visit(node.value)\n                    slice = self.visit(node.slice)\n                    return '__get__(%s, \n__getitem__\n)([%s], __NULL_OBJECT__)' % (value, slice)\n\n                elif isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.BinOp):\n                    ## TODO keep this optimization? in js mode `a[x+y]` is assumed to a direct key,\n                    ## it would be safer to check if one of the operands is a number literal,\n                    ## in that case it is safe to assume that this is a direct key.\n                    return '%s[ %s ]' %(name, self.visit(node.slice))\n\n                elif self._with_direct_keys:\n                    return '%s[ %s ]' %(name, self.visit(node.slice))\n\n                else:\n                    s = self.visit(node.slice)\n                    ## this is bad for chromes jit because it trys to find `__uid__`\n                    return '%s[ __ternary_operator__(%s.__uid__, %s) ]' %(name, s, s)\n\n                    ## TODO check why the JSON.stringify hack fails with arrays (fake tuples)\n                    #check_array = '__ternary_operator__( instanceof(%s,Array), JSON.stringify(%s), %s )' %(s, s, s)\n                    #return '%s[ __ternary_operator__(%s.__uid__, %s) ]' %(name, s, check_array)\n\n        else:\n            raise RuntimeError( self.format_error('unknown backend') )\n\n    def visit_Slice(self, node):\n        if self._with_go or self._with_rust or self._with_cpp:\n            lower = upper = step = None\n        elif self._with_js:\n            lower = upper = step = 'undefined'\n        else:\n            lower = upper = step = 'undefined'\n        if node.lower:\n            lower = self.visit(node.lower)\n        if node.upper:\n            upper = self.visit(node.upper)\n        if node.step:\n            step = self.visit(node.step)\n\n        if self._with_go or self._with_rust or self._with_cpp:\n            if lower and upper and step:\n                return '%s:%s:%s' %(lower,upper,step)\n            elif lower and step:\n                return '%s::%s' %(lower,step)\n            elif upper and step:\n                return ':%s:%s' %(upper,step)\n            elif step:\n                return '::%s'%step\n            elif lower and upper:\n                return '%s:%s' %(lower,upper)\n            elif upper:\n                return ':%s' %upper\n            elif lower:\n                return '%s:'%lower\n            else:\n                return ':'\n        else:\n            return \n%s, %s, %s\n % (lower, upper, step)\n\n    def visit_Assign(self, node):\n        use_runtime_errors = not (self._with_js or self._with_ll or self._with_go)\n        use_runtime_errors = use_runtime_errors and self._with_runtime_exceptions\n\n        lineno = node.lineno\n        if node.lineno \n len(self._source):\n            src = self._source[ node.lineno ]\n            self._line_number = node.lineno\n            self._line = src\n\n\n        if use_runtime_errors:\n            writer.write('try:')\n            writer.push()\n\n        targets = list( node.targets )\n        target = targets[0]\n\n        ## should be ok most of the time to assign to a low level type, TODO deprecate this when `auto dict = x` is fixed c++ backend.\n        if isinstance(target, ast.Name) and target.id in typedpython.types:\n            raise SyntaxError( self.format_error('ERROR: can not assign to builtin lowlevel type: '+target.id) )\n\n        elif self._with_go and isinstance(target, ast.Subscript) and isinstance(target.value, ast.Name) and target.value.id in ('__go__array__', '__go__class__', '__go__pointer__', '__go__func__'):\n            if len(targets)==2 and isinstance(targets[1], ast.Attribute) and isinstance(targets[1].value, ast.Name) and targets[1].value.id == 'self' and len(self._class_stack):\n                if target.value.id == '__go__array__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = '__go__array__(%s\ntypedef)' %self.visit(target.slice)\n                elif target.value.id == '__go__class__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = self.visit(target.slice)\n                elif target.value.id == '__go__pointer__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = '\n*%s\n' %self.visit(target.slice)\n                elif target.value.id == '__go__func__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = self.visit(target.slice)\n\n\n            elif target.value.id == '__go__class__':\n                #self._class_stack[-1]._struct_vars[ targets[1].attr ] = self.visit(target.slice)\n                raise SyntaxError(self.visit(target))\n            elif target.value.id == '__go__pointer__':\n                if len(targets)==2:\n                    writer.write(\n                        'inline(\nvar %s *%s;\n)' %(self.visit(targets[1]), self.visit(target.slice))\n                    )\n                else:\n                    writer.write(\n                        'inline(\nvar %s *%s;\n)' %(self.visit(node.value), self.visit(target.slice))\n                    )\n\n            elif target.value.id == '__go__array__':\n                if isinstance(node.value, ast.Call) and len(node.value.args) and isinstance(node.value.args[0], ast.GeneratorExp ):\n                    node.value.args[0].go_listcomp_type = self.visit(target.slice)\n                else:\n                    raise SyntaxError( 'only a variable created by a generator expressions needs an array typedef')\n            else:\n                raise SyntaxError(self.visit(target))\n\n            targets = targets[1:]\n\n\n        elif self._with_rpc_name and isinstance(target, Attribute) and isinstance(target.value, Name) and target.value.id == self._with_rpc_name:\n            writer.write('__rpc_set__(%s, \n%s\n, %s)' %(self._with_rpc, target.attr, self.visit(node.value)))\n            return None\n        elif self._with_rpc_name and isinstance(node.value, Attribute) and isinstance(node.value.value, Name) and node.value.value.id == self._with_rpc_name:\n            writer.write('%s = __rpc_get__(%s, \n%s\n)' %(self.visit(target), self._with_rpc, node.value.attr))\n            return None\n\n        #############################################\n        for target in targets:\n            self._visit_assign_helper( node, target )\n            node = ast.Expr( value=target )\n\n        if use_runtime_errors:\n            writer.pull()\n            writer.write('except:')\n            writer.push()\n            if lineno-1 \n len(self._source):\n                src = self._source[ lineno-1 ]\n                src = src.replace('\n', '\\\\\n')\n                src = 'line %s: %s' %(lineno, src.strip())\n                writer.write('console.trace()')\n                writer.write('console.error(__exception__, __exception__.message)')\n                writer.write('console.error(\n%s\n)' %src)\n                writer.write('raise RuntimeError(\n%s\n)' %src)\n            else:\n                writer.write('raise RuntimeError(\nno source code\n)')\n\n            writer.pull()\n\n\n\n    def _visit_assign_helper(self, node, target):\n        if isinstance(node.value, ast.Lambda):\n            self.visit(node.value)  ## writes function def\n            writer.write('%s = __lambda__' %self.visit(target))\n\n        elif isinstance(node.value, ast.Dict) and (self._with_go or self._with_rust or self._with_cpp):\n            key_type = None\n            val_type = None\n\n            for i in range( len(node.value.keys) ):\n                k = node.value.keys[ i ]\n                v = node.value.values[i]\n\n                ## key type ##\n                if isinstance(k, ast.Str):\n                    key_type = 'string'\n                elif isinstance(k, ast.Num):\n                    key_type = 'int'\n\n                ## value type ##\n                if isinstance(v, ast.Str):\n                    val_type = 'string'\n                elif isinstance(v, ast.Num):\n                    if isinstance(v.n, int):\n                        val_type = 'int'\n                    else:\n                        val_type = 'float64'\n                elif isinstance(v, ast.List) and len(v.elts):\n                    for elt in v.elts:\n                        if isinstance(elt, ast.Num):\n                            if isinstance(elt.n, int):\n                                val_type = '\n[]int\n'\n                            else:\n                                val_type = '\n[]double\n'\n                        elif isinstance(elt, ast.Str):\n                            val_type = '\n[]string\n'\n                elif isinstance(v, ast.Tuple) and len(v.elts):\n                    if val_type is None:\n                        val_type = [None] * len(v.elts)\n\n                    for vidx,elt in enumerate(v.elts):\n                        if isinstance(elt, ast.Num):\n                            if isinstance(elt.n, int):\n                                val_type[vidx] = 'int'\n                            else:\n                                val_type[vidx] = 'double'\n                        elif isinstance(elt, ast.Str):\n                            val_type[vidx] = 'string'\n                        elif isinstance(elt, ast.Name):\n                            ## TODO, check if named is a global\n                            pass\n                        elif isinstance(elt, ast.BinOp):\n\n                            if isinstance(elt.left, ast.Num):\n                                if isinstance(elt.left.n, int):\n                                    val_type[vidx] = 'int'\n                                else:\n                                    val_type[vidx] = 'double'\n\n                            elif isinstance(elt.right, ast.Num):\n                                if isinstance(elt.right.n, int):\n                                    val_type[vidx] = 'int'\n                                else:\n                                    val_type[vidx] = 'double'\n\n\n                        elif isinstance(elt, ast.List) and len(elt.elts):\n                            for et in elt.elts:\n                                if isinstance(et, ast.Num):\n                                    if isinstance(et.n, int):\n                                        val_type[vidx] = '\n[]int\n'\n                                    else:\n                                        val_type[vidx] = '\n[]double\n'\n                                elif isinstance(et, ast.Str):\n                                    val_type[vidx] = '\n[]string\n'\n                                elif isinstance(et, ast.BinOp):\n                                    if isinstance(et.left, ast.Num):\n                                        if isinstance(et.left.n, int):\n                                            val_type[vidx] = '\n[]int\n'\n                                        else:\n                                            val_type[vidx] = '\n[]double\n'\n\n                                    elif isinstance(et.right, ast.Num):\n                                        raise RuntimeError('right is num')\n                                else:\n                                    raise RuntimeError(et)\n                        else:\n                            raise RuntimeError(elt)\n\n\n            if type(val_type) is list:\n                if None in val_type:\n                    raise SyntaxError( self.format_error(val_type) )\n                else:\n                    val_type = tuple(val_type)\n\n\n            if not key_type:\n                raise SyntaxError(  self.format_error('can not determine dict key type')  )\n            if not val_type:\n                raise SyntaxError(  self.format_error('can not determine dict value type')  )\n\n            t = self.visit(target)\n            v = self.visit(node.value)\n            writer.write('%s = __go__map__(%s, %s) \n %s' %(t, key_type, val_type, v))\n            self._autotyped_dicts[t] = v\n\n\n        elif isinstance(node.value, ast.List) and (self._with_go or self._with_rust or self._with_cpp):\n            guess_type = None\n            for elt in node.value.elts:\n                if isinstance(elt, ast.Num):\n                    if isinstance(elt.n, int):\n                        guess_type = 'int'\n                    else:\n                        guess_type = 'float64'\n                elif isinstance(elt, ast.Str):\n                    guess_type = 'string'\n\n            if guess_type:\n                t = self.visit(target)\n                v = self.visit(node.value)\n                writer.write('%s = __go__array__(%s) \n %s' %(t, guess_type, v))\n            else:\n                raise SyntaxError(self.format_error('can not determine type of array'))\n\n        elif isinstance(target, Subscript):\n            name = self.visit(target.value)  ## target.value may have \nreturns_type\n after being visited\n\n            if isinstance(target.slice, ast.Ellipsis):\n                #code = '%s[\n$wrapped\n] = %s' %(self.visit(target.value), self.visit(node.value))\n                code = '%s[...] = %s' %(self.visit(target.value), self.visit(node.value))\n\n            elif isinstance(target.slice, ast.Slice):\n                if isinstance(target.value, ast.Name) and target.value.id == '__let__':\n                    ## pass along special __let__ to the backend pass\n                    code = '__let__[%s : %s]' %(self.visit(target.slice.upper), self.visit(target.slice.lower))\n                elif self._with_cpp or self._with_rust or self._with_go:\n                    code = '%s[%s]=%s' %(self.visit(target.value), self.visit(target.slice), self.visit(node.value))\n                else:\n                    code = '%s.__setslice__(%s, %s)' %(self.visit(target.value), self.visit(target.slice), self.visit(node.value))\n\n            elif self._with_ll or self._with_cpp or self._with_go or self._with_rust:\n                code = '%s[ %s ] = %s'\n                code = code % (self.visit(target.value), self.visit(target.slice.value), self.visit(node.value))\n\n            elif self._with_js:\n                s = self.visit(target.slice.value)\n                if isinstance(target.slice.value, ast.Num) or isinstance(target.slice.value, ast.BinOp):\n                    code = '%s[ %s ] = %s' % (self.visit(target.value), s, self.visit(node.value))\n                elif self._with_direct_keys:\n                    code = '%s[ %s ] = %s' % (self.visit(target.value), s, self.visit(node.value))\n                else:\n                    ## check_array is broken? TODO deprecate or fix this\n                    #check_array = '__ternary_operator__( instanceof(%s,Array), JSON.stringify(%s), %s )' %(s, s, s)\n                    #code = '%s[ __ternary_operator__(%s.__uid__, %s) ] = %s' %(self.visit(target.value), s, check_array, self.visit(node.value))\n                    ## this is safer\n                    code = '%s[ __ternary_operator__(%s.__uid__, %s) ] = %s' %(self.visit(target.value), s, s, self.visit(node.value))\n\n            elif name in self._func_typedefs and self._func_typedefs[name] == 'list':\n                code = '%s[%s] = %s'%(name, self.visit(target.slice.value), self.visit(node.value))\n\n            else:\n                code = \n__get__(__get__(%s, '__setitem__'), '__call__')([%s, %s], JSObject())\n\n                code = code % (self.visit(target.value), self.visit(target.slice.value), self.visit(node.value))\n\n            writer.write(code)\n\n        elif isinstance(target, Attribute):\n            self._in_assign_target = True\n            target_value = self.visit(target.value)  ## target.value may have \nreturns_type\n after being visited\n            self._in_assign_target = False\n\n            if self._with_js or self._with_go:\n                writer.write( '%s.%s=%s' %(target_value, target.attr, self.visit(node.value)) )\n\n        elif isinstance(target, Name):  ## assignment to variable\n            node_value = self.visit( node.value )  ## node.value may have extra attributes after being visited\n\n            ## note: self._globals and self._instances is DEPRECATED\n            ## tracking of variable types has been moved to the next stage of translation,\n            ## where each backend may have different requirements.\n\n            writer.write('%s = %s' % (self.visit(target), node_value))\n\n        elif isinstance(target, ast.Tuple):\n            if self._use_destructured_assignment:  ## Rust, Go, Dart\n                elts = [self.visit(e) for e in target.elts]\n                writer.write('(%s) = %s' % (','.join(elts), self.visit(node.value)))\n\n            elif self._with_cpp and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='channel':\n                ## special case for rust style channels\n                sender = self.visit( target.elts[0] )\n                recver = self.visit( target.elts[1] )\n                writer.write('%s = %s' % (sender, self.visit(node.value)))\n                writer.write('%s = %s' % (recver, sender))\n\n            else:\n                if isinstance(node.value, ast.Name):\n                    r = node.value.id\n                else:\n                    id = self.identifier\n                    self.identifier += 1\n                    r = '__r_%s' % id\n                    writer.write('var(%s)' % r)\n                    writer.write('%s = %s' % (r, self.visit(node.value)))\n\n                for i, target in enumerate(target.elts):\n                    if isinstance(target, Attribute):\n                        code = '__set__(%s, \n%s\n, %s[%s])' % (\n                            self.visit(target.value),\n                            target.attr,\n                            r,\n                            i\n                        )\n                        writer.write(code)\n                    elif self._with_js:\n                        writer.write(\n%s = %s[%s]\n % (self.visit(target), r, i))\n                    else:\n                        raise RuntimeError( self.format_error('unknown backend'))\n\n        else:\n            raise SyntaxError( self.format_error(target) )\n\n\n    def visit_Print(self, node):\n        writer.write('print(%s)' % ', '.join(map(self.visit, node.values)))\n\n    def visit_Str(self, node):\n        s = node.s.replace('\\\\','\\\\\\\\').replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\\0', '\\\\0')\n        s = s.replace('\\\n', '\\\\\n')\n        s = s.replace('.__right_arrow__.', '-\n').replace('= __go__send__\n', '\n-')\n        s = s.replace('__DOLLAR__', '$')\n        s = s.replace('__new__\n', 'new ')\n        s = s.replace('.__doublecolon__.', '::')\n\n\n        if self._with_js:\n            return '\n%s\n' %s           #.encode('utf-8')\n        else:\n            if len(s) == 0:\n                return '\n'\n            elif s.startswith('\n') or s.endswith('\n'):\n                return \n'''%s'''\n %s   #.encode('utf-8')\n            else:\n                return '\n%s\n' %s   #.encode('utf-8')\n\n    def visit_IfExp(self, node):\n        test    = self.visit(node.test)\n        iftrue  = self.visit(node.body)\n        iffalse = self.visit(node.orelse)\n        return '(%s if %s else %s)' %(iftrue, test, iffalse)\n\n\n    def visit_Expr(self, node):\n        if node.lineno \n len(self._source):\n            src = self._source[ node.lineno ]\n            ## TODO raise SyntaxErrors with the line number and line source\n            self._line_number = node.lineno\n            self._line = src\n\n        ## note: runtime errors and checking generator has moved to `jstranslator.md`\n        ## TODO clean this up\n        #use_runtime_errors = not (self._with_js or self._with_ll or self._with_dart or self._with_coffee or self._with_go)\n        #use_runtime_errors = use_runtime_errors and self._with_runtime_exceptions\n\n        line = self.visit(node.value)\n        if line:\n            #writer.write('('+line+')')\n            writer.write( line )\n\n\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Lambda):  ## inlined and called lambda \n(lambda x: x)(y)\n\n            node.func.keep_as_lambda = True\n\n        for a in node.args:\n            if isinstance(a, ast.Lambda):\n                a.keep_as_lambda = True\n\n        for kw in node.keywords:\n            if isinstance(kw.value, ast.Lambda):\n                kw.value.keep_as_lambda = True\n\n\n        name = self.visit(node.func)\n        if name in typedpython.GO_SPECIAL_CALLS:\n            name = typedpython.GO_SPECIAL_CALLS[ name ]\n            args = [self.visit(e) for e in node.args ]\n            args += ['%s=%s' %(k.arg, self.visit(k.value)) for k in node.keywords ]\n            return '%s( %s )' %(name, ','.join(args))\n\n        if self._with_rpc:\n            if not self._with_rpc_name:\n                return '__rpc__( %s, \n%s\n, [%s] )' %(self._with_rpc, name, ','.join([self.visit(a) for a in node.args]))\n            elif self._with_rpc_name:\n                if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == self._with_rpc_name:\n                    name = name[ len(self._with_rpc_name)+1 : ]\n                    return '__rpc__( %s, \n%s\n, [%s] )' %(self._with_rpc, name, ','.join([self.visit(a) for a in node.args]))\n\n        ###############################################\n\n        if name == 'open':  ## do not overwrite window.open ##\n            name = '__open__'\n            node.func.id = '__open__'\n\n        ###############################################\n\n        if self._with_webworker and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'self' and node.func.attr == 'terminate':\n            return 'self.postMessage({\ntype\n:\nterminate\n})'\n\n        elif self._use_threading and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'threading':\n            if node.func.attr == 'start_new_thread' or node.func.attr == '_start_new_thread':\n                return '__start_new_thread( %s, %s )' %(self.visit(node.args[0]), self.visit(node.args[1]))\n            elif node.func.attr == 'start_webworker':\n                return '__start_new_thread( %s, %s )' %(self.visit(node.args[0]), self.visit(node.args[1]))\n            else:\n                raise SyntaxError( self.format_error(node.func.attr) )\n\n        elif self._with_webworker and name in self._global_functions:\n            node.calling_from_worker = True\n            args = [self.visit(arg) for arg in node.args]\n            return 'self.postMessage({\ntype\n:\ncall\n, \nfunction\n:\n%s\n, \nargs\n:[%s]})' %(name, ','.join(args))\n\n        elif self._with_js and self._use_array and name == 'array':\n            args = [self.visit(arg) for arg in node.args]\n            return '__js_typed_array(%s)' %','.join(args)\n\n        #########################################\n        if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'numpy' and node.func.attr == 'array':\n            args = [self.visit(arg) for arg in node.args]\n            if node.keywords:\n                kwargs = [ '%s=%s' %(x.arg, self.visit(x.value)) for x in node.keywords]\n                return 'numpy.array(%s, %s)' %( ','.join(args), ','.join(kwargs) )\n            else:\n                return 'numpy.array(%s)' %','.join(args)\n\n        elif isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'pythonjs' and node.func.attr == 'configure':\n            raise RuntimeError( self.format_error('pythonjs.configure is deprecated'))\n\n        elif name == 'inline':\n            return 'inline(%s)' %self.visit(node.args[0])\n\n        elif self._with_ll:\n            F = self.visit(node.func)\n            args = [self.visit(arg) for arg in node.args]\n            if node.keywords:\n                args.extend( [self.visit(x.value) for x in node.keywords] )\n                return '%s(%s)' %( F, ','.join(args) )\n            else:\n                return '%s(%s)' %( F, ','.join(args) )\n\n        elif self._with_go or self._with_rust or self._with_cpp:  ## pass-thru unchanged to next stage for Go, Rust and C++\n            args = list( map(self.visit, node.args) )\n            if None in args:\n                raise RuntimeError( self.format_error('invalid argument: %s' %node.args))\n            if node.keywords:\n                args.extend( ['%s=%s'%(x.arg,self.visit(x.value)) for x in node.keywords] )\n            if node.starargs:\n                args.append('*%s' %self.visit(node.starargs))\n\n            return '%s(%s)' %( self.visit(node.func), ','.join(args) )\n\n        elif self._with_js:\n            args = list( map(self.visit, node.args) )\n\n            if name in self._generator_functions:\n                return ' new(%s(%s))' %(name, ','.join(args))\n\n            elif name in self._builtin_functions and self._builtin_functions[name]:  ## inlined js\n                if args:\n                    return self._builtin_functions[name] % ','.join(args)\n                else:\n                    return self._builtin_functions[name]\n\n            elif name == 'new':\n                assert len(args) == 1\n                return 'new(%s)' %args[0]\n\n            elif name == 'isinstance':\n                assert len(args) == 2\n                #if args[1] == 'dict':   ## TODO find better solution for dict test\n                #   args[1] = 'Object'  ## this fails when testing \nisinstance(a, dict)==False\n when a is an instance of some class.\n                #elif args[1] == 'list':\n                #   args[1] = 'Array'\n                return 'isinstance(%s, %s)' %(args[0], args[1])\n\n            elif isinstance(node.func, ast.Attribute):\n                ## special method calls that collide with javascript internal methods on native types ##\n                anode = node.func\n                self._in_assign_target = True\n                method = self.visit( node.func )\n                self._in_assign_target = False\n\n                if anode.attr == 'update' and len(args) == 1:\n                    return '__jsdict_update(%s, %s)' %(self.visit(anode.value), ','.join(args) )\n\n                elif anode.attr == 'get' and len(args) \n 0 and len(args) \n= 2 and not node.keywords:\n                    return '__jsdict_get(%s, %s)' %(self.visit(anode.value), ','.join(args) )\n\n                elif anode.attr == 'set' and len(args)==2:\n                    return '__jsdict_set(%s, %s)' %(self.visit(anode.value), ','.join(args))\n\n                elif anode.attr == 'keys' and not args:\n                    #if self._strict_mode:\n                    #   raise SyntaxError( self.format_error('method `keys` is not allowed without arguments') )\n\n                    return '__jsdict_keys(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'values' and not args:\n                    #if self._strict_mode:\n                    #   raise SyntaxError( self.format_error('method `values` is not allowed without arguments') )\n                    return '__jsdict_values(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'items' and not args and not node.keywords:\n                    #if self._strict_mode:\n                    #   raise SyntaxError( self.format_error('method `items` is not allowed without arguments') )\n\n                    return '__jsdict_items(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'pop' and len(args) in (1,2):\n                    pval  = self.visit(anode.value)\n                    pargs = ','.join(args)\n                    ## special case for `myarray.pop(0)`, all cases of `myarr.pop(n)` see `__jsdict_pop`\n                    if len(args)==1 and isinstance(anode.value, ast.Name) and args[0]=='0':  ## V8 can JIT this\n                        return '(%s.shift() if instanceof(%s,Array) else __jsdict_pop(%s, %s))' %(pval, pval, pval,pargs)\n                    else:\n                        return '__jsdict_pop(%s, %s)' %(pval, ','.join(args) )\n\n                elif anode.attr == 'split' and not args:\n                    if self._strict_mode:\n                        raise SyntaxError( self.format_error('method `split` is not allowed without arguments') )\n\n                    return '__split_method(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'sort' and not args:\n                    if self._strict_mode:\n                        raise SyntaxError( self.format_error('method `sort` is not allowed without arguments') )\n\n                    return '__sort_method(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'replace' and len(node.args)==2:\n                    if self._strict_mode:\n                        raise SyntaxError( self.format_error('method `replace` is not allowed...') )\n\n                    return '__replace_method(%s, %s)' %(self.visit(anode.value), ','.join(args) )\n\n                else:\n                    ctx = '.'.join( self.visit(node.func).split('.')[:-1] )\n                    if node.keywords:\n                        kwargs = [ '%s:%s'%(x.arg, self.visit(x.value)) for x in node.keywords ]\n\n                        if args:\n                            if node.starargs:\n                                a = ( method, ctx, ','.join(args), self.visit(node.starargs), ','.join(kwargs) )\n                                ## note: this depends on the fact that [].extend in PythonJS returns self (this),\n                                ## which is different from regular python where list.extend returns None\n                                return '%s.apply( %s, [].extend([%s]).extend(%s).append({%s}) )' %a\n                            else:\n                                return '%s(%s, {%s})' %( method, ','.join(args), ','.join(kwargs) )\n\n                        else:\n                            if node.starargs:\n                                a = ( self.visit(node.func),ctx, self.visit(node.starargs), ','.join(kwargs) )\n                                return '%s.apply(%s, [].extend(%s).append({%s}) )' %a\n\n                            else:\n                                return '%s({%s})' %( method, ','.join(kwargs) )\n\n                    else:\n                        if node.starargs:\n                            a = ( self.visit(node.func), ctx, ','.join(args), self.visit(node.starargs) )\n                            return '%s.apply(%s, [].extend([%s]).extend(%s))' %a\n\n                        else:\n                            return '%s(%s)' %( method, ','.join(args) )\n\n\n            elif isinstance(node.func, Name) and node.func.id in self._js_classes:\n                if node.keywords:\n                    kwargs = [ '%s:%s'%(x.arg, self.visit(x.value)) for x in node.keywords ]\n                    if args:\n                        a = ','.join(args)\n                        return 'new( %s(%s, {%s}) )' %( self.visit(node.func), a, ','.join(kwargs) )\n                    else:\n                        return 'new( %s({%s}) )' %( self.visit(node.func), ','.join(kwargs) )\n                else:\n                    if node.kwargs:\n                        args.append( self.visit(node.kwargs) )\n\n                    a = ','.join(args)\n                    return 'new( %s(%s) )' %( self.visit(node.func), a )\n\n            else:  ## ----------------------------- javascript mode ------------------------\n                if node.keywords:\n                    kwargs = [ '%s:%s'%(x.arg, self.visit(x.value)) for x in node.keywords ]\n                    if args:\n                        if node.starargs:\n                            a = ( self.visit(node.func), self.visit(node.func), ','.join(args), self.visit(node.starargs), ','.join(kwargs) )\n                            return '%s.apply( %s, [].extend([%s]).extend(%s).append({%s}) )' %a\n                        else:\n                            return '%s(%s, {%s})' %( self.visit(node.func), ','.join(args), ','.join(kwargs) )\n                    else:\n                        if node.starargs:\n                            a = ( self.visit(node.func),self.visit(node.func), self.visit(node.starargs), ','.join(kwargs) )\n                            return '%s.apply(%s, [].extend(%s).append({%s}) )' %a\n                        else:\n                            func_name = self.visit(node.func)\n                            if func_name == 'dict':\n                                return '{%s}' %','.join(kwargs)\n                            else:\n                                return '%s({%s})' %( func_name, ','.join(kwargs) )\n\n                else:\n                    if node.starargs:\n                        a = ( self.visit(node.func), self.visit(node.func), ','.join(args), self.visit(node.starargs) )\n                        return '%s.apply(%s, [].extend([%s]).extend(%s))' %a\n                    else:\n                        return '%s(%s)' %( self.visit(node.func), ','.join(args) )\n\n\n        elif isinstance(node.func, Name) and node.func.id in self._generator_functions:\n            args = list( map(self.visit, node.args) )\n            if name in self._generator_functions:\n                return 'JS(\nnew %s(%s)\n)' %(name, ','.join(args))\n\n        elif name == 'new':\n            args = list( map(self.visit, node.args) )\n            assert len(args) == 1\n            return 'new(%s)' %args[0]\n\n        elif isinstance(node.func, Name) and node.func.id in ('JS', 'toString', 'JSObject', 'JSArray', 'var', 'instanceof', 'typeof'):\n            args = list( map(self.visit, node.args) ) ## map in py3 returns an iterator not a list\n            if node.func.id == 'var':\n                for k in node.keywords:\n                    self._instances[ k.arg ] = k.value.id\n                    args.append( k.arg )\n            else:\n                kwargs = map(lambda x: '%s=%s' % (x.arg, self.visit(x.value)), node.keywords)\n                args.extend(kwargs)\n            args = ', '.join(args)\n            return '%s(%s)' % (node.func.id, args)\n\n        else:\n            ## TODO deprecate below ##\n\n            ## check if pushing to a global typed list ##\n            if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id in self._global_typed_lists and node.func.attr == 'append':\n                gtype = self._globals[ node.func.value.id ]\n                if gtype == 'list' and node.func.attr == 'append':\n                    if isinstance(node.args[0], Name):\n                        if node.args[0].id in self._instances:\n                            gset = self._global_typed_lists[ node.func.value.id ]\n                            gset.add( self._instances[node.args[0].id])\n                            if len(gset) != 1:\n                                raise SyntaxError('global lists can only contain one type: instance \n%s\n is different' %node.args[0].id)\n                        else:\n                            raise SyntaxError('global lists can only contain one type: instance \n%s\n is unknown' %node.args[0].id)\n\n            call_has_args_only = len(node.args) and not (len(node.keywords) or node.starargs or node.kwargs)\n            call_has_args_kwargs_only = len(node.args) and len(node.keywords) and not (node.starargs or node.kwargs)\n            call_has_args = len(node.args) or len(node.keywords) or node.starargs or node.kwargs\n            name = self.visit(node.func)\n            args = None\n            kwargs = None\n\n            if call_has_args_only:  ## lambda only supports simple args for now.\n                args = ', '.join(map(self.visit, node.args))\n\n            elif call_has_args_kwargs_only:\n                args = ', '.join(map(self.visit, node.args))\n                kwargs = ', '.join(map(lambda x: '%s:%s' % (x.arg, self.visit(x.value)), node.keywords))\n\n            elif call_has_args:\n                args = ', '.join(map(self.visit, node.args))\n                kwargs = ', '.join(map(lambda x: '%s=%s' % (x.arg, self.visit(x.value)), node.keywords))\n                args_name = '__args_%s' % self.identifier\n                kwargs_name = '__kwargs_%s' % self.identifier\n\n                writer.append('var(%s, %s)' % (args_name, kwargs_name))\n                self.identifier += 1\n\n                writer.append('%s = [%s]' % (args_name, args))\n\n                if node.starargs:\n                    writer.append('%s.push.apply(%s, %s)' % (args_name, args_name, self.visit(node.starargs)))\n\n                writer.append('%s = JSObject(%s)' % (kwargs_name, kwargs))\n\n                if node.kwargs:\n                    kwargs = self.visit(node.kwargs)\n                    writer.write('var(__kwargs_temp)')\n                    writer.write('__kwargs_temp = %s[...]' %kwargs)\n                    #code = \nJS('for (var name in %s) { %s[name] = %s[...][name]; }')\n % (kwargs, kwargs_name, kwargs)\n                    #code = \nfor __name in %s: %s[__name] = %s[__name]\n % (kwargs, kwargs_name, kwargs)\n                    code = \nJS('for (var name in __kwargs_temp) { %s[name] = __kwargs_temp[name]; }')\n %kwargs_name\n                    writer.append(code)\n\n            #######################################\n\n            ## special method calls ##\n            if isinstance(node.func, ast.Attribute) and node.func.attr in ('get', 'keys', 'values', 'pop', 'items', 'split', 'replace', 'sort'):\n                anode = node.func\n                if anode.attr == 'get' and len(node.args) \n 0 and len(node.args) \n= 2:\n                    return '__jsdict_get(%s, %s)' %(self.visit(anode.value), args )\n\n                elif anode.attr == 'keys' and not args:\n                    return '__jsdict_keys(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'values' and not args:\n                    return '__jsdict_values(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'items' and not args:\n                    return '__jsdict_items(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'pop':\n                    if args:\n                        return '__jsdict_pop(%s, %s)' %(self.visit(anode.value), args )\n                    else:\n                        return '__jsdict_pop(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'sort' and not args:\n                    return '__sort_method(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'split' and len(node.args) \n= 1:\n                    if not args:\n                        return '__split_method(%s)' %self.visit(anode.value)\n                    else:\n                        return '__split_method(%s, %s)' %(self.visit(anode.value), args)\n\n                elif anode.attr == 'replace' and len(node.args)==2:\n                    return '__replace_method(%s, %s)' %(self.visit(anode.value), args )\n\n                else:\n                    return '%s(%s)' %( self.visit(node.func), args )\n\n\n    def visit_Lambda(self, node):\n        args = []\n        for i,a in  enumerate(node.args.args):  ## typed args lambda hack\n            s = self.visit(a)\n            if len(node.args.defaults):\n                assert len(node.args.args)==len(node.args.defaults)\n                s += '=\n%s\n' %self.visit(node.args.defaults[i])\n            args.append( s )\n\n\n        ##'__INLINE_FUNCTION__' from typedpython.py\n        if hasattr(node, 'keep_as_lambda') or (args and args[0]=='__INLINE_FUNCTION__'):\n            ## TODO lambda keyword args\n            self._in_lambda = True\n            a = '(lambda %s: %s)' %(','.join(args), self.visit(node.body))\n            self._in_lambda = False\n            return a\n        else:\n            node.name = '__lambda__'\n            node.decorator_list = []\n            node.body = [node.body]\n            b = node.body[-1]\n            node.body[-1] = ast.Return( b )\n            return self.visit_FunctionDef(node)\n\n    def visit_FunctionDef(self, node):\n        global writer\n\n        ## deprecated\n        #if node in self._generator_function_nodes:\n        #   self._generator_functions.add( node.name )\n        #   if '--native-yield' in sys.argv:\n        #       raise NotImplementedError  ## TODO\n        #   else:\n        #       GeneratorFunctionTransformer( node, compiler=self )\n        #       return\n\n        writer.functions.append(node.name)\n\n        is_worker_entry = False\n        property_decorator = None\n        decorators = []\n        with_dart_decorators = []\n        setter = False\n        return_type = None\n        return_type_keywords = {}\n        fastdef = False\n        javascript = False\n        inline = False\n        threaded = self._with_webworker\n        jsfile = None\n\n        self._typedef_vars = dict()  ## clear typed variables: filled in below by @typedef or in visit_Assign, TODO break this apart into _typed_args and _typed_locals on the node\n        node._typed_args = dict()    ## used in visit class def to get types for struct\n\n        ## TODO deprecate all the glsl code\n        local_typedefs = []\n        typedef_chans = []\n        func_expr = None\n\n        ## deprecated?\n        self._func_typedefs = {}\n\n        if writer.is_at_global_level() and not self._with_webworker:\n            self._global_functions[ node.name ] = node  ## save ast-node\n\n        for decorator in reversed(node.decorator_list):\n            if isinstance(decorator, Name) and decorator.id == 'debugger':\n                writer.write('@debugger')\n            elif isinstance(decorator, Name) and decorator.id == 'classmethod':\n                writer.write('@classmethod')\n            elif isinstance(decorator, Name) and decorator.id == 'virtualoverride':\n                writer.write('@virtualoverride')\n            elif isinstance(decorator, Name) and decorator.id == 'extern':\n                writer.write('@extern')\n\n            elif isinstance(decorator, Call) and decorator.func.id == 'expression':\n                ## js function expressions are now the default, because hoisting is not pythonic.\n                ## when the user writes `a = def(): ...` this gets translated to `@expression( target )\\n def __NAMELESS__()`\n                assert len(decorator.args)==1\n                func_expr = self.visit(decorator.args[0])\n\n            elif isinstance(decorator, Call) and decorator.func.id == '__typedef__':  ## new style\n                c = decorator\n                assert len(c.args) == 3 and len(c.keywords)==0\n                vname = self.visit(c.args[0])\n                vtype = self.visit(c.args[1])\n                vptr  = self.visit(c.args[2])\n\n                self._typedef_vars[ vname ]  = vtype\n                self._instances[ vname ]     = vtype\n                self._func_typedefs[ vname ] = vtype\n                node._typed_args[ vname ]    = vtype\n                local_typedefs.append( '%s=%s' %(vname, vtype))\n                writer.write('@__typedef__(%s, %s, %s)' %(vname, vtype, vptr))\n\n\n            elif isinstance(decorator, Call) and decorator.func.id in ('typedef', 'typedef_chan'):  ## old style\n                c = decorator\n                assert len(c.args) == 0 and len(c.keywords)\n                for kw in c.keywords:\n                    #assert isinstance( kw.value, Name)\n                    kwval = self.visit(kw.value)\n                    self._typedef_vars[ kw.arg ] = kwval\n                    self._instances[ kw.arg ] = kwval\n                    self._func_typedefs[ kw.arg ] = kwval\n                    node._typed_args[ kw.arg ]    = kwval\n                    local_typedefs.append( '%s=%s' %(kw.arg, kwval))\n                    if decorator.func.id=='typedef_chan':\n                        typedef_chans.append( kw.arg )\n                        writer.write('@__typedef_chan__(%s=%s)' %(kw.arg, kwval))\n                    else:\n                        writer.write('@__typedef__(%s=%s)' %(kw.arg, kwval))\n\n\n            elif isinstance(decorator, ast.Call) and isinstance(decorator.func, ast.Name) and decorator.func.id == 'webworker':\n                threaded = True\n                assert len(decorator.args) == 1\n                jsfile = decorator.args[0].s\n\n            elif isinstance(decorator, Call) and isinstance(decorator.func, ast.Name) and decorator.func.id == 'returns':\n                #if decorator.keywords:  ## deprecated\n                #   for k in decorator.keywords:\n                #       key = k.arg\n                #       assert key == 'array' or key == 'vec4'\n                #       return_type_keywords[ key ] = self.visit(k.value)\n                #else:\n                assert len(decorator.args) == 1\n                if isinstance( decorator.args[0], Name):\n                    return_type = decorator.args[0].id\n                elif isinstance(decorator.args[0], ast.Str):\n                    return_type = '\n%s\n' %decorator.args[0].s\n                else:\n                    raise SyntaxError('invalid @returns argument')\n\n            elif self._with_cpp or self._with_rust:\n                writer.write('@%s' %self.visit(decorator))\n\n            elif isinstance(decorator, Name) and decorator.id == 'fastdef':  ## TODO clean this up\n                fastdef = True\n                raise SyntaxError('@fast is deprecated')\n\n            elif isinstance(decorator, Name) and decorator.id == 'javascript':\n                javascript = True\n                raise SyntaxError('@javascript is deprecated')\n\n            elif isinstance(decorator, Name) and decorator.id == 'property':\n                ## this old style is deprecated, it worked with the old js backend and lua backend\n                #property_decorator = decorator\n                #n = node.name + '__getprop__'\n                #self._decorator_properties[ node.original_name ] = dict( get=n, set=None )\n                #node.name = n\n\n                self._decorator_properties[ node.name ] = dict( get=decorator, set=None )\n                writer.write('@getter')\n\n\n            elif isinstance(decorator, Attribute) and isinstance(decorator.value, Name) and decorator.value.id in self._decorator_properties:\n                if decorator.attr == 'setter':\n                    if self._decorator_properties[ decorator.value.id ]['set'] is not None:\n                        raise SyntaxError( self.format_error(\ndecorator.setter is used more than once\n) )\n\n                    ## old deprecated stuff\n                    #n = node.name + '__setprop__'\n                    #self._decorator_properties[ decorator.value.id ]['set'] = n\n                    #node.name = n\n                    #setter = True\n                    #prop_name = node.original_name\n\n                    if node.name != decorator.value.id:\n                        node.name = decorator.value.id\n\n                    self._decorator_properties[ decorator.value.id ]['set'] = decorator\n                    writer.write('@setter')\n\n                elif decorator.attr == 'deleter':\n                    ## javascript has no deleter for properties?\n                    raise NotImplementedError('TODO property deleter')\n                else:\n                    raise SyntaxError('invalid property type')\n\n            elif isinstance(decorator, Call) and decorator.func.id == 'custom_operator':\n                assert len(decorator.args) == 1\n                assert isinstance( decorator.args[0], Str )\n                op = decorator.args[0].s.decode('utf-8')\n                if op not in self._custom_operators:\n                    raise RuntimeError( op, self._custom_operators )\n                self._custom_operators[ op ] = node.name\n\n            else:\n                decorators.append( decorator )\n\n\n        if threaded:\n            if not jsfile: jsfile = 'worker.js'\n            #writer_main.write('%s = \n%s\n' %(node.name, jsfile))\n            self._webworker_functions[ node.name ] = jsfile\n            writer = get_webworker_writer( jsfile )  ## updates global `writer`\n\n\n\n        ## force python variable scope, and pass user type information to second stage of translation.\n        ## the dart backend can use this extra type information for speed and debugging.\n        ## the Go and GLSL backends require this extra type information.\n        vars = []\n        local_typedef_names = set()\n        if not self._with_coffee:\n            try:\n                local_vars, global_vars = retrieve_vars(node.body)\n            except SyntaxError as err:\n                raise SyntaxError( self.format_error(err) )\n\n            local_vars = local_vars-global_vars\n            inlined_long = False\n            if local_vars:\n                args_typedefs = []\n                args = [ a.id for a in node.args.args ]\n\n                for v in local_vars:\n                    usertype = None\n                    if '=' in v:\n                        t,n = v.split('=')  ## unpack type and name\n                        v = '%s=%s' %(n,t)  ## reverse\n                        local_typedef_names.add( n )\n                        if t == 'long' and inlined_long == False:\n                            inlined_long = True\n                            writer.write('''inline(\nif (__NODEJS__==true) var long = require('long')\n)''')  ## this is ugly\n\n                        if n in args:\n                            args_typedefs.append( v )\n                        else:\n                            local_typedefs.append( v )\n                    elif v in args or v in local_typedef_names: pass\n                    else: vars.append( v )\n\n                if args_typedefs:\n                    writer.write('@__typedef__(%s)' %','.join(args_typedefs))\n\n\n        if func_expr:\n            writer.write('@expression(%s)' %func_expr)\n\n\n        if not self._with_js and not javascript:\n            writer.write('@__pyfunction__')\n\n        if return_type or return_type_keywords:\n            if return_type_keywords and return_type:\n                kw = ['%s=%s' %(k,v) for k,v in return_type_keywords.items()]\n                writer.write('@returns(%s, %s)' %(return_type,','.join(kw)) )\n            elif return_type_keywords:\n                writer.write('@returns(%s)' %','.join( ['%s=%s' %(k,v) for k,v in return_type_keywords.items()] ))\n            else:\n                writer.write('@returns(%s)' %return_type)\n\n        ## apply decorators ##\n        for decorator in decorators:\n            writer.write('@%s' %self.visit(decorator))\n\n\n        if self._with_go or self._with_rust or self._with_cpp:  ## pass-thru unchanged to next stage\n            args = []\n            offset = len(node.args.args) - len(node.args.defaults)\n            for i, arg in enumerate(node.args.args):\n                a = arg.id\n                dindex = i - offset\n                if dindex \n= 0 and node.args.defaults:\n                    ## try to infer type from named param default,\n                    ## this way the user can simply write `def f(a=0)`\n                    ## rather than `def f(a:int=0)`\n                    default_node = node.args.defaults[dindex]\n                    if a not in node._typed_args:\n                        if isinstance(default_node, ast.Num):\n                            if str(default_node.n).isdigit():\n                                node._typed_args[a] = 'int'\n                            else:\n                                node._typed_args[a] = 'float'  ## default to 32 or 64 bit float?\n                            writer.write('@__typedef__(%s=\n%s\n)' %(a, node._typed_args[a]))\n                        elif isinstance(default_node, ast.Str):\n                            node._typed_args[a] = 'string'\n                            writer.write('@__typedef__(%s=\n%s\n)' %(a, node._typed_args[a]))\n\n                    default = self.visit(default_node)\n                    args.append( '%s=%s' %(a, default))\n                else:\n                    args.append( a )\n\n            if node.args.vararg: args.append( '*%s' %node.args.vararg )\n            writer.write( 'def %s( %s ):' % (node.name, ','.join(args)) )\n\n\n        elif self._with_js or javascript or self._with_ll:\n\n            kwargs_name = node.args.kwarg or '_kwargs_'\n\n            args = []\n            offset = len(node.args.args) - len(node.args.defaults)\n            for i, arg in enumerate(node.args.args):\n                a = arg.id\n                dindex = i - offset\n                if dindex \n= 0 and node.args.defaults:\n                    pass\n                else:\n                    args.append( a )\n\n            if node.args.vararg:\n                if len(node.args.defaults) or node.args.kwarg:\n                    if args:\n                        writer.write( 'def %s( %s, %s, *%s ):' % (node.name, ','.join(args), kwargs_name, node.args.vararg))\n                    else:\n                        writer.write( 'def %s( %s, *%s ):' % (node.name, kwargs_name, node.args.vararg))\n                elif args:\n                    writer.write( 'def %s( %s, *%s ):' % (node.name, ','.join(args), node.args.vararg))\n                else:\n                    writer.write( 'def %s( *%s ):' % (node.name, node.args.vararg))\n            elif len(node.args.defaults) or node.args.kwarg:\n                if args:\n                    writer.write( 'def %s( %s, %s ):' % (node.name, ','.join(args), kwargs_name ) )\n                else:\n                    writer.write( 'def %s( %s ):' % (node.name, kwargs_name) )\n            else:\n                writer.write( 'def %s( %s ):' % (node.name, ','.join(args)) )\n\n        else:\n            if len(node.args.defaults) or node.args.kwarg or len(node.args.args) or node.args.vararg:\n                writer.write('def %s(args, kwargs):' % node.name)\n            else:\n                writer.write('def %s():' % node.name)\n\n        writer.push()\n\n        ## write local typedefs and var scope ##\n        a = ','.join( vars )\n        if local_typedefs:\n            if a: a += ','\n            a += ','.join(local_typedefs)\n        writer.write('var(%s)' %a)\n\n        #####################################################################\n        if self._with_go or self._with_rust or self._with_cpp:\n            pass\n\n        elif (self._with_js or javascript or self._with_ll):\n            if node.args.defaults:\n                if not self._fast_js:\n                    ## this trys to recover when called in a bad way,\n                    ## however, this could be dangerous because the program\n                    ## should fail if a function is called this badly.\n                    kwargs_name = node.args.kwarg or '_kwargs_'\n                    lines = [ 'if (!( %s instanceof Object )) {' %kwargs_name ]\n                    a = ','.join( ['%s: arguments[%s]' %(arg.id, i) for i,arg in enumerate(node.args.args)] )\n                    lines.append( 'var %s = {%s}' %(kwargs_name, a))\n                    lines.append( '}')\n                    for a in lines:\n                        writer.write(\ninline('''%s''')\n %a)\n\n                offset = len(node.args.args) - len(node.args.defaults)\n\n                maxlen = 0\n                maxlen2 = 0\n                for i, arg in enumerate(node.args.args):\n                    dindex = i - offset\n                    if dindex \n= 0:\n                        dval = self.visit( node.args.defaults[dindex] )\n\n                        if len(arg.id) \n maxlen:\n                            maxlen = len(arg.id)\n\n                        if len(dval) \n maxlen2:\n                            maxlen2 = len(dval)\n\n\n                for i, arg in enumerate(node.args.args):\n                    dindex = i - offset\n                    if dindex \n= 0:\n                        default_value = self.visit( node.args.defaults[dindex] )\n                        #a = (kwargs_name, kwargs_name, arg.id, arg.id, default_value, arg.id, kwargs_name, arg.id)\n                        #b = \nif (%s === undefined || %s.%s === undefined) {var %s = %s} else {var %s=%s.%s}\n %a\n                        spaces = ' ' * (maxlen - len(arg.id))\n                        spaces2 = ' ' * (maxlen2 - len(default_value))\n\n                        ## this is fast, but fails in the case where the user has called a function that takes\n                        ## named keyword args, and called it without giving those keyword names. This case can\n                        ## easily popup when the user has refactored the function to use named keyword args,\n                        ## but did not update all code that calls that function.\n                        #a = (arg.id, spaces, kwargs_name, kwargs_name,arg.id, spaces, default_value, spaces2, kwargs_name, arg.id)\n                        #b = \nvar %s %s= (%s === undefined || %s.%s === undefined)%s?\\t%s %s: %s.%s\n %a\n\n                        ## new version throws a runtime error if the function was called improperly.\n                        ERR = 'function `%s` requires named keyword arguments, invalid parameter for `%s`' %(node.name, arg.id)\n                        a = (arg.id, spaces, kwargs_name, kwargs_name, kwargs_name,arg.id, spaces, default_value, spaces2, kwargs_name, kwargs_name, arg.id,ERR)\n                        b = \nvar %s %s= (%s===undefined || (typeof(%s)=='object' \n %s.%s===undefined))%s?\\t%s %s:   typeof(%s)=='object'?%s.%s: __invalid_call__('%s',arguments)\n %a\n\n                        c = \ninline('''%s''')\n %b\n                        writer.write( c )\n\n\n        ################# function body #################\n\n\n        if threaded and is_worker_entry:  ## DEPRECATED - TODO REMOVE\n            for i,arg in enumerate(node.args.args):\n                writer.write( '%s = __webworker_wrap(%s, %s)' %(arg.id, arg.id, i))\n                writer.write('__wargs__.push(%s)'%arg.id)\n\n\n        self._return_type = None # tries to catch a return type in visit_Return\n\n        ## write function body ##\n        ## if sleep() is called or a new webworker is started, the following function body must be wrapped in\n        ## a closure callback and called later by setTimeout\n        timeouts = []\n        #continues = []\n        for b in node.body:\n\n            if self._use_threading and isinstance(b, ast.Assign) and isinstance(b.value, ast.Call):  ## DEPRECATED - TODO REMOVE\n                if isinstance(b.value.func, ast.Attribute) and isinstance(b.value.func.value, Name) and b.value.func.value.id == 'threading':\n                    if b.value.func.attr == 'start_new_thread':\n                        self.visit(b)\n                        writer.write('__run__ = True')\n                        writer.write('def __callback%s():' %len(timeouts))\n                        writer.push()\n                        ## workerjs for nodejs requires at least 100ms to initalize onmessage/postMessage\n                        timeouts.append(0.2)\n                        continue\n                    elif b.value.func.attr == 'start_webworker':\n                        self.visit(b)\n                        writer.write('__run__ = True')\n                        writer.write('def __callback%s():' %len(timeouts))\n                        writer.push()\n                        ## workerjs for nodejs requires at least 100ms to initalize onmessage/postMessage\n                        timeouts.append(0.2)\n                        continue\n\n                elif self._with_webworker and isinstance(b, ast.Assign) and isinstance(b.value, ast.Call) and isinstance(b.value.func, ast.Name) and b.value.func.id in self._global_functions:\n                    #assert b.value.calling_from_worker\n                    #raise SyntaxError(b)\n                    self.visit(b)\n                    writer.write('def __blocking( %s ):' %self.visit(b.targets[0]))\n                    writer.push()\n                    timeouts.append('BLOCKING')\n                    continue\n\n\n            elif self._use_sleep:\n                c = b\n                if isinstance(b, ast.Expr):\n                    b = b.value\n\n                if isinstance(b, ast.Call) and isinstance(b.func, ast.Name) and b.func.id == 'sleep':\n                    writer.write('__run__ = True')\n                    writer.write('def __callback%s():' %len(timeouts))\n                    writer.push()\n                    timeouts.append( self.visit(b.args[0]) )\n                    continue\n\n                elif isinstance(b, ast.While):  ## TODO\n                    has_sleep = False\n                    for bb in b.body:\n                        if isinstance(bb, ast.Expr):\n                            bb = bb.value\n                        if isinstance(bb, ast.Call) and isinstance(bb.func, ast.Name) and bb.func.id == 'sleep':\n                            has_sleep = float(self.visit(bb.args[0]))\n\n                    if has_sleep \n 0.0:\n                        has_sleep = int(has_sleep*1000)\n                        #writer.write('__run_while__ = True')\n                        writer.write('__continue__ = True')\n                        writer.write('def __while():')\n                        writer.push()\n\n                        for bb in b.body:\n                            if isinstance(bb, ast.Expr):\n                                bb = bb.value\n                            if isinstance(bb, ast.Call) and isinstance(bb.func, ast.Name) and bb.func.id == 'sleep':\n                                continue\n                                #TODO - split body and generate new callback - now sleep is only valid at the end of the while loop\n\n                            else:\n                                e = self.visit(bb)\n                                if e: writer.write( e )\n\n                        writer.write( 'if %s: __run_while__ = True' %self.visit(b.test))\n                        writer.write( 'else: __run_while__ = False')\n\n                        writer.write('if __run_while__: setTimeout(__while, %s)' %(has_sleep))\n                        writer.write('elif __continue__: setTimeout(__callback%s, 0)' %len(timeouts))\n\n                        writer.pull()\n\n                        writer.write('setTimeout(__while, 0)')\n                        writer.write('__run__ = True')\n                        writer.write('def __callback%s():' %len(timeouts))\n                        writer.push()\n                        timeouts.append(None)\n                        continue\n\n                    else:\n                        self.visit(b)\n\n                    continue\n\n                b = c  ## replace orig b\n\n            self.visit(b)\n\n        i = len(timeouts)-1\n        while timeouts:\n            ms = timeouts.pop()\n            if ms == 'BLOCKING':\n                writer.write(   'threading._blocking_callback = None')\n                writer.pull()\n                writer.write('threading._blocking_callback = __blocking')\n            elif ms is not None:\n                writer.pull()\n\n                ms = float(ms)\n                ms *= 1000\n                writer.write('if __run__: setTimeout(__callback%s, %s)' %(i, ms))\n                writer.write('elif __continue__: setTimeout(__callback%s, %s)' %(i+1, ms))\n            i -= 1\n\n        if self._return_type:       ## check if a return type was caught\n            if return_type:\n                assert return_type == self._return_type\n            else:\n                return_type = self._return_type\n            self._function_return_types[ node.name ] = self._return_type\n        self._return_type = None\n\n\n        ############################################################\n        ### DEPRECATED\n        if setter and 'set' in self._injector:  ## inject extra code\n            value_name = node.args.args[1].id\n            inject = [\n                'if self.property_callbacks[\n%s\n]:' %prop_name,\n                'self.property_callbacks[\n%s\n]([\n%s\n, %s, self], JSObject())' %(prop_name, prop_name, value_name)\n            ]\n            writer.write( ' '.join(inject) )\n\n        elif self._injector and node.original_name == '__init__':\n            if 'set' in self._injector:\n                writer.write( 'self.property_callbacks = JSObject()' )\n            if 'init' in self._injector:\n                writer.write('if self.__class__.init_callbacks.length:')\n                writer.push()\n                writer.write('for callback in self.__class__.init_callbacks:')\n                writer.push()\n                writer.write('callback( [self], JSObject() )')\n                writer.pull()\n                writer.pull()\n        ############################################################\n\n        writer.pull()  ## end function body\n\n        self._typedef_vars = dict()  ## clear typed variables\n\n        if self._in_js_class:  ## used when making multiple output javascripts, like main.js and webworker.js\n            #writer = writer_main\n            return\n\n\n        types = []\n        for x in zip(node.args.args[-len(node.args.defaults):], node.args.defaults):\n            key = x[0]\n            value = x[1]\n            if isinstance(value, ast.Name):\n                value = value.id\n            else:\n                value = type(value).__name__.lower()\n            types.append( '%s : \n%s\n' %(self.visit(key), value) )\n\n\n        if self._introspective_functions:\n            ## note, in javascript function.name is a non-standard readonly attribute,\n            ## the compiler creates anonymous functions with name set to an empty string.\n            writer.write('%s.NAME = \n%s\n' %(node.name,node.name))\n\n            writer.write( '%s.args_signature = [%s]' %(node.name, ','.join(['\n%s\n'%n.id for n in node.args.args])) )\n            defaults = ['%s:%s'%(self.visit(x[0]), self.visit(x[1])) for x in zip(node.args.args[-len(node.args.defaults):], node.args.defaults) ]\n            writer.write( '%s.kwargs_signature = {%s}' %(node.name, ','.join(defaults)) )\n            writer.write( '%s.types_signature = {%s}' %(node.name, ','.join(types)) )\n\n            if return_type:\n                writer.write('%s.return_type = \n%s\n'%(node.name, return_type))\n\n\n\n    #################### loops ###################\n    ## the old-style for loop that puts a while loop inside a try/except and catches StopIteration,\n    ## has a problem because at runtime if there is an error inside the loop, it will not show up in a strack trace,\n    ## the error is slient.  FAST_FOR is safer and faster, although it is not strictly Python because in standard\n    ## Python a list is allowed to grow or string while looping over it.  FAST_FOR only deals with a fixed size thing to loop over.\n    FAST_FOR = True\n\n    def visit_Continue(self, node):\n        if self._with_js:\n            writer.write('continue')\n        else:\n            writer.write('continue')\n        return ''\n\n    def visit_Break(self, node):\n        if self._in_loop_with_else:\n            writer.write('__break__ = True')\n        writer.write('break')\n\n    def visit_For(self, node):\n        if node.orelse:\n            raise SyntaxError( self.format_error('the syntax for/else is deprecated') )\n\n\n        if self._with_go:\n            writer.write( 'for %s in %s:' %(self.visit(node.target), self.visit(node.iter)) )\n            writer.push()\n            map(self.visit, node.body)\n            writer.pull()\n            return None\n\n        if self._with_rpc_name and isinstance(node.iter, ast.Attribute) and isinstance(node.iter.value, ast.Name) and node.iter.value.id == self._with_rpc_name:\n            target = self.visit(node.target)\n            writer.write('def __rpc_loop__():')\n            writer.push()\n            writer.write(   '%s = __rpc_iter__(%s, \n%s\n)' %(target, self._with_rpc, node.iter.attr) )\n            writer.write(   'if %s == \n__STOP_ITERATION__\n: __continue__()' %target)\n            writer.write(   'else:')\n            writer.push()\n            map(                self.visit, node.body )\n            writer.write(       '__rpc_loop__()')\n            writer.pull()\n            writer.pull()\n            writer.write('__rpc_loop__()')\n\n            writer.write('def __continue__():')  ## because this def comes after, it needs to be `hoisted` up by the javascript VM\n            writer.push()\n            return None\n\n\n        iterid = self._iter_ids\n        self._iter_ids += 1\n\n        target = node.target\n        enumtar = None\n        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, Name) and node.iter.func.id == 'enumerate':\n            iter = node.iter.args[0]\n            if isinstance(target, ast.Tuple):\n                enumtar = target.elts[0]\n                target = target.elts[1]\n            else:\n                raise SyntaxError('for enumerate loop, requires unpacking to a: index,value pair')\n        else:\n            iter = node.iter\n\n        if enumtar:\n            writer.write('var(%s)'%enumtar.id)\n            writer.write('%s = 0' %enumtar.id)\n\n        vars = []\n        multi_target = []\n\n        if isinstance(target, ast.Tuple):\n            vars.append( '__mtarget__%s' %iterid)\n            for elt in target.elts:\n                if isinstance(elt, ast.Name):\n                    multi_target.append( elt.id )\n                    vars.append( elt.id )\n                else:\n                    raise NotImplementedError('unknown iterator sub-target type: %s'%target)\n        elif isinstance(target, ast.Name):\n            vars.append( target.id )\n        else:\n            raise NotImplementedError('unknown iterator target type: %s'%target)\n\n\n        if self._with_ll or self._with_cpp or self._with_rust or self._with_go:\n            writer.write('for %s in %s:' %(self.visit(target), self.visit(iter)))\n            writer.push()\n            map(self.visit, node.body)\n            writer.pull()\n\n        elif self._with_js:\n            if isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in ('range','xrange'):\n                iter_start = '0'\n                if len(iter.args) == 2:\n                    iter_start = self.visit(iter.args[0])\n                    iter_end = self.visit(iter.args[1])\n                else:\n                    iter_end = self.visit(iter.args[0])\n\n                iter_name = target.id\n\n                writer.write('inline(\n/*for var in range*/\n)')\n\n                writer.write('var(%s)' %iter_name)\n                if iter_start == '0':\n                    writer.write('%s = -1' %iter_name)\n                else:\n                    writer.write('%s = %s-1' %(iter_name, iter_start))\n                if '(' in iter_end:  ## if its a function call, cache it to a variable\n                    writer.write('var(%s__end__)' %iter_name)\n                    writer.write('%s__end__ = %s' %(iter_name, iter_end))\n                    writer.write('while inline(\n++%s\n) \n %s__end__:' %(iter_name, iter_name))\n                else:\n                    writer.write('while inline(\n++%s\n) \n %s:' %(iter_name, iter_end))\n\n                writer.push()\n                map(self.visit, node.body)\n\n                if self._with_js:\n                    #writer.write('inline(\n%s += 1\n)' %iter_name )\n                    if enumtar:\n                        writer.write('inline(\n%s += 1\n)'%enumtar.id)\n                else:\n                    #writer.write('%s += 1' %iter_name )\n                    if enumtar:\n                        writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n\n            elif isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in self._generator_functions:\n                iter_name = self.visit(target)\n                writer.write('var(%s, __generator__%s)' %(iter_name,iterid))\n                writer.write('__generator__%s = %s' %(iterid,self.visit(iter)))\n                writer.write('while __generator__%s.__done__ != 1:'%iterid)\n                writer.push()\n                writer.write('%s = __generator__%s.next()'%(iter_name,iterid))\n                map(self.visit, node.body)\n                writer.pull()\n\n            else:\n                if multi_target:\n                    writer.write('var(%s)' % ','.join(vars))\n                    writer.write('for __mtarget__%s in %s:' %(iterid,self.visit(iter)))\n                    writer.push()\n                    for i,elt in enumerate(multi_target):\n                        writer.write('%s = __mtarget__%s[%s]' %(elt,iterid,i))\n\n                else:\n                    a = self.visit(target)\n                    self._in_assign_target = True\n                    b = self.visit(iter)\n                    self._in_assign_target = False\n                    writer.write('for %s in %s:' %(a, b))\n                    writer.push()\n\n\n                map(self.visit, node.body)\n\n                if enumtar:\n                    writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n        else:\n\n            ## TODO else remove node.target.id from self._instances\n            if isinstance(iter, Name) and iter.id in self._global_typed_lists:\n                self._instances[ target.id ] = list( self._global_typed_lists[ iter.id ] )[0]\n\n\n            vars.append('__iterator__%s'%iterid)\n            if not self._with_coffee:\n                writer.write('var(%s)' % ','.join(vars))\n\n\n            is_range = False\n            is_generator = False\n            iter_start = '0'\n            iter_end = None\n            if self.FAST_FOR and isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in ('range','xrange'):\n                is_range = True\n                if len(iter.args) == 2:\n                    iter_start = self.visit(iter.args[0])\n                    iter_end = self.visit(iter.args[1])\n                else:\n                    iter_end = self.visit(iter.args[0])\n\n            elif isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in self._generator_functions:\n                is_generator = True\n            else:\n                if hasattr(node, 'lineno'):\n                    src = self._source[ node.lineno-1 ]\n                    src = src.replace('\n', '\\\\\n')\n                    err = 'no iterator - line %s: %s'   %(node.lineno, src.strip())\n                    writer.write('__iterator__%s = __get__(__get__(%s, \n__iter__\n, \n%s\n), \n__call__\n)([], __NULL_OBJECT__)' %(iterid, self.visit(iter), err))\n\n                else:\n                    writer.write('__iterator__%s = __get__(__get__(%s, \n__iter__\n), \n__call__\n)([], __NULL_OBJECT__)' %(iterid, self.visit(iter)))\n\n            if is_generator:\n                iter_name = self.visit(target)\n                if not self._with_coffee:\n                    writer.write('var(%s, __generator__%s)' %(iter_name, iterid))\n                writer.write('__generator__%s = %s' %(iterid,self.visit(iter)))\n                writer.write('while __generator__%s.__done__ != 1:'%iterid)\n                writer.push()\n                writer.write('%s = __generator__%s.next()'%(iter_name,iterid))\n                map(self.visit, node.body)\n                writer.pull()\n\n\n            elif is_range:\n                iter_name = target.id\n                if not self._with_coffee:\n                    writer.write('var(%s, %s__end__)' %(iter_name, iter_name))\n                writer.write('%s = %s' %(iter_name, iter_start))\n                writer.write('%s__end__ = %s' %(iter_name, iter_end))   ## assign to a temp variable.\n                #writer.write('while %s \n %s:' %(iter_name, iter_end))  ## this fails with the ternary __add_op\n                writer.write('while %s \n %s__end__:' %(iter_name, iter_name))\n\n                writer.push()\n                map(self.visit, node.body)\n                writer.write('%s += 1' %iter_name )\n\n                if enumtar:\n                    writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n            else:\n                if not self._with_coffee:\n                    writer.write('var(__next__%s)'%iterid)\n                writer.write('__next__%s = __get__(__iterator__%s, \nnext\n)'%(iterid,iterid))\n                writer.write('while __iterator__%s.index \n __iterator__%s.length:'%(iterid,iterid))\n\n                writer.push()\n\n                if multi_target:\n                    writer.write('__mtarget__%s = __next__%s()'%(iterid, iterid))\n                    for i,elt in enumerate(multi_target):\n                        writer.write('%s = __mtarget__%s[%s]' %(elt,iterid,i))\n                else:\n                    writer.write('%s = __next__%s()' %(target.id, iterid))\n\n                map(self.visit, node.body)\n\n                if enumtar:\n                    writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n\n            return ''\n\n    _call_ids = 0\n    def visit_While(self, node):\n        if self._cache_while_body_calls:  ## TODO add option for this\n            for n in node.body:\n                calls = collect_calls(n)\n                for c in calls:\n                    if isinstance(c.func, ast.Name):  ## these are constant for sure\n                        i = self._call_ids\n                        writer.write( '__call__%s = __get__(%s,\n__call__\n)' %(i,self.visit(c.func)) )\n                        c.func.id = '__call__%s'%i\n                        c.constant = True\n                        self._call_ids += 1\n\n        if node.orelse:\n            raise SyntaxError( self.format_error('while/else loop is not allowed') )\n            self._in_loop_with_else = True\n            writer.write('var(__break__)')\n            writer.write('__break__ = False')\n\n        self._in_while_test = True\n        writer.write('while %s:' % self.visit(node.test))\n        self._in_while_test = False\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n\n        if node.orelse:\n            self._in_loop_with_else = False\n            writer.write('if __break__ == False:')\n            writer.push()\n            map(self.visit, node.orelse)\n            writer.pull()\n\n    def visit_With(self, node):\n        global writer\n\n        if isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'rpc':\n            self._with_rpc = self.visit( node.context_expr.args[0] )\n            if isinstance(node.optional_vars, ast.Name):\n                self._with_rpc_name = node.optional_vars.id\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            self._with_rpc = None\n            self._with_rpc_name = None\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'webworker':\n            self._with_webworker = True\n            writer = get_webworker_writer( 'worker.js' )\n\n            #writer.write('if typeof(require) != \nundefined\n: requirejs = require')  ## compatible with nodewebkit\n            #writer.write('else: importScripts(\nrequire.js\n)')\n\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            self._with_webworker = False\n            writer = writer_main\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'lowlevel':\n            self._with_ll = True\n            #map(self.visit, node.body)\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            self._with_ll = False\n\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'atomic':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'static':\n            raise RuntimeError('with static: is reserved for future use')\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id in EXTRA_WITH_TYPES:\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id in EXTRA_WITH_TYPES:\n            if node.context_expr.keywords:\n                assert len(node.context_expr.keywords)==1\n                k = node.context_expr.keywords[0].arg\n                v = self.visit(node.context_expr.keywords[0].value)\n                a = 'with %s(%s=%s):' %( self.visit(node.context_expr.func), k,v )\n                writer.write(a)\n            else:\n                writer.write('with %s:' %self.visit(node.context_expr))\n\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'asm':\n            asmcode = []\n            for b in node.body:\n                asmcode.append( b.value.s )\n            args = [ 'code=\n%s\n' % ''.join(asmcode) ]\n            for kw in node.context_expr.keywords:\n                args.append( '%s=%s' %(kw.arg, self.visit(kw.value)) )\n            asm = '__asm__( %s )' %(','.join(args))\n            writer.write( asm )\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'extern':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n        elif isinstance( node.context_expr, ast.Str):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance(node.context_expr, ast.Name) and node.context_expr.id=='syntax':\n            if isinstance(node.optional_vars, ast.Name):\n                writer.write('with syntax(%s):' %self._autotyped_dicts[node.optional_vars.id])\n            else:\n                writer.write('with syntax(%s):' %self.visit(node.optional_vars))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance(node.context_expr, ast.Name) and node.context_expr.id.startswith('return_'):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id.startswith('return_'):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n        elif self.visit( node.context_expr ).startswith('return_'):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'syntax':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'timeout':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'chain_then':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'macro':\n            if isinstance(node.context_expr.args[0], ast.Str):\n                writer.write('with %s:' %self.visit(node.context_expr))\n            else:  ## force macro as string\n                writer.write('with macro(\n%s\n):' %self.visit(node.context_expr.args[0]))\n\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n\n        elif isinstance(node.context_expr, ast.Name) or isinstance(node.context_expr, ast.Tuple):  ## assume that backend can support this\n            #if isinstance(node.optional_vars, ast.Subscript) and isinstance(node.optional_vars.slice, ast.Index):\n            if node.optional_vars:\n                writer.write('with %s as %s:' %(self.visit(node.context_expr), self.visit(node.optional_vars)))\n            else:\n                writer.write('with %s:' %self.visit(node.context_expr))\n\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance(node.context_expr, ast.BoolOp) and isinstance(node.context_expr.op, ast.And):\n            writer.write('with [%s] as future:' % ','.join( [self.visit(f) for f in node.context_expr.values] ))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        else:\n            #raise SyntaxError('invalid use of \nwith\n statement: %s' %self.visit(node.context_expr))\n            raise SyntaxError('invalid use of \nwith\n statement: %s' %node.context_expr)\n\nEXTRA_WITH_TYPES = ('__switch__', '__default__', '__case__', '__select__')\n\n\n\n\n\nclass CollectCalls(NodeVisitor):\n    _calls_ = []\n    def visit_Call(self, node):\n        self._calls_.append( node )\n\ndef collect_calls(node):\n    CollectCalls._calls_ = calls = []\n    CollectCalls().visit( node )\n    return calls\n\n\nclass CollectDictComprehensions(NodeVisitor):\n    _comps_ = []\n    def visit_GeneratorExp(self,node):\n        self._comps_.append( node )\n        self.visit( node.elt )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n    def visit_DictComp(self, node):\n        self._comps_.append( node )\n        self.visit( node.key )\n        self.visit( node.value )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n\ndef collect_dict_comprehensions(node):\n    CollectDictComprehensions._comps_ = comps = []\n    CollectDictComprehensions().visit( node )\n    return comps\n\n\nclass CollectComprehensions(NodeVisitor):\n    _comps_ = []\n    def visit_GeneratorExp(self,node):\n        self._comps_.append( node )\n        self.visit( node.elt )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n    def visit_ListComp(self, node):\n        self._comps_.append( node )\n        self.visit( node.elt )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n\ndef collect_comprehensions(node):\n    CollectComprehensions._comps_ = comps = []\n    CollectComprehensions().visit( node )\n    return comps\n\nclass CollectGenFuncs(NodeVisitor):\n    _funcs = []\n    _genfuncs = []\n    def visit_FunctionDef(self, node):\n        self._funcs.append( node )\n        node._yields = []\n        node._loops = []\n        for b in node.body:\n            self.visit(b)\n        self._funcs.pop()\n\n    def visit_Yield(self, node):\n        func = self._funcs[-1]\n        func._yields.append( node )\n        if func not in self._genfuncs:\n            self._genfuncs.append( func )\n\n    def visit_For(self, node):\n        if len(self._funcs):\n            self._funcs[-1]._loops.append( node )\n        for b in node.body:\n            self.visit(b)\n\n    def visit_While(self, node):\n        if len(self._funcs):\n            self._funcs[-1]._loops.append( node )\n        for b in node.body:\n            self.visit(b)\n\n\ndef collect_generator_functions(node):\n    CollectGenFuncs._funcs = []\n    CollectGenFuncs._genfuncs = gfuncs = []\n    CollectGenFuncs().visit( node )\n    return gfuncs\n\n\n\ndef python_to_pythonjs(script, **kwargs):\n    translator = PythonToPythonJS(\n        source = script,\n        **kwargs\n    )\n\n    code = writer.getvalue()\n\n    if translator.has_webworkers():\n        userimports = ['\n%s\n'%imp for imp in translator.get_webworker_imports()]\n        pre = [\n            '__workerimports__ = [%s]' %','.join(userimports),\n            #'__workerpool__ = new(__WorkerPool__(__workersrc__, __workerimports__))',\n            'inline(\nvar \u2ca2\u2c91\u2c91\u2c92 = new __WorkerPool__(__workersrc__, __workerimports__)\n)',\n            ''\n        ]\n        code = '\\n'.join(pre) + code\n        res = {'main':code}\n        for jsfile in translator.get_webworker_file_names():\n            res[ jsfile ] = get_webworker_writer( jsfile ).getvalue()\n        return res\n    else:\n        if '--debug' in sys.argv:\n            try:\n                open('/tmp/python-to-pythonjs.debug.py', 'wb').write(code)\n            except:\n                pass\n        return code", 
            "title": "PreTranslator"
        }, 
        {
            "location": "/intermediateform/#python-to-intermediate-form", 
            "text": "by Amirouche Boubekki and Brett Hartshorn - copyright 2013\nLicense: \"New BSD\"   @import fakestdlib.md   \n\nimport os, sys, copy\nfrom types import GeneratorType\n\nimport ast\nfrom ast import Str\nfrom ast import Call\nfrom ast import Name\nfrom ast import Tuple\nfrom ast import Assign\nfrom ast import keyword\nfrom ast import Subscript\nfrom ast import Attribute\nfrom ast import FunctionDef\nfrom ast import BinOp\nfrom ast import Pass\nfrom ast import Global\nfrom ast import With\n\nfrom ast import parse\nfrom ast import NodeVisitor\n\n\n\nPOWER_OF_TWO = [ 2**i for i in range(32) ]\n\nwriter = writer_main = CodeWriter()\n\n__webworker_writers = dict()\ndef get_webworker_writer( jsfile ):\n    if jsfile not in __webworker_writers:\n        __webworker_writers[ jsfile ] = CodeWriter()\n    return __webworker_writers[ jsfile ]\n\n\n\nclass Typedef(object):\n    # http://docs.python.org/2/reference/datamodel.html#emulating-numeric-types\n    _opmap = dict(\n        __add__ = '+',\n        __iadd__ = '+=',\n        __sub__ = '-',\n        __isub__ = '-=',\n        __mul__ = '*',\n        __imul__ = '*=',\n        __div__ = '/',\n        __idiv__ = '/=',\n        __mod__ = '%',\n        __imod__ = '%=',\n        __lshift__ = ' ',\n        __ilshift__ = ' =',\n        __rshift__ = ' ',\n        __irshift__ = ' =',\n        __and__ = ' ',\n        __iand__ = ' =',\n        __xor__ = '^',\n        __ixor__ = '^=',\n        __or__ = '|',\n        __ior__ = '|=',\n    )\n\n    def __init__(self, **kwargs):\n        for name in kwargs.keys():  ## name, methods, properties, attributes, class_attributes, parents\n            setattr( self, name, kwargs[name] )\n\n        self.operators = dict()\n        for name in self.methods:\n            if name in self._opmap:\n                op = self._opmap[ name ]\n                self.operators[ op ] = self.get_pythonjs_function_name( name )\n\n    def get_pythonjs_function_name(self, name):\n        assert name in self.methods\n        return '__%s_%s' %(self.name, name) ## class name\n\n    def check_for_parent_with(self, method=None, property=None, operator=None, class_attribute=None):\n\n        for parent_name in self.parents:\n            if not self.compiler.is_known_class_name( parent_name ):\n                continue\n\n            typedef = self.compiler.get_typedef( class_name=parent_name )\n            if method and method in typedef.methods:\n                return typedef\n            elif property and property in typedef.properties:\n                return typedef\n            elif operator and typedef.operators:\n                return typedef\n            elif class_attribute in typedef.class_attributes:\n                return typedef\n            elif typedef.parents:\n                res = typedef.check_for_parent_with(\n                    method=method, \n                    property=property, \n                    operator=operator,\n                    class_attribute=class_attribute\n                )\n                if res:\n                    return res\n\n\n\n\nclass PythonToPythonJS(NodeVisitorBase):\n\n    identifier = 0  ## clean up\n    _func_typedefs = ()  ## TODO clean up\n\n    def __init__(self, source=None, modules=False, module_path=None, dart=False, coffee=False, go=False, rust=False, cpp=False, fast_javascript=False, pure_javascript=False):\n        #super(PythonToPythonJS, self).__init__()\n        NodeVisitorBase.__init__(self, source)  ## note self._source gets changed below\n\n        ## lowlevel is code within a `with lowlevel:` block\n        ## this is used to define some builtin methods for each backend,\n        ## where the user wants the most direct translation possible to\n        ## the target backend.  This is only for special cases.\n        self._with_ll = False   ## lowlevel\n\n        self._modules = modules          ## split into mutiple files by class\n        self._module_path = module_path  ## used for user `from xxx import *` to load .py files in the same directory.\n        self._with_coffee = coffee\n        self._with_dart = dart\n        self._with_go = go\n        self._with_gojs = False\n        self._with_rust = rust\n        self._with_cpp = cpp\n        self._fast_js = fast_javascript\n        self._strict_mode = pure_javascript\n\n        ## TODO _with_js should be renamed to _with_restricted_python, or _with_rpy.\n        ## originally this option was only used to switch modes from the original\n        ## full python mode to the faster more restricted python mode.\n        ## The older full python mode requires a backend that is very dynamic, like: javascript or lua\n        ## full python mode maps all calls through a generic `__get__` method that takes care of all\n        ## dynamic mapping at runtime, this basically emulates what CPython is doing in C in a slower VM.\n        ## full python mode also breaks down classes into flat function calls, for backends that do not\n        ## directly support classes like Lua and JavaScript.\n        ## The JavaScript backend now defaults to restricted python mode, because it is much faster,\n        ## and classes are now translated to JavaScript prototypes and constructed by calling new,\n        ## this also provides much better interop with external JS libraries.\n        ## Since restricted python mode became default the new backends: rust and c++ now require that mode,\n        ## and it makes the last stage of translation simpler and more generic.\n        ## However, the Lua backend still requires the old style full python mode, because in Lua classes\n        ## must be fully broken down into flat functions.\n        self._with_js = True\n\n\n        if self._with_rust or self._with_go:\n            self._use_destructured_assignment = True\n        else:\n            self._use_destructured_assignment = False\n\n        self._html_tail = []; script = False\n        if source.strip().startswith(' html'):\n            lines = source.splitlines()\n            for line in lines:\n                if line.strip().startswith(' script'):\n                    if 'type= text/python ' in line:\n                        writer.write( ' script type= text/python ')\n                        script = list()\n                    elif 'src=' in line and '~/' in line:  ## external javascripts installed in users home folder\n                        x = line.split('src= ')[-1].split(' ')[0]\n                        if os.path.isfile(os.path.expanduser(x)):\n                            o = []\n                            o.append( ' script type= text/javascript ' )\n                            if x.lower().endswith('.coffee'):\n                                import subprocess\n                                proc = subprocess.Popen(\n                                    ['coffee','--bare', '--print', os.path.expanduser(x)], \n                                    stdout=subprocess.PIPE\n                                )\n                                o.append( proc.stdout.read() )\n                            else:\n                                o.append( open(os.path.expanduser(x), 'rb').read() )\n                            o.append( ' /script ')\n                            if script is True:\n                                self._html_tail.extend( o )\n                            else:\n                                for y in o:\n                                    writer.write(y)\n\n                    else:\n                        writer.write(line)\n\n                elif line.strip() == ' /script ':\n                    if type(script) is list and len(script):\n                        source = '\\n'.join(script)\n                        script = True\n                        self._html_tail.append( ' /script ')\n                    else:\n                        writer.write( line )\n\n                elif isinstance( script, list ):\n                    script.append( line )\n\n                elif script is True:\n                    self._html_tail.append( line )\n\n                else:\n                    writer.write( line )\n\n        ## preprocess the input source that may contain extended syntax\n        ## that the python AST parser can not deal with.\n        ## note: `transform_source` translates into an intermediate form\n        ## that is python AST compatible.\n        source = typedpython.transform_source( source )\n\n\n        ## optimize  +  and  *  operator, for python syntax like 'a'*3 becomes 'aaa'\n        if fast_javascript:\n            self._direct_operators = set( ['+', '*'] )\n        else:\n            self._direct_operators = set()\n\n        self._in_catch_exception = False\n        self._in_lambda = False\n        self._in_while_test = False\n        self._use_threading = False\n        self._use_sleep = False  ## only for the js backend, makes while loops `sleep` using setTimeOut\n        self._use_array = False\n        self._webworker_functions = dict()\n        self._webworker_imports = list()\n        self._with_webworker = False\n        self._with_rpc = None\n        self._with_rpc_name = None\n        self._with_direct_keys = fast_javascript\n\n        self._with_glsl = False  ## TODO dep\n\n        self._source = source.splitlines()\n        self._class_stack = list()\n        self._classes = dict()    ## class name : [method names]\n        self._class_parents = dict()  ## class name : parents\n        self._instance_attributes = dict()  ## class name : [attribute names]\n        self._class_attributes = dict()\n        self._catch_attributes = None\n        self._typedef_vars = dict()\n\n        #self._names = set() ## not used?\n        ## inferred class instances, TODO regtests to confirm that this never breaks ##\n        self._instances = dict()  ## instance name : class name\n\n        self._decorator_properties = dict()\n        self._decorator_class_props = dict()\n        self._function_return_types = dict()\n        self._return_type = None\n\n\n        self._typedefs = dict()  ## class name : typedef  (deprecated - part of the old static type finder)\n\n        self._globals = dict()\n        self._global_nodes = dict()\n        self._with_static_type = None\n        self._global_typed_lists = dict()  ## global name : set  (if len(set)==1 then we know it is a typed list)\n        self._global_typed_dicts = dict()\n        self._global_typed_tuples = dict()\n        self._global_functions = dict()\n        self._autotyped_dicts  = dict()\n\n        self._js_classes = dict()\n        self._in_js_class = False\n        self._in_assign_target = False\n        self._with_runtime_exceptions = True  ## this is only used in full python mode.\n\n        self._iter_ids = 0\n        self._addop_ids = 0\n\n        self._cache_while_body_calls = False\n        self._comprehensions = []\n        self._generator_functions = set()\n\n        self._in_loop_with_else = False\n        self._introspective_functions = False\n\n        self._custom_operators = {}\n        self._injector = []  ## advanced meta-programming hacks\n        self._in_class = None\n        self._with_fastdef = False\n        self.setup_builtins()\n\n        source = self.preprocess_custom_operators( source )\n        tree = ast.parse( source )\n\n        self._generator_function_nodes = collect_generator_functions( tree )\n\n        for node in tree.body:\n            ## skip module level doc strings ##\n            if isinstance(node, ast.Expr) and isinstance(node.value, ast.Str):\n                pass\n            else:\n                self.visit(node)\n\n        if self._html_tail:\n            for line in self._html_tail:\n                writer.write(line)\n\n    def get_webworker_imports(self):\n        return self._webworker_imports\n\n    def has_webworkers(self):\n        return len(self._webworker_functions.keys())\n\n    def get_webworker_file_names(self):\n        return set(self._webworker_functions.values())\n\n    def preprocess_custom_operators(self, data):\n        '''\n        custom operators must be defined before they are used\n        '''\n        code = []\n        for line in data.splitlines():\n            if line.strip().startswith('@custom_operator'):\n                l = line.replace(' ',  ' )\n                a,b,c = l.split( ' )\n                op = b.decode('utf-8')\n                self._custom_operators[ op ] = None\n            else:\n                for op in self._custom_operators:\n                    op = op.encode('utf-8')\n                    line = line.replace(op, '| %s |'%op)\n\n            code.append( line )\n\n        data = '\\n'.join( code )\n        return data\n\n    def setup_builtins(self):\n        self._classes['dict'] = set(['__getitem__', '__setitem__'])\n        self._classes['list'] = set() #['__getitem__', '__setitem__'])\n        self._classes['tuple'] = set() #['__getitem__', '__setitem__'])\n        self._builtin_classes = set(['dict', 'list', 'tuple'])\n        self._builtin_functions = {\n            'ord':'%s.charCodeAt(0)',\n            'chr':'String.fromCharCode(%s)',\n            'abs':'Math.abs(%s)',\n            'cos':'Math.cos(%s)',\n            'sin':'Math.sin(%s)',\n            'sqrt':'Math.sqrt(%s)'\n        }\n        self._builtin_functions_dart = {\n            'ord':'%s.codeUnitAt(0)',\n            'chr':'new(String.fromCharCode(%s))',\n        }\n\n    def is_known_class_name(self, name):\n        return name in self._classes\n\n    def get_typedef(self, instance=None, class_name=None):\n        assert instance or class_name\n        if isinstance(instance, Name) and instance.id in self._instances:\n            class_name = self._instances[ instance.id ]\n\n        if class_name:\n            #assert class_name in self._classes\n            if class_name not in self._classes:\n                #raise RuntimeError('class name: %s - not found in self._classes - node:%s '%(class_name, instance))\n                return None  ## TODO hook into self._typedef_vars\n\n            if class_name not in self._typedefs:\n                self._typedefs[ class_name ] = Typedef(\n                    name = class_name,\n                    methods = self._classes[ class_name ],\n                    #properties = self._decorator_class_props[ class_name ],\n                    #attributes = self._instance_attributes[ class_name ],\n                    #class_attributes = self._class_attributes[ class_name ],\n                    #parents = self._class_parents[ class_name ],\n                    properties = self._decorator_class_props.get(  class_name, set()),\n                    attributes = self._instance_attributes.get(    class_name, set()),\n                    class_attributes = self._class_attributes.get( class_name, set()),\n                    parents = self._class_parents.get(             class_name, set()),\n\n                    compiler = self,\n                )\n            return self._typedefs[ class_name ]\n\n    def visit_Delete(self, node):\n        writer.write('del %s' %','.join([self.visit(t) for t in node.targets]))\n\n    def visit_Import(self, node):\n        '''\n        fallback to requirejs or if in webworker importScripts.\n        some special modules from pythons stdlib can be faked here like:\n            . threading\n\n        nodejs only:\n            . tornado\n            . os\n\n        '''\n\n        tornado = ['tornado', 'tornado.web', 'tornado.ioloop']\n\n        for alias in node.names:\n            if self._with_go or self._with_rust or self._with_cpp:\n                if alias.asname:\n                    writer.write('import %s as %s' %(alias.name, alias.asname))\n                else:\n                    writer.write('import %s' %alias.name)\n            elif self._with_webworker:\n                self._webworker_imports.append( alias.name )\n            elif alias.name in tornado:\n                pass  ## pythonjs/fakelibs/tornado.py\n            elif alias.name == 'tempfile':\n                pass  ## pythonjs/fakelibs/tempfile.py\n            elif alias.name == 'sys':\n                pass  ## pythonjs/fakelibs/sys.py\n            elif alias.name == 'subprocess':\n                pass  ## pythonjs/fakelibs/subprocess.py\n            elif alias.name == 'numpy':\n                pass\n\n            elif alias.name == 'json' or alias.name == 'os':\n                pass  ## part of builtins.py\n            elif alias.name == 'threading':\n                self._use_threading = True\n                #writer.write( 'Worker = require( /usr/local/lib/node_modules/workerjs )')\n\n                ## note: nodewebkit includes Worker, but only from the main script context,\n                ## there might be a bug in requirejs or nodewebkit where Worker gets lost\n                ## when code is loaded into main as a module using requirejs, as a workaround\n                ## allow  workerjs  to be loaded as a fallback, however this appears to not work in nodewebkit.\n                writer.write( 'if __NODEJS__==True and typeof(Worker)== undefined : Worker = require( workerjs )')\n\n            #elif alias.asname:\n            #   #writer.write( '''inline( var %s = requirejs('%s') )''' %(alias.asname, alias.name) )\n            #   writer.write( '''inline( var %s = require('%s') )''' %(alias.asname, alias.name.replace('__DASH__', '-')) )\n            #elif '.' in alias.name:\n            #   raise NotImplementedError('import with dot not yet supported: line %s' % node.lineno)\n            #else:\n            #   #writer.write( '''inline( var %s = requirejs('%s') )''' %(alias.name, alias.name) )\n            #   writer.write( '''inline( var %s = require('%s') )''' %(alias.name, alias.name) )\n\n            elif alias.asname:\n                writer.write('import %s as %s' %(alias.name, alias.asname))\n            else:\n                writer.write('import %s' %alias.name)\n\n\n    def visit_ImportFrom(self, node):\n        if self._with_go:\n            lib = fakestdlib.GO\n        elif self._with_cpp:\n            lib = fakestdlib.CPP\n        elif self._with_rust:\n            lib = {}\n        else:\n            lib = fakestdlib.JS\n\n        if self._module_path:\n            path = os.path.join( self._module_path, node.module+'.py')\n        else:\n            path = os.path.join( './', node.module+'.py')\n\n        if node.module == 'time' and node.names[0].name == 'sleep':\n            if not (self._with_cpp or self._with_rust or self._with_go or self._with_ll):\n                self._use_sleep = True\n\n        ############################################################\n        if node.module == 'array' and node.names[0].name == 'array':\n            self._use_array = True ## this is just a hint that calls to array call the builtin array\n\n        elif node.module == 'bisect' and node.names[0].name == 'bisect':\n            ## bisect library is part of the stdlib,\n            ## in pythonjs it is a builtin function defined in builtins.py\n            pass\n        elif node.module == '__future__':\n            pass\n\n        elif node.module in lib:\n            imported = False\n            for n in node.names:\n                if n.name in lib[ node.module ]:\n                    if not imported:\n                        imported = True\n                        if fakestdlib.REQUIRES in lib[node.module]:\n                            writer.write('import %s' %','.join(lib[node.module][fakestdlib.REQUIRES]))\n\n                    writer.write( 'inline( %s )' %lib[node.module][n.name] )\n                    if n.name not in self._builtin_functions:\n                        self._builtin_functions[ n.name ] = n.name + '()'\n\n        elif os.path.isfile(path):\n            ## user import `from mymodule import *` TODO support files from other folders\n            ## this creates a sub-translator, because they share the same `writer` object (a global),\n            ## there is no need to call `writer.write` here.\n            ## note: the current pythonjs.configure mode here maybe different from the subcontext.\n            data = open(path, 'rb').read()\n            subtrans = PythonToPythonJS(\n                data,\n                module_path     = self._module_path,\n                fast_javascript = self._fast_js,\n                modules         = self._modules,\n                pure_javascript = self._strict_mode,\n            )\n            self._js_classes.update( subtrans._js_classes ) ## TODO - what other typedef info needs to be copied here?\n\n        elif self._with_rust:  ## allow `import xx` to be translated to `extern crate xx`\n            writer.write('from %s import %s' %(node.module, ','.join([n.name for n in node.names])))\n        elif node.module == 'runtime':\n            writer.write('from runtime import *')\n        elif node.module == 'nodejs':\n            writer.write('from nodejs import *')\n        elif node.module == 'nodejs.tornado':\n            writer.write('from nodejs.tornado import *')\n        elif self._with_js:\n            inames = [n.name for n in node.names]\n            writer.write('from %s import %s' %(node.module, ','.join(inames)))\n        else:\n            msg = 'invalid import - file not found: %s'%path\n            raise SyntaxError( self.format_error(msg) )\n\n    def visit_Assert(self, node):\n        writer.write('assert %s' %self.visit(node.test))\n\n    def visit_Set(self, node):  ## new python3 style `a={1,2,3}`\n        return '{%s}' %','.join([self.visit(elt) for elt in node.elts])\n\n    def visit_Dict(self, node):\n        node.returns_type = 'dict'\n        keytype = None\n        a = []\n        alt = []\n        for i in range( len(node.keys) ):\n            if isinstance(node.keys[i], ast.Num):\n                if type(node.keys[i].n) is int:\n                    if keytype is None:\n                        keytype = 'int'\n                    elif keytype != 'int':\n                        raise SyntaxError(self.format_error('dictionary can not have mixed string and number keys'))\n            elif isinstance(node.keys[i], ast.Str):\n                if keytype is None:\n                    keytype = 'string'\n                elif keytype != 'string':\n                    raise SyntaxError(self.format_error('dictionary can not have mixed string and number keys'))\n\n\n            k = self.visit( node.keys[ i ] )\n            v = node.values[i]\n\n\n            if isinstance(v, ast.Lambda):\n                v.keep_as_lambda = True\n            v = self.visit( v )\n            if self._with_ll or self._with_go or self._with_rust or self._with_cpp:\n                a.append( '%s:%s'%(k,v) )\n            elif self._fast_js:\n                if not isinstance(node.keys[i], ast.Name):\n                    if isinstance(node.keys[i], ast.List):\n                        if len(node.keys[i].elts) != 1:\n                            raise SyntaxError(\n                                self.format_error('JavaScript ES6 Error: computed property name, `[]` wrapper not of length one.')\n                            )\n                        k = self.visit(node.keys[i].elts[0])\n                    alt.append( '[%s, %s]' %(k,v) )\n                else:\n                    a.append( '%s:%s'%(k,v) )\n            elif self._with_js:\n                ## TODO remove this\n                a.append( '[%s,%s]'%(k,v) )\n            else:\n                raise RuntimeError( self.format_error('invalid backend') )\n\n\n        if self._with_ll or self._with_go or self._with_rust or self._with_cpp:\n            b = ','.join( a )\n            return '{%s}' %b\n        elif self._fast_js:\n            b = ','.join( a )\n            opts = '{copy:False,'\n            if keytype is not None:\n                opts += 'keytype: %s ,' %keytype\n            if len(alt):\n                opts += 'iterable:[%s]' %','.join(alt)\n            opts += '}'\n            return 'dict({%s}, %s )' %(b, opts)\n\n        elif self._with_js:  ## DEPRECATED - note: this allowed for python style dict literals\n            b = ','.join( a )\n            return '__jsdict( [%s] )' %b\n        else:\n            raise RuntimeError('dict - unknown backend')\n\n    def visit_Tuple(self, node):\n        node.returns_type = 'tuple'\n        #a = '[%s]' % ', '.join(map(self.visit, node.elts))\n        a = []\n        for e in node.elts:\n            if isinstance(e, ast.Lambda):\n                e.keep_as_lambda = True\n            v = self.visit(e)\n            assert v is not None\n            a.append( v )\n\n        if self._with_rust or self._with_cpp:\n            if len(a)==1:\n                return '(%s,)' % a[0]\n            else:\n                return '(%s)' % ', '.join(a)\n        else:\n            return '[%s]' % ', '.join(a)\n\n    def visit_List(self, node):\n        node.returns_type = 'list'\n\n        a = []\n        for e in node.elts:\n            if isinstance(e, ast.Lambda):  ## inlined and called lambda  (lambda x: x)(y) \n                e.keep_as_lambda = True\n            v = self.visit(e)\n            assert v is not None\n            a.append( v )\n\n        return '[%s]' % ', '.join(a)\n\n    def visit_GeneratorExp(self, node):\n        return self.visit_ListComp(node)\n\n    _comp_id = 0\n\n    def visit_DictComp(self, node):\n        '''\n        node.key is key name\n        node.value is value\n        '''\n        #raise SyntaxError(self.visit(node.key))  ## key, value, generators\n\n        node.returns_type = 'dict'\n\n        if len(self._comprehensions) == 0:\n            comps = collect_dict_comprehensions( node )\n            for i,cnode in enumerate(comps):\n                cname = '__comp__%s' % self._comp_id\n                cnode._comp_name = cname\n                self._comprehensions.append( cnode )\n                self._comp_id += 1\n\n\n        cname = node._comp_name\n        writer.write('var(%s)'%cname)\n\n        length = len( node.generators )\n        a = ['idx%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['iter%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['get%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n\n        if self._with_go:\n            assert node.go_dictcomp_type\n            k,v = node.go_dictcomp_type\n            writer.write('%s = __go__map__(%s, %s) {}' %(cname, k,v))\n        else:\n            writer.write('%s = {}'%cname)\n\n        generators = list( node.generators )\n        generators.reverse()\n        self._gen_comp( generators, node )\n\n        self._comprehensions.remove( node )\n        return cname\n\n\n    def visit_ListComp(self, node):\n        node.returns_type = 'list'\n        if self._with_rust or self._with_cpp:\n            ## pass directly to next translation stage\n            gen = node.generators[0]\n            a = self.visit(node.elt)\n            b = self.visit(gen.target)\n            c = self.visit(gen.iter)\n            return '[%s for %s in %s]' %(a,b,c)\n        else:\n            compname = self._visit_listcomp_helper(node)\n            return compname\n\n    def _visit_listcomp_helper(self, node):\n        ## TODO - move this logic to the next translation stage for each backend.\n        ## TODO - check if there was a bug here, why only when self._comprehensions is zero?\n        #if len(self._comprehensions) == 0 or True:\n        comps = collect_comprehensions( node )\n        assert comps\n        for i,cnode in enumerate(comps):\n            cname = '__comp__%s' % self._comp_id\n            cnode._comp_name = cname\n            self._comprehensions.append( cnode )\n            self._comp_id += 1\n\n        cname = node._comp_name\n        writer.write('var(%s)'%cname)\n        #writer.write('var(__comp__%s)'%self._comp_id)\n\n        length = len( node.generators ) + (len(self._comprehensions)-1)\n        a = ['idx%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['iter%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n        a = ['get%s'%i for i in range(length)]\n        writer.write('var( %s )' %','.join(a) )\n\n        if self._with_go:\n            assert node.go_listcomp_type\n            #writer.write('__comp__%s = __go__array__(%s)' %(self._comp_id, node.go_listcomp_type))\n            writer.write('%s = __go__array__(%s)' %(cname, node.go_listcomp_type))\n        else:\n            writer.write('%s = JSArray()'%cname)\n\n        generators = list( node.generators )\n        generators.reverse()\n        self._gen_comp( generators, node )\n\n        #if node in self._comprehensions:\n        #   self._comprehensions.remove( node )\n\n        if self._with_go:\n            #return '__go__addr__(__comp__%s)' %self._comp_id\n            return '__go__addr__(%s)' %cname\n        else:\n            #return '__comp__%s' %self._comp_id\n            return cname\n\n\n    def _gen_comp(self, generators, node):\n        #self._comp_id += 1\n        #id = self._comp_id\n\n        gen = generators.pop()\n        id = len(generators) + self._comprehensions.index( node )\n        assert isinstance(gen.target, Name)\n        writer.write('idx%s = 0'%id)\n\n        is_range = False\n        if isinstance(gen.iter, ast.Call) and isinstance(gen.iter.func, ast.Name) and gen.iter.func.id in ('range', 'xrange'):\n            is_range = True\n\n            writer.write('iter%s = %s' %(id, self.visit(gen.iter.args[0])) )\n            writer.write('while idx%s   iter%s:' %(id,id) )\n            writer.push()\n\n            writer.write('var(%s)'%gen.target.id)\n            writer.write('%s=idx%s' %(gen.target.id, id) )\n\n        elif self._with_js:  ## only works with arrays in javascript mode\n            writer.write('iter%s = %s' %(id, self.visit(gen.iter)) )\n            writer.write('while idx%s   iter%s.length:' %(id,id) )\n            writer.push()\n            writer.write('var(%s)'%gen.target.id)\n            writer.write('%s=iter%s[idx%s]' %(gen.target.id, id,id) )\n\n        else:\n            raise SyntaxError('deprecated - lua backend')\n\n        if generators:\n            self._gen_comp( generators, node )\n        else:\n            cname = node._comp_name #self._comprehensions[-1]\n            #cname = '__comp__%s' % self._comp_id\n\n            if len(gen.ifs):\n                test = []\n                for compare in gen.ifs:\n                    test.append( self.visit(compare) )\n\n                writer.write('if %s:' %' and '.join(test))\n                writer.push()\n                self._gen_comp_helper(cname, node)\n                writer.pull()\n\n            else:\n                self._gen_comp_helper(cname, node)\n\n        writer.write('idx%s+=1' %id )\n        writer.pull()\n\n    def _gen_comp_helper(self, cname, node):\n        if isinstance(node, ast.DictComp):\n            key = self.visit(node.key)\n            val = self.visit(node.value)\n            if self._with_go:\n                writer.write('%s[ %s ] = %s' %(cname, key, val) )\n            else:\n                writer.write('%s[ %s ] = %s' %(cname, key, val) )\n\n        elif self._with_go:\n            writer.write('%s = append(%s, %s )' %(cname, cname,self.visit(node.elt)) )\n        else:\n            writer.write('%s.push( %s )' %(cname,self.visit(node.elt)) )\n\n    def visit_In(self, node):\n        return ' in '\n\n    def visit_NotIn(self, node):\n        #return ' not in '\n        raise RuntimeError(' not in  is only allowed in if-test: see method - visit_Compare')\n\n    ## TODO check if the default visit_Compare always works ##\n    #def visit_Compare(self, node):\n    #   raise NotImplementedError( node )\n\n\n    def visit_AugAssign(self, node):\n        self._in_assign_target = True\n        target = self.visit( node.target )\n        self._in_assign_target = False\n\n        op = '%s=' %self.visit( node.op )\n\n        if op == '//=':\n            if isinstance(node.target, ast.Attribute):\n                name = self.visit(node.target.value)\n                attr = node.target.attr\n                target = '%s.%s' %(name, attr)\n\n            if self._with_go:\n                a = '%s /= %s' %(target, self.visit(node.value))\n            elif self._with_cpp:\n                a = '%s /= %s' %(target, self.visit(node.value))\n            else:\n                a = '%s = Math.floor(%s/%s)' %(target, target, self.visit(node.value))\n            writer.write(a)\n\n\n        elif self._with_js:  ## no operator overloading in with-js mode\n            a = '%s %s %s' %(target, op, self.visit(node.value))\n            writer.write(a)\n\n        elif isinstance(node.target, ast.Attribute):\n            name = self.visit(node.target.value)\n            attr = node.target.attr\n            a = '%s.%s %s %s' %(name, attr, op, self.visit(node.value))\n            writer.write(a)\n\n        elif isinstance(node.target, ast.Subscript):\n            name = self.visit(node.target.value)\n            slice = self.visit(node.target.slice)\n            #if self._with_js:\n            #   a = '%s[ %s ] %s %s'\n            #   writer.write(a %(name, slice, op, self.visit(node.value)))\n            #else:\n            op = self.visit(node.op)\n            value = self.visit(node.value)\n            #a = '__get__(%s,  __setitem__ )( [%s, __get__(%s,  __getitem__ )([%s], {}) %s (%s)], {} )'\n            fallback = '__get__(%s,  __setitem__ )( [%s, __get__(%s,  __getitem__ )([%s], {}) %s (%s)], {} )'%(name, slice, name, slice, op, value)\n            if isinstance(node.target.value, ast.Name):\n                ## TODO also check for arr.remote (RPC) if defined then __setitem__ can not be bypassed\n\n                ## the overhead of checking if target is an array,\n                ## and calling __setitem__ directly bypassing a single __get__,\n                ## is greather than simply calling the fallback\n                #writer.write('if instanceof(%s, Array): %s.__setitem__([%s, %s[%s] %s (%s) ], __NULL_OBJECT__)' %(name, name, slice, name,slice, op, value))\n\n                writer.write('if instanceof(%s, Array): %s[%s] %s= %s' %(name, name,slice, op, value))\n                writer.write('else: %s' %fallback)\n            else:\n                writer.write(fallback)\n\n        else:\n            ## TODO extra checks to make sure the operator type is valid in this context\n            a = '%s %s %s' %(target, op, self.visit(node.value))\n            writer.write(a)\n\n    def visit_Yield(self, node):\n        return 'yield %s' % self.visit(node.value)\n\n    def _get_js_class_base_init(self, node ):\n        for base in node.bases:\n            bid = self.visit(base).replace('.','_')\n            if bid == 'object':\n                continue\n\n            if bid not in self._js_classes:\n                print 'WARNING: can not find base class in translation unit  %s ' %bid\n                return None\n\n            n = self._js_classes[ bid ]\n\n            if hasattr(n, '_cached_init'):\n                return n._cached_init\n            else:\n                return self._get_js_class_base_init( n )  ## TODO fixme\n\n    def _visit_typed_classdef(self, node): ## this should be called visit_multibackend_classdef\n        name = node.name\n        node._struct_vars = dict()\n        self._js_classes[ name ] = node\n\n        comments = []\n        methods  = {}\n        method_list = []  ## getter/setters can have the same name\n        props = set()     ## type info for the backend and Dart (old)\n        struct_types = dict()\n\n        body_macros = []\n\n        for item in node.body:\n            if isinstance(item, ast.Expr) and isinstance(item.value, ast.Str):\n                comments.append(item.value.s)\n\n            elif isinstance(item, FunctionDef):\n                methods[ item.name ] = item\n                finfo = inspect_method( item )\n                props.update( finfo['properties'] )\n\n                if item.name != '__init__':\n                    method_list.append( item )\n\n                #if item.name == '__init__': continue\n                continue\n\n                item.args.args = item.args.args[1:]  ## remove self\n                for n in finfo['name_nodes']:\n                    if n.id == 'self':\n                        n.id = 'this'\n\n            elif isinstance(item, ast.Expr) and isinstance(item.value, ast.Dict):\n                sdef = []\n                for i in range( len(item.value.keys) ):\n                    k = self.visit( item.value.keys[ i ] )\n                    v = self.visit( item.value.values[i] )\n                    sdef.append( '%s=%s'%(k,v) )\n\n                writer.write('@__struct__(%s)' %','.join(sdef))\n\n            elif isinstance(item, ast.Expr) and isinstance(item.value, ast.Call) and isinstance(item.value.func, ast.Name) and item.value.func.id=='macro':\n                body_macros.append( macro('%s')  %item.value.args[0].s)\n\n\n        if comments:\n            # Get comment lines.\n            comment_lines = comments[0].splitlines()\n\n            # Remove the first and last comment line, if they are empty (could be caused by a multi-line string).\n            if len(comment_lines[0].strip()) == 0:\n                comment_lines = comment_lines[1:]\n            if len(comment_lines)   1 and len(comment_lines[-1].strip()) == 0:\n                comment_lines = comment_lines[:-1]\n\n            # Determine the number of leading whitespaces for the first comment line.\n            number_of_leading_whitespaces = len(comment_lines[0]) - len(comment_lines[0].lstrip())\n\n            stripped_comment_lines = []\n\n            # Remove the leading whitespaces from every line (assuming every whitespace starts with the same whitespaces).\n            for line in comment_lines:\n\n                # The comment line is too short.\n                if len(line)   number_of_leading_whitespaces:\n                    stripped_comment_lines.append(line.lstrip())\n                    continue\n\n                # The first part of the comment line does not contain only whitespaces.\n                if len(line[:number_of_leading_whitespaces].strip())   0:\n                    stripped_comment_lines.append(line.lstrip())\n                    continue\n\n                stripped_comment_lines.append(line[number_of_leading_whitespaces:])\n\n\n            comments = ['\\n'.join(stripped_comment_lines)]\n\n        ## pass along all class decorators to the backend ##\n        for dec in node.decorator_list:\n            writer.write('@%s'%self.visit(dec))\n\n\n        bases = []\n        for base in node.bases:\n            bases.append( self.visit(base) )\n        if bases:\n            writer.write('class %s( %s ):'%(node.name, ','.join(bases)))\n\n        else:\n            writer.write('class %s:' %node.name)\n\n        init = methods.get( '__init__', None)\n\n        writer.push()\n\n        if comments:\n            writer.write( '''%s'''  %comments[0])\n        if body_macros:\n            for macro in body_macros:\n                writer.write(macro)\n\n        ## constructor\n        if init:\n            methods.pop( '__init__' )\n            #if self._with_dart:\n            #   init.name = node.name\n\n            if not self._with_rust:\n                ## this is used for which backend? ##\n                writer.write('@returns(self)')\n\n            self.visit(init)\n            node._struct_vars.update( init._typed_args )\n\n            for item in init.body:\n                if isinstance(item, ast.Assign) and isinstance(item.targets[0], ast.Attribute):\n                    if isinstance(item.targets[0].value, ast.Name) and item.targets[0].value.id=='self':\n                        attr = item.targets[0].attr\n                        if attr not in node._struct_vars:\n                            if self._with_go:\n                                node._struct_vars[ attr ] = 'interface'\n                            elif self._with_cpp:\n                                pass\n                            else:\n                                err = [ \n                                    'error: unknown type for attribute `self.%s`'%attr,\n                                    'init typed args:' + ', '.join(init._typed_args.keys()),\n                                    'struct members :' + ', '.join(node._struct_vars.keys())\n\n                                ]\n                                raise SyntaxError( self.format_error('\\n'.join(err)) )\n\n                elif isinstance(item, ast.Expr) and isinstance(item.value, ast.Call) and isinstance(item.value.func, ast.Name) and item.value.func.id=='__let__':\n                    if isinstance(item.value.args[0], ast.Attribute) and item.value.args[0].value.id=='self':\n                        #node._struct_vars[ item.value.args[0].attr ] = item.value.args[1].s\n                        node._struct_vars[ item.value.args[0].attr ] = self.visit(item.value.args[1])\n\n        ## methods\n        for method in method_list:\n            self.visit(method)\n\n        for item in node.body:\n            if isinstance(item, ast.With):\n                s = self.visit(item)\n                if s: writer.write( s )\n\n\n        if not init and not method_list:\n            writer.write( 'pass' )\n\n        ## this special dict is picked up in the second stage of `pythonjs_to_xxx` to build structs or classes\n        if node._struct_vars:\n            writer.write('{')\n            for k in node._struct_vars:\n                v = node._struct_vars[k]\n                writer.write('  %s : %s,' %(k,v))\n            writer.write('}')\n\n        writer.pull()\n\n\n    def _visit_js_classdef(self, node):\n        name = node.name\n\n        ## nested classes \n        if hasattr(node, 'is_nested_class') and node.is_nested_class:\n            name = '_'.join( [s.name for s in self._class_stack] )\n\n        self._js_classes[ name ] = node\n        self._in_js_class = True\n        class_decorators = []\n\n        for decorator in node.decorator_list:  ## class decorators\n            class_decorators.append( decorator )\n\n        method_names = []  ## write back in order (required by GLSL)\n        methods      = {}  ## same named functions get squashed in here (like getter/setters)\n        methods_all  = []  ## all methods of class\n        __call__     = None\n        class_vars = []\n        post_class_write = [\n            '%s.prototype.__class__ = %s' %(name, name),\n            '%s.__name__ =  %s ' %(name,name),\n            '%s.__bases__ = []' %name,\n        ]\n        node._post_class_write = post_class_write\n        for item in node.body:\n            if isinstance(item, FunctionDef):\n                if item.name == '__getattr__':\n                    raise SyntaxError(self.format_error('__getattr__ is not allowed'))\n                ## only remove `self` if it is the first argument,\n                ## python actually allows `self` to be any name (whatever the first argument is named)\n                ## but that is very bad style, and basically never used.\n                ## by dropping that bad style we can assume that any method whose first argument is\n                ## not self is a static method, this way the user can omit using the decorator `@staticmethod`\n\n                item._has_self = False  ## used below to check if it is a staticmethod\n                if len(item.args.args):\n                    item._has_self = self.visit(item.args.args[0]) in ('self', 'this')\n                if item._has_self:\n                    item.args.args = item.args.args[1:]  ## removes self\n\n\n                finfo = inspect_function( item )\n\n                if item.name == '__call__':\n                    for n in finfo['name_nodes']:\n                        if n.id == 'self':\n                            n.id = '__call__'\n\n                    __call__ = item\n                else:\n                    for n in finfo['name_nodes']:\n                        if n.id == 'self':\n                            n.id = 'this'\n\n                    method_names.append(item.name)\n                    methods[ item.name ] = item\n                    methods_all.append( item )\n\n            elif isinstance(item, ast.Expr) and isinstance(item.value, Str):  ## skip doc strings\n                pass\n            elif isinstance(item, ast.ClassDef):\n                ## support subclass namespaces ##\n                item.is_nested_class = True\n                self.visit(item)\n                sets_namespace = '.'.join( [s.name for s in self._class_stack+[item]] )\n                sub_name = '_'.join( [s.name for s in self._class_stack+[item]] )\n                if len(self._class_stack)   1:\n                    self._class_stack[0]._post_class_write.insert(0, '%s = %s' %(sets_namespace, sub_name) )\n                else:\n                    post_class_write.insert(0, '%s = %s' %(sets_namespace, sub_name) )\n\n            else:\n                class_vars.append( item )\n\n\n        init = methods.get( '__init__', None)\n        if init:\n            args = [self.visit(arg) for arg in init.args.args]\n            node._cached_init = init\n            if init.args.kwarg:\n                args.append( init.args.kwarg )\n\n        else:\n            args = []\n            init = self._get_js_class_base_init( node )\n            if init:\n                args = [self.visit(arg) for arg in init.args.args]\n                node._cached_init = init\n\n        writer.write('def %s(%s):' %(name,','.join(args)))\n        writer.push()\n\n        if __call__:\n            line = self.visit(__call__)\n            if line: writer.write( line )\n            writer.write('inline( __call__.__$UID$__ = __$UID$__ ++ )')\n            #writer.write('__call__.__proto__ = this.__proto__')  ## not valid in all browsers\n            ## this works in all browsers, and is only slightly slower than using `__proto__`\n\n            for mname in method_names:\n                writer.write('__call__.%s = this.%s' %(mname, mname))\n\n            writer.write('__call__.__call__ = __call__')  ## for the rare case, where the user directly call `__call__`\n            writer.write('__call__.__class__ = %s' %node.name)  ## so that builtin `isinstance` can still work.\n\n            if init:\n                if hasattr(init, '_code'):  ## cached - is this valid here with __call__? ##\n                    code = init._code\n                elif args:\n                    code = '__call__.__init__(%s)'%(', '.join(args))\n                    init._code = code\n                else:\n                    code = '__call__.__init__()'\n                    init._code = code\n                writer.write(code)\n\n            writer.write('return __call__')\n\n\n            if False:\n                ## this way of implementing a callable functor is 200x slower than above,\n                ## what is likely killing the JIT here is dynamically binding `__call__` to `this`,\n                ## looping over the values in `this` and reassigning them to `__callbound__` appears\n                ## to break V8\n                writer.write('var(__callbound__)')\n                writer.write('@bind(__callbound__, this)')\n                line = self.visit(__call__)\n                if line: writer.write( line )\n                ## note: Object.keys is even slower in this case ##\n                #writer.write('inline( for (var _ in Object.keys(this)) {__callbound__[_]=this[_];} )')\n                #writer.write('__callbound__.__proto__ = this.__proto__')\n                #writer.write('__callbound__.__call__ = __callbound__')\n                for mname in method_names:\n                    writer.write('__callbound__.%s = this.%s.bind(this)' %(mname, mname))\n                writer.write('return __callbound__')\n\n\n        elif init:\n            writer.write('inline( this.__$UID$__ = __$UID$__ ++ )')\n\n            tail = ''  ## what was tail used for?\n\n            ## note: this is just the constructor, the actual __init__\n            ## body is moved along with all the other methods to functions\n            ## that bind to CLASSNAME.prototype.METHODNAME\n            ##for b in init.body:\n            ##  line = self.visit(b)\n            ##  if line: writer.write( line )\n\n            if hasattr(init, '_code'):  ## cached ##\n                code = init._code\n            elif args:\n                code = 'this.__init__(%s); %s'%(', '.join(args), tail)\n                init._code = code\n            else:\n                code = 'this.__init__();     %s' % tail\n                init._code = code\n\n            writer.write(code)\n\n        else:\n            writer.write('inline( this.__$UID$__ = __$UID$__ ++ )')\n\n        writer.pull()\n\n        if post_class_write:\n            for postline in post_class_write:\n                writer.write(postline)\n\n\n        writer.write('@__prototype__(%s)'%name)\n        writer.write('def toString(): return inline( this.__$UID$__ )')\n\n        for method in methods_all:\n            mname = method.name\n\n            ## this hack is required to assign the function to the class prototype `A.prototype.method=function`\n            writer.write('@__prototype__(%s)'%name)\n            if not method._has_self:\n                writer.write('@staticmethod')\n\n            line = self.visit(method)\n            if line: writer.write( line )\n            #writer.write('%s.prototype.%s = %s'%(name,mname,mname))  ## this also works, but is not as humanreadable\n\n            ## allows subclass method to extend the parents method by calling the parent by class name,\n            ## `MyParentClass.some_method(self)`\n            f = 'function () { return %s.prototype.%s.apply(arguments[0], Array.prototype.slice.call(arguments,1)) }' %(name, mname)\n            writer.write('%s.%s = inline( %s )'%(name,mname,f))\n\n        for base in node.bases:\n            base = self.visit(base)\n            if base == 'object': continue\n            a = [\n                'for (var n in %s.prototype) {'%base,\n                '  if (!(n in %s.prototype)) {'%name,\n                '    %s.prototype[n] = %s.prototype[n]'%(name,base),\n                '  }',\n                '}'\n            ]\n            a = ''.join(a)\n            writer.write(  inline('%s')  %a )\n            writer.write( '%s.__bases__.push(%s)' %(name,base))\n\n        ## class attributes\n        for item in class_vars:\n            if isinstance(item, Assign) and isinstance(item.targets[0], Name):\n                item_name = item.targets[0].id\n                #item.targets[0].id = '__%s_%s' % (name, item_name)\n                #self.visit(item)  # this will output the code for the assign\n                #writer.write('%s.prototype.%s = %s' % (name, item_name, item.targets[0].id))\n                writer.write('%s.%s = %s' % (name, item_name, self.visit(item.value)))\n\n        self._in_js_class = False\n\n    def visit_ClassDef(self, node):\n        self._class_stack.append( node )\n\n        if self._modules:\n            writer.write('__new_module__(%s)' %node.name) ## triggers a new file in final stage of translation.\n\n        ######## c++ and typed backends ########\n        if self._with_go or self._with_rust or self._with_cpp:\n            self._visit_typed_classdef(node)\n            self._class_stack.pop()\n            return\n\n        elif self._with_js:  ######## javascript backend #######\n            self._visit_js_classdef(node)\n            self._class_stack.pop()\n            return\n\n\n    def visit_And(self, node):\n        return ' and '\n\n    def visit_Or(self, node):\n        return ' or '\n\n    def visit_BoolOp(self, node):\n        op = self.visit(node.op)\n        #raise SyntaxError(op)\n        return '('+ op.join( [self.visit(v) for v in node.values] ) + ')'\n\n    def visit_If(self, node):\n        if writer.is_at_global_level() and (self._with_rust or self._with_rust or self._with_cpp):\n            raise SyntaxError( self.format_error('if statements can not be used at module level when transpiling to typed language') )\n\n        elif isinstance(node.test, ast.Dict):\n            if self._with_js:\n                writer.write('if Object.keys(%s).length:' % self.visit(node.test))\n            else:\n                writer.write('if %s.keys().length:' % self.visit(node.test))\n\n        elif isinstance(node.test, ast.List):\n            writer.write('if %s.length:' % self.visit(node.test))\n\n        elif self._with_ll or self._with_rust or self._with_cpp or self._fast_js:\n            writer.write('if %s:' % self.visit(node.test))\n        elif isinstance(node.test, ast.Compare):\n            writer.write('if %s:' % self.visit(node.test))\n        else:\n            writer.write('if __test_if_true__(%s):' % self.visit(node.test))\n\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n        if node.orelse:\n            writer.write('else:')\n            writer.push()\n            map(self.visit, node.orelse)\n            writer.pull()\n\n    def visit_TryExcept(self, node):\n        if len(node.handlers)==0:\n            raise SyntaxError(self.format_error('no except handlers'))\n\n        ## by default in js-mode some expections will not be raised,\n        ## this allows those cases to throw proper errors.\n        if node.handlers[0].type:\n            self._in_catch_exception = self.visit(node.handlers[0].type)\n        else:\n            self._in_catch_exception = None\n\n        writer.write('try:')\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n        map(self.visit, node.handlers)\n\n    def visit_TryFinally(self, node):\n        #raise SyntaxError(node.body)\n        assert len(node.body)==1\n        self.visit_TryExcept(node.body[0])\n        writer.write('finally:')\n        writer.push()\n        for b in node.finalbody:\n            a = self.visit(b)\n            if a: writer.write(a)\n        writer.pull()\n\n    def visit_Raise(self, node):\n        if isinstance(node.type, ast.Name):\n            writer.write('raise %s' % node.type.id)\n\n        elif isinstance(node.type, ast.Call):\n            if len(node.type.args)   1:\n                raise SyntaxError( self.format_error('raise Error(x) can only have a single argument') )\n\n            if node.type.args:\n                writer.write( 'raise %s(%s)' %(self.visit(node.type.func), self.visit(node.type.args[0])) )\n            elif node.type.keywords:\n                kw = []\n                for k in node.type.keywords:\n                    kw.append('%s=%s' %(k.arg, self.visit(k.value)))\n                writer.write( 'raise %s(%s)' %(self.visit(node.type.func), ','.join(kw)) )\n            else:\n                writer.write( 'raise %s()' %self.visit(node.type.func) )\n\n    def visit_ExceptHandler(self, node):\n        if node.type and node.name:\n            writer.write('except %s, %s:' % (self.visit(node.type), self.visit(node.name)))\n        elif node.type and not node.name:\n            writer.write('except %s:' % self.visit(node.type))\n        else:\n            writer.write('except:')\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n\n    def visit_Pass(self, node):\n        writer.write('pass')\n\n    def visit_Name(self, node):\n        if self._with_js:\n            if node.id == 'True':\n                return 'true'\n            elif node.id == 'False':\n                return 'false'\n            elif node.id == 'None':\n                if self._with_go:\n                    return 'nil'\n                else:\n                    return 'null'\n\n        return node.id\n\n    def visit_Num(self, node):\n        return str(node.n)\n\n    def visit_Return(self, node):\n        if node.value:\n            if isinstance(node.value, Call) and isinstance(node.value.func, Name) and node.value.func.id in self._classes:\n                self._return_type = node.value.func.id\n            elif isinstance(node.value, Name) and node.value.id == 'self' and 'self' in self._instances:\n                self._return_type = self._instances['self']\n            ###################\n\n            if isinstance(node.value, ast.Lambda):\n                self.visit( node.value )\n                writer.write( 'return __lambda__' )\n\n            elif isinstance(node.value, ast.Tuple):\n                writer.write( 'return %s;' % ','.join([self.visit(e) for e in node.value.elts]) )\n\n            else:\n                writer.write('return %s' % self.visit(node.value))\n\n        else:\n            writer.write('return')  ## empty return\n\n    def visit_BinOp(self, node):\n        left = self.visit(node.left)\n        op = self.visit(node.op)\n\n        is_go_listcomp = False\n        if self._with_go:\n            if op == ' ':\n                if isinstance(node.left, ast.Subscript) and isinstance(node.left.value, ast.Name) and node.left.value.id=='__inline__':\n                    return 'inline( %s %s )' %(node.left.slice.value.s, self.visit(node.right))\n\n                elif isinstance(node.left, ast.Call) and isinstance(node.left.func, ast.Name):\n                    if node.left.func.id=='__go__array__' and isinstance(node.right, ast.GeneratorExp):\n                        is_go_listcomp = True\n                        node.right.go_listcomp_type = node.left.args[0].id\n                    elif node.left.func.id=='__go__map__':\n                        if isinstance(node.left.args[1], ast.Call):  ## map comprehension\n                            is_go_listcomp = True\n                            node.right.go_dictcomp_type =  ( node.left.args[0].id, self.visit(node.left.args[1]) )\n                        else:\n                            node.right.go_dictcomp_type =  ( node.left.args[0].id, node.left.args[1].id )\n\n\n        right = self.visit(node.right)\n\n        if self._with_go:\n            if op == '//': op = '/'\n\n            if is_go_listcomp:\n                return right\n            else:\n                return '(%s %s %s)' % (left, op, right)\n\n        elif op == '%' and isinstance(node.left, ast.Str) and self._with_js:\n            return '__sprintf( %s, %s )' %(left, right)  ## assumes that right is a tuple, or list.\n\n        elif op == '*' and isinstance(node.left, ast.List) and self._with_js:\n            if len(node.left.elts) == 1 and isinstance(node.left.elts[0], ast.Name) and node.left.elts[0].id == 'None':\n                return 'inline( new Array(%s) )' %self.visit(node.right)\n            else:\n                return '%s.__mul__(%s)' %(left, right)\n\n        elif op == '**' and self._with_cpp:\n            return 'std.__doublecolon__.pow(%s,%s)' %(left, right)\n\n        elif op == '//' and self._with_cpp:\n            ## note: std::floor(int,int) returns a double,\n            ## because in C, with typed variables there is no need for\n            ## two different division operators `/` (float) and `//` (integer)\n            #return 'std.__doublecolon__.floor(%s/%s)' %(left, right)\n            return '(%s / %s)' % (left, right)\n\n        elif op == '//' and self._with_js:  ## TODO, c++ and typed modes should not set _with_js to true\n            return 'Math.floor(%s/%s)' %(left, right)\n\n        elif op == '**' and self._with_js:\n            return 'Math.pow(%s,%s)' %(left, right)\n\n\n        return '(%s %s %s)' % (left, op, right)\n\n    def visit_Eq(self, node):\n        return '=='\n\n    def visit_NotEq(self, node):\n        return '!='\n\n    def visit_Is(self, node):\n        return 'is'\n\n    def visit_Pow(self, node):\n        return '**'\n\n    def visit_Mult(self, node):\n        return '*'\n\n    def visit_Add(self, node):\n        return '+'\n\n    def visit_Sub(self, node):\n        return '-'\n\n    def visit_FloorDiv(self, node):\n        return '//'\n    def visit_Div(self, node):\n        return '/'\n    def visit_Mod(self, node):\n        return '%'\n    def visit_LShift(self, node):\n        return ' '\n    def visit_RShift(self, node):\n        return ' '\n    def visit_BitXor(self, node):\n        return '^'\n    def visit_BitOr(self, node):\n        return '|'\n    def visit_BitAnd(self, node):\n        return ' '\n\n    def visit_Lt(self, node):\n        return ' '\n\n    def visit_Gt(self, node):\n        return ' '\n\n    def visit_GtE(self, node):\n        return ' ='\n\n    def visit_LtE(self, node):\n        return ' ='\n\n    def visit_Compare(self, node):\n        left = self.visit(node.left)\n        comp = [ left ]\n        for i in range( len(node.ops) ):\n            if i==0 and isinstance(node.left, ast.Name) and node.left.id in self._typedef_vars and self._typedef_vars[node.left.id] == 'long':\n                if isinstance(node.ops[i], ast.Eq):\n                    comp = ['%s.equals(%s)' %(left, self.visit(node.comparators[i]))]\n                elif isinstance(node.ops[i], ast.Lt):\n                    comp = ['%s.lessThan(%s)' %(left, self.visit(node.comparators[i]))]\n                elif isinstance(node.ops[i], ast.Gt):\n                    comp = ['%s.greaterThan(%s)' %(left, self.visit(node.comparators[i]))]\n\n                elif isinstance(node.ops[i], ast.LtE):\n                    comp = ['%s.lessThanOrEqual(%s)' %(left, self.visit(node.comparators[i]))]\n                elif isinstance(node.ops[i], ast.GtE):\n                    comp = ['%s.greaterThanOrEqual(%s)' %(left, self.visit(node.comparators[i]))]\n\n                else:\n                    raise NotImplementedError( node.ops[i] )\n\n            elif isinstance(node.ops[i], ast.In) or isinstance(node.ops[i], ast.NotIn):\n                if comp[-1] == left:\n                    comp.pop()\n                else:\n                    comp.append( ' and ' )\n\n                if isinstance(node.ops[i], ast.NotIn):\n                    comp.append( ' not (')\n\n                a = ( self.visit(node.comparators[i]), left )\n\n                if self._with_cpp or self._with_rust or self._with_go:\n                    comp.append('%s in %s' %(a[1], a[0]))\n\n                elif self._with_js:\n                    ## this makes  if 'x' in Array  work like Python:  if 'x' in list  - TODO fix this for js-objects\n                    ## note javascript rules are confusing:  1 in [1,2]  is true, this is because a  in test  in javascript tests for an index\n                    comp.append( '__contains__(%s, %s)' %(a[0],a[1]))\n                else:\n                    raise RuntimeError( self.format_error('invalid backend') )\n\n                if isinstance(node.ops[i], ast.NotIn):\n                    comp.append( ' )')  ## it is not required to enclose NotIn\n\n            else:\n                comp.append( self.visit(node.ops[i]) )\n                comp.append( self.visit(node.comparators[i]) )\n\n        try:\n            out = ' '.join(comp)\n        except UnicodeDecodeError as err:\n            print comp\n            for c in comp:\n                print c\n            raise err\n        return ' '.join( comp )\n\n    def visit_Not(self, node):\n        return ' not '\n\n    def visit_IsNot(self, node):\n        return ' is not '\n\n    def visit_UnaryOp(self, node):\n        op = self.visit(node.op)\n        if op is None: raise RuntimeError( node.op )\n        operand = self.visit(node.operand)\n        if operand is None: raise RuntimeError( node.operand )\n        return op + operand\n\n    def visit_USub(self, node):\n        return '-'\n    def visit_UAdd(self, node):\n        return '+'\n\n\n    def visit_Attribute(self, node):\n        node_value = self.visit(node.value)\n\n        if self._with_ll or self._with_go:\n            return '%s.%s' %(node_value, node.attr)\n\n        elif self._with_js:\n            ## TODO enable get attribute - move to js backend ##\n            #if self._in_catch_exception == 'AttributeError':\n            #   return '__getfast__(%s,  %s )' % (node_value, node.attr)\n            #else:\n            return '%s.%s' %(node_value, node.attr)\n\n        elif hasattr(node, 'lineno'):\n            src = self._source[ node.lineno-1 ]\n            src = src.replace(' ', '\\\\ ')\n            err = 'missing attribute `%s` - line %s: %s'    %(node.attr, node.lineno, src.strip())\n            return '__get__(%s,  %s ,  %s )' % (node_value, node.attr, err)\n        else:\n            return '__get__(%s,  %s )' % (node_value, node.attr)\n\n\n    def visit_Index(self, node):\n        return self.visit(node.value)\n\n    def visit_Subscript(self, node):\n        name = self.visit(node.value)\n\n        if isinstance(node.slice, ast.Ellipsis):\n            return '%s[...]' %name\n\n        elif self._with_ll or self._with_rust or self._with_go or self._with_cpp:\n            return '%s[%s]' %(name, self.visit(node.slice))\n\n        elif self._with_js:\n            if isinstance(node.slice, ast.Slice):  ## allow slice on Array\n                if not node.slice.lower and not node.slice.upper and not node.slice.step:\n                    return '%s.copy()' %name\n                elif not node.slice.upper and node.slice.step:\n                    slice = self.visit(node.slice).split(',')\n                    slice = '%s,%s' %(slice[0], slice[2])\n                    return '%s.__getslice_lowerstep__(%s)'%(name, slice)\n                else:\n                    return '%s.__getslice__(%s)'%(name, self.visit(node.slice))\n\n\n            elif isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.Num):\n                if node.slice.value.n   0:\n                    ## the problem with this is it could be a dict with negative numbered keys\n                    return '%s[ %s.length+%s ]' %(name, name, self.visit(node.slice))\n                else:\n                    return '%s[ %s ]' %(name, self.visit(node.slice))\n\n\n            else:  ## ------------------ old javascript mode ------------------------\n                ## TODO clean this up ##\n\n                if self._in_catch_exception == 'KeyError':\n                    value = self.visit(node.value)\n                    slice = self.visit(node.slice)\n                    return '__get__(%s,  __getitem__ )([%s], __NULL_OBJECT__)' % (value, slice)\n\n                elif isinstance(node.slice, ast.Index) and isinstance(node.slice.value, ast.BinOp):\n                    ## TODO keep this optimization? in js mode `a[x+y]` is assumed to a direct key,\n                    ## it would be safer to check if one of the operands is a number literal,\n                    ## in that case it is safe to assume that this is a direct key.\n                    return '%s[ %s ]' %(name, self.visit(node.slice))\n\n                elif self._with_direct_keys:\n                    return '%s[ %s ]' %(name, self.visit(node.slice))\n\n                else:\n                    s = self.visit(node.slice)\n                    ## this is bad for chromes jit because it trys to find `__uid__`\n                    return '%s[ __ternary_operator__(%s.__uid__, %s) ]' %(name, s, s)\n\n                    ## TODO check why the JSON.stringify hack fails with arrays (fake tuples)\n                    #check_array = '__ternary_operator__( instanceof(%s,Array), JSON.stringify(%s), %s )' %(s, s, s)\n                    #return '%s[ __ternary_operator__(%s.__uid__, %s) ]' %(name, s, check_array)\n\n        else:\n            raise RuntimeError( self.format_error('unknown backend') )\n\n    def visit_Slice(self, node):\n        if self._with_go or self._with_rust or self._with_cpp:\n            lower = upper = step = None\n        elif self._with_js:\n            lower = upper = step = 'undefined'\n        else:\n            lower = upper = step = 'undefined'\n        if node.lower:\n            lower = self.visit(node.lower)\n        if node.upper:\n            upper = self.visit(node.upper)\n        if node.step:\n            step = self.visit(node.step)\n\n        if self._with_go or self._with_rust or self._with_cpp:\n            if lower and upper and step:\n                return '%s:%s:%s' %(lower,upper,step)\n            elif lower and step:\n                return '%s::%s' %(lower,step)\n            elif upper and step:\n                return ':%s:%s' %(upper,step)\n            elif step:\n                return '::%s'%step\n            elif lower and upper:\n                return '%s:%s' %(lower,upper)\n            elif upper:\n                return ':%s' %upper\n            elif lower:\n                return '%s:'%lower\n            else:\n                return ':'\n        else:\n            return  %s, %s, %s  % (lower, upper, step)\n\n    def visit_Assign(self, node):\n        use_runtime_errors = not (self._with_js or self._with_ll or self._with_go)\n        use_runtime_errors = use_runtime_errors and self._with_runtime_exceptions\n\n        lineno = node.lineno\n        if node.lineno   len(self._source):\n            src = self._source[ node.lineno ]\n            self._line_number = node.lineno\n            self._line = src\n\n\n        if use_runtime_errors:\n            writer.write('try:')\n            writer.push()\n\n        targets = list( node.targets )\n        target = targets[0]\n\n        ## should be ok most of the time to assign to a low level type, TODO deprecate this when `auto dict = x` is fixed c++ backend.\n        if isinstance(target, ast.Name) and target.id in typedpython.types:\n            raise SyntaxError( self.format_error('ERROR: can not assign to builtin lowlevel type: '+target.id) )\n\n        elif self._with_go and isinstance(target, ast.Subscript) and isinstance(target.value, ast.Name) and target.value.id in ('__go__array__', '__go__class__', '__go__pointer__', '__go__func__'):\n            if len(targets)==2 and isinstance(targets[1], ast.Attribute) and isinstance(targets[1].value, ast.Name) and targets[1].value.id == 'self' and len(self._class_stack):\n                if target.value.id == '__go__array__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = '__go__array__(%s typedef)' %self.visit(target.slice)\n                elif target.value.id == '__go__class__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = self.visit(target.slice)\n                elif target.value.id == '__go__pointer__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = ' *%s ' %self.visit(target.slice)\n                elif target.value.id == '__go__func__':\n                    self._class_stack[-1]._struct_vars[ targets[1].attr ] = self.visit(target.slice)\n\n\n            elif target.value.id == '__go__class__':\n                #self._class_stack[-1]._struct_vars[ targets[1].attr ] = self.visit(target.slice)\n                raise SyntaxError(self.visit(target))\n            elif target.value.id == '__go__pointer__':\n                if len(targets)==2:\n                    writer.write(\n                        'inline( var %s *%s; )' %(self.visit(targets[1]), self.visit(target.slice))\n                    )\n                else:\n                    writer.write(\n                        'inline( var %s *%s; )' %(self.visit(node.value), self.visit(target.slice))\n                    )\n\n            elif target.value.id == '__go__array__':\n                if isinstance(node.value, ast.Call) and len(node.value.args) and isinstance(node.value.args[0], ast.GeneratorExp ):\n                    node.value.args[0].go_listcomp_type = self.visit(target.slice)\n                else:\n                    raise SyntaxError( 'only a variable created by a generator expressions needs an array typedef')\n            else:\n                raise SyntaxError(self.visit(target))\n\n            targets = targets[1:]\n\n\n        elif self._with_rpc_name and isinstance(target, Attribute) and isinstance(target.value, Name) and target.value.id == self._with_rpc_name:\n            writer.write('__rpc_set__(%s,  %s , %s)' %(self._with_rpc, target.attr, self.visit(node.value)))\n            return None\n        elif self._with_rpc_name and isinstance(node.value, Attribute) and isinstance(node.value.value, Name) and node.value.value.id == self._with_rpc_name:\n            writer.write('%s = __rpc_get__(%s,  %s )' %(self.visit(target), self._with_rpc, node.value.attr))\n            return None\n\n        #############################################\n        for target in targets:\n            self._visit_assign_helper( node, target )\n            node = ast.Expr( value=target )\n\n        if use_runtime_errors:\n            writer.pull()\n            writer.write('except:')\n            writer.push()\n            if lineno-1   len(self._source):\n                src = self._source[ lineno-1 ]\n                src = src.replace(' ', '\\\\ ')\n                src = 'line %s: %s' %(lineno, src.strip())\n                writer.write('console.trace()')\n                writer.write('console.error(__exception__, __exception__.message)')\n                writer.write('console.error( %s )' %src)\n                writer.write('raise RuntimeError( %s )' %src)\n            else:\n                writer.write('raise RuntimeError( no source code )')\n\n            writer.pull()\n\n\n\n    def _visit_assign_helper(self, node, target):\n        if isinstance(node.value, ast.Lambda):\n            self.visit(node.value)  ## writes function def\n            writer.write('%s = __lambda__' %self.visit(target))\n\n        elif isinstance(node.value, ast.Dict) and (self._with_go or self._with_rust or self._with_cpp):\n            key_type = None\n            val_type = None\n\n            for i in range( len(node.value.keys) ):\n                k = node.value.keys[ i ]\n                v = node.value.values[i]\n\n                ## key type ##\n                if isinstance(k, ast.Str):\n                    key_type = 'string'\n                elif isinstance(k, ast.Num):\n                    key_type = 'int'\n\n                ## value type ##\n                if isinstance(v, ast.Str):\n                    val_type = 'string'\n                elif isinstance(v, ast.Num):\n                    if isinstance(v.n, int):\n                        val_type = 'int'\n                    else:\n                        val_type = 'float64'\n                elif isinstance(v, ast.List) and len(v.elts):\n                    for elt in v.elts:\n                        if isinstance(elt, ast.Num):\n                            if isinstance(elt.n, int):\n                                val_type = ' []int '\n                            else:\n                                val_type = ' []double '\n                        elif isinstance(elt, ast.Str):\n                            val_type = ' []string '\n                elif isinstance(v, ast.Tuple) and len(v.elts):\n                    if val_type is None:\n                        val_type = [None] * len(v.elts)\n\n                    for vidx,elt in enumerate(v.elts):\n                        if isinstance(elt, ast.Num):\n                            if isinstance(elt.n, int):\n                                val_type[vidx] = 'int'\n                            else:\n                                val_type[vidx] = 'double'\n                        elif isinstance(elt, ast.Str):\n                            val_type[vidx] = 'string'\n                        elif isinstance(elt, ast.Name):\n                            ## TODO, check if named is a global\n                            pass\n                        elif isinstance(elt, ast.BinOp):\n\n                            if isinstance(elt.left, ast.Num):\n                                if isinstance(elt.left.n, int):\n                                    val_type[vidx] = 'int'\n                                else:\n                                    val_type[vidx] = 'double'\n\n                            elif isinstance(elt.right, ast.Num):\n                                if isinstance(elt.right.n, int):\n                                    val_type[vidx] = 'int'\n                                else:\n                                    val_type[vidx] = 'double'\n\n\n                        elif isinstance(elt, ast.List) and len(elt.elts):\n                            for et in elt.elts:\n                                if isinstance(et, ast.Num):\n                                    if isinstance(et.n, int):\n                                        val_type[vidx] = ' []int '\n                                    else:\n                                        val_type[vidx] = ' []double '\n                                elif isinstance(et, ast.Str):\n                                    val_type[vidx] = ' []string '\n                                elif isinstance(et, ast.BinOp):\n                                    if isinstance(et.left, ast.Num):\n                                        if isinstance(et.left.n, int):\n                                            val_type[vidx] = ' []int '\n                                        else:\n                                            val_type[vidx] = ' []double '\n\n                                    elif isinstance(et.right, ast.Num):\n                                        raise RuntimeError('right is num')\n                                else:\n                                    raise RuntimeError(et)\n                        else:\n                            raise RuntimeError(elt)\n\n\n            if type(val_type) is list:\n                if None in val_type:\n                    raise SyntaxError( self.format_error(val_type) )\n                else:\n                    val_type = tuple(val_type)\n\n\n            if not key_type:\n                raise SyntaxError(  self.format_error('can not determine dict key type')  )\n            if not val_type:\n                raise SyntaxError(  self.format_error('can not determine dict value type')  )\n\n            t = self.visit(target)\n            v = self.visit(node.value)\n            writer.write('%s = __go__map__(%s, %s)   %s' %(t, key_type, val_type, v))\n            self._autotyped_dicts[t] = v\n\n\n        elif isinstance(node.value, ast.List) and (self._with_go or self._with_rust or self._with_cpp):\n            guess_type = None\n            for elt in node.value.elts:\n                if isinstance(elt, ast.Num):\n                    if isinstance(elt.n, int):\n                        guess_type = 'int'\n                    else:\n                        guess_type = 'float64'\n                elif isinstance(elt, ast.Str):\n                    guess_type = 'string'\n\n            if guess_type:\n                t = self.visit(target)\n                v = self.visit(node.value)\n                writer.write('%s = __go__array__(%s)   %s' %(t, guess_type, v))\n            else:\n                raise SyntaxError(self.format_error('can not determine type of array'))\n\n        elif isinstance(target, Subscript):\n            name = self.visit(target.value)  ## target.value may have  returns_type  after being visited\n\n            if isinstance(target.slice, ast.Ellipsis):\n                #code = '%s[ $wrapped ] = %s' %(self.visit(target.value), self.visit(node.value))\n                code = '%s[...] = %s' %(self.visit(target.value), self.visit(node.value))\n\n            elif isinstance(target.slice, ast.Slice):\n                if isinstance(target.value, ast.Name) and target.value.id == '__let__':\n                    ## pass along special __let__ to the backend pass\n                    code = '__let__[%s : %s]' %(self.visit(target.slice.upper), self.visit(target.slice.lower))\n                elif self._with_cpp or self._with_rust or self._with_go:\n                    code = '%s[%s]=%s' %(self.visit(target.value), self.visit(target.slice), self.visit(node.value))\n                else:\n                    code = '%s.__setslice__(%s, %s)' %(self.visit(target.value), self.visit(target.slice), self.visit(node.value))\n\n            elif self._with_ll or self._with_cpp or self._with_go or self._with_rust:\n                code = '%s[ %s ] = %s'\n                code = code % (self.visit(target.value), self.visit(target.slice.value), self.visit(node.value))\n\n            elif self._with_js:\n                s = self.visit(target.slice.value)\n                if isinstance(target.slice.value, ast.Num) or isinstance(target.slice.value, ast.BinOp):\n                    code = '%s[ %s ] = %s' % (self.visit(target.value), s, self.visit(node.value))\n                elif self._with_direct_keys:\n                    code = '%s[ %s ] = %s' % (self.visit(target.value), s, self.visit(node.value))\n                else:\n                    ## check_array is broken? TODO deprecate or fix this\n                    #check_array = '__ternary_operator__( instanceof(%s,Array), JSON.stringify(%s), %s )' %(s, s, s)\n                    #code = '%s[ __ternary_operator__(%s.__uid__, %s) ] = %s' %(self.visit(target.value), s, check_array, self.visit(node.value))\n                    ## this is safer\n                    code = '%s[ __ternary_operator__(%s.__uid__, %s) ] = %s' %(self.visit(target.value), s, s, self.visit(node.value))\n\n            elif name in self._func_typedefs and self._func_typedefs[name] == 'list':\n                code = '%s[%s] = %s'%(name, self.visit(target.slice.value), self.visit(node.value))\n\n            else:\n                code =  __get__(__get__(%s, '__setitem__'), '__call__')([%s, %s], JSObject()) \n                code = code % (self.visit(target.value), self.visit(target.slice.value), self.visit(node.value))\n\n            writer.write(code)\n\n        elif isinstance(target, Attribute):\n            self._in_assign_target = True\n            target_value = self.visit(target.value)  ## target.value may have  returns_type  after being visited\n            self._in_assign_target = False\n\n            if self._with_js or self._with_go:\n                writer.write( '%s.%s=%s' %(target_value, target.attr, self.visit(node.value)) )\n\n        elif isinstance(target, Name):  ## assignment to variable\n            node_value = self.visit( node.value )  ## node.value may have extra attributes after being visited\n\n            ## note: self._globals and self._instances is DEPRECATED\n            ## tracking of variable types has been moved to the next stage of translation,\n            ## where each backend may have different requirements.\n\n            writer.write('%s = %s' % (self.visit(target), node_value))\n\n        elif isinstance(target, ast.Tuple):\n            if self._use_destructured_assignment:  ## Rust, Go, Dart\n                elts = [self.visit(e) for e in target.elts]\n                writer.write('(%s) = %s' % (','.join(elts), self.visit(node.value)))\n\n            elif self._with_cpp and isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name) and node.value.func.id=='channel':\n                ## special case for rust style channels\n                sender = self.visit( target.elts[0] )\n                recver = self.visit( target.elts[1] )\n                writer.write('%s = %s' % (sender, self.visit(node.value)))\n                writer.write('%s = %s' % (recver, sender))\n\n            else:\n                if isinstance(node.value, ast.Name):\n                    r = node.value.id\n                else:\n                    id = self.identifier\n                    self.identifier += 1\n                    r = '__r_%s' % id\n                    writer.write('var(%s)' % r)\n                    writer.write('%s = %s' % (r, self.visit(node.value)))\n\n                for i, target in enumerate(target.elts):\n                    if isinstance(target, Attribute):\n                        code = '__set__(%s,  %s , %s[%s])' % (\n                            self.visit(target.value),\n                            target.attr,\n                            r,\n                            i\n                        )\n                        writer.write(code)\n                    elif self._with_js:\n                        writer.write( %s = %s[%s]  % (self.visit(target), r, i))\n                    else:\n                        raise RuntimeError( self.format_error('unknown backend'))\n\n        else:\n            raise SyntaxError( self.format_error(target) )\n\n\n    def visit_Print(self, node):\n        writer.write('print(%s)' % ', '.join(map(self.visit, node.values)))\n\n    def visit_Str(self, node):\n        s = node.s.replace('\\\\','\\\\\\\\').replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\\0', '\\\\0')\n        s = s.replace('\\ ', '\\\\ ')\n        s = s.replace('.__right_arrow__.', '- ').replace('= __go__send__ ', ' -')\n        s = s.replace('__DOLLAR__', '$')\n        s = s.replace('__new__ ', 'new ')\n        s = s.replace('.__doublecolon__.', '::')\n\n\n        if self._with_js:\n            return ' %s ' %s           #.encode('utf-8')\n        else:\n            if len(s) == 0:\n                return ' '\n            elif s.startswith(' ') or s.endswith(' '):\n                return  '''%s'''  %s   #.encode('utf-8')\n            else:\n                return ' %s ' %s   #.encode('utf-8')\n\n    def visit_IfExp(self, node):\n        test    = self.visit(node.test)\n        iftrue  = self.visit(node.body)\n        iffalse = self.visit(node.orelse)\n        return '(%s if %s else %s)' %(iftrue, test, iffalse)\n\n\n    def visit_Expr(self, node):\n        if node.lineno   len(self._source):\n            src = self._source[ node.lineno ]\n            ## TODO raise SyntaxErrors with the line number and line source\n            self._line_number = node.lineno\n            self._line = src\n\n        ## note: runtime errors and checking generator has moved to `jstranslator.md`\n        ## TODO clean this up\n        #use_runtime_errors = not (self._with_js or self._with_ll or self._with_dart or self._with_coffee or self._with_go)\n        #use_runtime_errors = use_runtime_errors and self._with_runtime_exceptions\n\n        line = self.visit(node.value)\n        if line:\n            #writer.write('('+line+')')\n            writer.write( line )\n\n\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Lambda):  ## inlined and called lambda  (lambda x: x)(y) \n            node.func.keep_as_lambda = True\n\n        for a in node.args:\n            if isinstance(a, ast.Lambda):\n                a.keep_as_lambda = True\n\n        for kw in node.keywords:\n            if isinstance(kw.value, ast.Lambda):\n                kw.value.keep_as_lambda = True\n\n\n        name = self.visit(node.func)\n        if name in typedpython.GO_SPECIAL_CALLS:\n            name = typedpython.GO_SPECIAL_CALLS[ name ]\n            args = [self.visit(e) for e in node.args ]\n            args += ['%s=%s' %(k.arg, self.visit(k.value)) for k in node.keywords ]\n            return '%s( %s )' %(name, ','.join(args))\n\n        if self._with_rpc:\n            if not self._with_rpc_name:\n                return '__rpc__( %s,  %s , [%s] )' %(self._with_rpc, name, ','.join([self.visit(a) for a in node.args]))\n            elif self._with_rpc_name:\n                if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == self._with_rpc_name:\n                    name = name[ len(self._with_rpc_name)+1 : ]\n                    return '__rpc__( %s,  %s , [%s] )' %(self._with_rpc, name, ','.join([self.visit(a) for a in node.args]))\n\n        ###############################################\n\n        if name == 'open':  ## do not overwrite window.open ##\n            name = '__open__'\n            node.func.id = '__open__'\n\n        ###############################################\n\n        if self._with_webworker and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'self' and node.func.attr == 'terminate':\n            return 'self.postMessage({ type : terminate })'\n\n        elif self._use_threading and isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'threading':\n            if node.func.attr == 'start_new_thread' or node.func.attr == '_start_new_thread':\n                return '__start_new_thread( %s, %s )' %(self.visit(node.args[0]), self.visit(node.args[1]))\n            elif node.func.attr == 'start_webworker':\n                return '__start_new_thread( %s, %s )' %(self.visit(node.args[0]), self.visit(node.args[1]))\n            else:\n                raise SyntaxError( self.format_error(node.func.attr) )\n\n        elif self._with_webworker and name in self._global_functions:\n            node.calling_from_worker = True\n            args = [self.visit(arg) for arg in node.args]\n            return 'self.postMessage({ type : call ,  function : %s ,  args :[%s]})' %(name, ','.join(args))\n\n        elif self._with_js and self._use_array and name == 'array':\n            args = [self.visit(arg) for arg in node.args]\n            return '__js_typed_array(%s)' %','.join(args)\n\n        #########################################\n        if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'numpy' and node.func.attr == 'array':\n            args = [self.visit(arg) for arg in node.args]\n            if node.keywords:\n                kwargs = [ '%s=%s' %(x.arg, self.visit(x.value)) for x in node.keywords]\n                return 'numpy.array(%s, %s)' %( ','.join(args), ','.join(kwargs) )\n            else:\n                return 'numpy.array(%s)' %','.join(args)\n\n        elif isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id == 'pythonjs' and node.func.attr == 'configure':\n            raise RuntimeError( self.format_error('pythonjs.configure is deprecated'))\n\n        elif name == 'inline':\n            return 'inline(%s)' %self.visit(node.args[0])\n\n        elif self._with_ll:\n            F = self.visit(node.func)\n            args = [self.visit(arg) for arg in node.args]\n            if node.keywords:\n                args.extend( [self.visit(x.value) for x in node.keywords] )\n                return '%s(%s)' %( F, ','.join(args) )\n            else:\n                return '%s(%s)' %( F, ','.join(args) )\n\n        elif self._with_go or self._with_rust or self._with_cpp:  ## pass-thru unchanged to next stage for Go, Rust and C++\n            args = list( map(self.visit, node.args) )\n            if None in args:\n                raise RuntimeError( self.format_error('invalid argument: %s' %node.args))\n            if node.keywords:\n                args.extend( ['%s=%s'%(x.arg,self.visit(x.value)) for x in node.keywords] )\n            if node.starargs:\n                args.append('*%s' %self.visit(node.starargs))\n\n            return '%s(%s)' %( self.visit(node.func), ','.join(args) )\n\n        elif self._with_js:\n            args = list( map(self.visit, node.args) )\n\n            if name in self._generator_functions:\n                return ' new(%s(%s))' %(name, ','.join(args))\n\n            elif name in self._builtin_functions and self._builtin_functions[name]:  ## inlined js\n                if args:\n                    return self._builtin_functions[name] % ','.join(args)\n                else:\n                    return self._builtin_functions[name]\n\n            elif name == 'new':\n                assert len(args) == 1\n                return 'new(%s)' %args[0]\n\n            elif name == 'isinstance':\n                assert len(args) == 2\n                #if args[1] == 'dict':   ## TODO find better solution for dict test\n                #   args[1] = 'Object'  ## this fails when testing  isinstance(a, dict)==False  when a is an instance of some class.\n                #elif args[1] == 'list':\n                #   args[1] = 'Array'\n                return 'isinstance(%s, %s)' %(args[0], args[1])\n\n            elif isinstance(node.func, ast.Attribute):\n                ## special method calls that collide with javascript internal methods on native types ##\n                anode = node.func\n                self._in_assign_target = True\n                method = self.visit( node.func )\n                self._in_assign_target = False\n\n                if anode.attr == 'update' and len(args) == 1:\n                    return '__jsdict_update(%s, %s)' %(self.visit(anode.value), ','.join(args) )\n\n                elif anode.attr == 'get' and len(args)   0 and len(args)  = 2 and not node.keywords:\n                    return '__jsdict_get(%s, %s)' %(self.visit(anode.value), ','.join(args) )\n\n                elif anode.attr == 'set' and len(args)==2:\n                    return '__jsdict_set(%s, %s)' %(self.visit(anode.value), ','.join(args))\n\n                elif anode.attr == 'keys' and not args:\n                    #if self._strict_mode:\n                    #   raise SyntaxError( self.format_error('method `keys` is not allowed without arguments') )\n\n                    return '__jsdict_keys(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'values' and not args:\n                    #if self._strict_mode:\n                    #   raise SyntaxError( self.format_error('method `values` is not allowed without arguments') )\n                    return '__jsdict_values(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'items' and not args and not node.keywords:\n                    #if self._strict_mode:\n                    #   raise SyntaxError( self.format_error('method `items` is not allowed without arguments') )\n\n                    return '__jsdict_items(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'pop' and len(args) in (1,2):\n                    pval  = self.visit(anode.value)\n                    pargs = ','.join(args)\n                    ## special case for `myarray.pop(0)`, all cases of `myarr.pop(n)` see `__jsdict_pop`\n                    if len(args)==1 and isinstance(anode.value, ast.Name) and args[0]=='0':  ## V8 can JIT this\n                        return '(%s.shift() if instanceof(%s,Array) else __jsdict_pop(%s, %s))' %(pval, pval, pval,pargs)\n                    else:\n                        return '__jsdict_pop(%s, %s)' %(pval, ','.join(args) )\n\n                elif anode.attr == 'split' and not args:\n                    if self._strict_mode:\n                        raise SyntaxError( self.format_error('method `split` is not allowed without arguments') )\n\n                    return '__split_method(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'sort' and not args:\n                    if self._strict_mode:\n                        raise SyntaxError( self.format_error('method `sort` is not allowed without arguments') )\n\n                    return '__sort_method(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'replace' and len(node.args)==2:\n                    if self._strict_mode:\n                        raise SyntaxError( self.format_error('method `replace` is not allowed...') )\n\n                    return '__replace_method(%s, %s)' %(self.visit(anode.value), ','.join(args) )\n\n                else:\n                    ctx = '.'.join( self.visit(node.func).split('.')[:-1] )\n                    if node.keywords:\n                        kwargs = [ '%s:%s'%(x.arg, self.visit(x.value)) for x in node.keywords ]\n\n                        if args:\n                            if node.starargs:\n                                a = ( method, ctx, ','.join(args), self.visit(node.starargs), ','.join(kwargs) )\n                                ## note: this depends on the fact that [].extend in PythonJS returns self (this),\n                                ## which is different from regular python where list.extend returns None\n                                return '%s.apply( %s, [].extend([%s]).extend(%s).append({%s}) )' %a\n                            else:\n                                return '%s(%s, {%s})' %( method, ','.join(args), ','.join(kwargs) )\n\n                        else:\n                            if node.starargs:\n                                a = ( self.visit(node.func),ctx, self.visit(node.starargs), ','.join(kwargs) )\n                                return '%s.apply(%s, [].extend(%s).append({%s}) )' %a\n\n                            else:\n                                return '%s({%s})' %( method, ','.join(kwargs) )\n\n                    else:\n                        if node.starargs:\n                            a = ( self.visit(node.func), ctx, ','.join(args), self.visit(node.starargs) )\n                            return '%s.apply(%s, [].extend([%s]).extend(%s))' %a\n\n                        else:\n                            return '%s(%s)' %( method, ','.join(args) )\n\n\n            elif isinstance(node.func, Name) and node.func.id in self._js_classes:\n                if node.keywords:\n                    kwargs = [ '%s:%s'%(x.arg, self.visit(x.value)) for x in node.keywords ]\n                    if args:\n                        a = ','.join(args)\n                        return 'new( %s(%s, {%s}) )' %( self.visit(node.func), a, ','.join(kwargs) )\n                    else:\n                        return 'new( %s({%s}) )' %( self.visit(node.func), ','.join(kwargs) )\n                else:\n                    if node.kwargs:\n                        args.append( self.visit(node.kwargs) )\n\n                    a = ','.join(args)\n                    return 'new( %s(%s) )' %( self.visit(node.func), a )\n\n            else:  ## ----------------------------- javascript mode ------------------------\n                if node.keywords:\n                    kwargs = [ '%s:%s'%(x.arg, self.visit(x.value)) for x in node.keywords ]\n                    if args:\n                        if node.starargs:\n                            a = ( self.visit(node.func), self.visit(node.func), ','.join(args), self.visit(node.starargs), ','.join(kwargs) )\n                            return '%s.apply( %s, [].extend([%s]).extend(%s).append({%s}) )' %a\n                        else:\n                            return '%s(%s, {%s})' %( self.visit(node.func), ','.join(args), ','.join(kwargs) )\n                    else:\n                        if node.starargs:\n                            a = ( self.visit(node.func),self.visit(node.func), self.visit(node.starargs), ','.join(kwargs) )\n                            return '%s.apply(%s, [].extend(%s).append({%s}) )' %a\n                        else:\n                            func_name = self.visit(node.func)\n                            if func_name == 'dict':\n                                return '{%s}' %','.join(kwargs)\n                            else:\n                                return '%s({%s})' %( func_name, ','.join(kwargs) )\n\n                else:\n                    if node.starargs:\n                        a = ( self.visit(node.func), self.visit(node.func), ','.join(args), self.visit(node.starargs) )\n                        return '%s.apply(%s, [].extend([%s]).extend(%s))' %a\n                    else:\n                        return '%s(%s)' %( self.visit(node.func), ','.join(args) )\n\n\n        elif isinstance(node.func, Name) and node.func.id in self._generator_functions:\n            args = list( map(self.visit, node.args) )\n            if name in self._generator_functions:\n                return 'JS( new %s(%s) )' %(name, ','.join(args))\n\n        elif name == 'new':\n            args = list( map(self.visit, node.args) )\n            assert len(args) == 1\n            return 'new(%s)' %args[0]\n\n        elif isinstance(node.func, Name) and node.func.id in ('JS', 'toString', 'JSObject', 'JSArray', 'var', 'instanceof', 'typeof'):\n            args = list( map(self.visit, node.args) ) ## map in py3 returns an iterator not a list\n            if node.func.id == 'var':\n                for k in node.keywords:\n                    self._instances[ k.arg ] = k.value.id\n                    args.append( k.arg )\n            else:\n                kwargs = map(lambda x: '%s=%s' % (x.arg, self.visit(x.value)), node.keywords)\n                args.extend(kwargs)\n            args = ', '.join(args)\n            return '%s(%s)' % (node.func.id, args)\n\n        else:\n            ## TODO deprecate below ##\n\n            ## check if pushing to a global typed list ##\n            if isinstance(node.func, ast.Attribute) and isinstance(node.func.value, Name) and node.func.value.id in self._global_typed_lists and node.func.attr == 'append':\n                gtype = self._globals[ node.func.value.id ]\n                if gtype == 'list' and node.func.attr == 'append':\n                    if isinstance(node.args[0], Name):\n                        if node.args[0].id in self._instances:\n                            gset = self._global_typed_lists[ node.func.value.id ]\n                            gset.add( self._instances[node.args[0].id])\n                            if len(gset) != 1:\n                                raise SyntaxError('global lists can only contain one type: instance  %s  is different' %node.args[0].id)\n                        else:\n                            raise SyntaxError('global lists can only contain one type: instance  %s  is unknown' %node.args[0].id)\n\n            call_has_args_only = len(node.args) and not (len(node.keywords) or node.starargs or node.kwargs)\n            call_has_args_kwargs_only = len(node.args) and len(node.keywords) and not (node.starargs or node.kwargs)\n            call_has_args = len(node.args) or len(node.keywords) or node.starargs or node.kwargs\n            name = self.visit(node.func)\n            args = None\n            kwargs = None\n\n            if call_has_args_only:  ## lambda only supports simple args for now.\n                args = ', '.join(map(self.visit, node.args))\n\n            elif call_has_args_kwargs_only:\n                args = ', '.join(map(self.visit, node.args))\n                kwargs = ', '.join(map(lambda x: '%s:%s' % (x.arg, self.visit(x.value)), node.keywords))\n\n            elif call_has_args:\n                args = ', '.join(map(self.visit, node.args))\n                kwargs = ', '.join(map(lambda x: '%s=%s' % (x.arg, self.visit(x.value)), node.keywords))\n                args_name = '__args_%s' % self.identifier\n                kwargs_name = '__kwargs_%s' % self.identifier\n\n                writer.append('var(%s, %s)' % (args_name, kwargs_name))\n                self.identifier += 1\n\n                writer.append('%s = [%s]' % (args_name, args))\n\n                if node.starargs:\n                    writer.append('%s.push.apply(%s, %s)' % (args_name, args_name, self.visit(node.starargs)))\n\n                writer.append('%s = JSObject(%s)' % (kwargs_name, kwargs))\n\n                if node.kwargs:\n                    kwargs = self.visit(node.kwargs)\n                    writer.write('var(__kwargs_temp)')\n                    writer.write('__kwargs_temp = %s[...]' %kwargs)\n                    #code =  JS('for (var name in %s) { %s[name] = %s[...][name]; }')  % (kwargs, kwargs_name, kwargs)\n                    #code =  for __name in %s: %s[__name] = %s[__name]  % (kwargs, kwargs_name, kwargs)\n                    code =  JS('for (var name in __kwargs_temp) { %s[name] = __kwargs_temp[name]; }')  %kwargs_name\n                    writer.append(code)\n\n            #######################################\n\n            ## special method calls ##\n            if isinstance(node.func, ast.Attribute) and node.func.attr in ('get', 'keys', 'values', 'pop', 'items', 'split', 'replace', 'sort'):\n                anode = node.func\n                if anode.attr == 'get' and len(node.args)   0 and len(node.args)  = 2:\n                    return '__jsdict_get(%s, %s)' %(self.visit(anode.value), args )\n\n                elif anode.attr == 'keys' and not args:\n                    return '__jsdict_keys(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'values' and not args:\n                    return '__jsdict_values(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'items' and not args:\n                    return '__jsdict_items(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'pop':\n                    if args:\n                        return '__jsdict_pop(%s, %s)' %(self.visit(anode.value), args )\n                    else:\n                        return '__jsdict_pop(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'sort' and not args:\n                    return '__sort_method(%s)' %self.visit(anode.value)\n\n                elif anode.attr == 'split' and len(node.args)  = 1:\n                    if not args:\n                        return '__split_method(%s)' %self.visit(anode.value)\n                    else:\n                        return '__split_method(%s, %s)' %(self.visit(anode.value), args)\n\n                elif anode.attr == 'replace' and len(node.args)==2:\n                    return '__replace_method(%s, %s)' %(self.visit(anode.value), args )\n\n                else:\n                    return '%s(%s)' %( self.visit(node.func), args )\n\n\n    def visit_Lambda(self, node):\n        args = []\n        for i,a in  enumerate(node.args.args):  ## typed args lambda hack\n            s = self.visit(a)\n            if len(node.args.defaults):\n                assert len(node.args.args)==len(node.args.defaults)\n                s += '= %s ' %self.visit(node.args.defaults[i])\n            args.append( s )\n\n\n        ##'__INLINE_FUNCTION__' from typedpython.py\n        if hasattr(node, 'keep_as_lambda') or (args and args[0]=='__INLINE_FUNCTION__'):\n            ## TODO lambda keyword args\n            self._in_lambda = True\n            a = '(lambda %s: %s)' %(','.join(args), self.visit(node.body))\n            self._in_lambda = False\n            return a\n        else:\n            node.name = '__lambda__'\n            node.decorator_list = []\n            node.body = [node.body]\n            b = node.body[-1]\n            node.body[-1] = ast.Return( b )\n            return self.visit_FunctionDef(node)\n\n    def visit_FunctionDef(self, node):\n        global writer\n\n        ## deprecated\n        #if node in self._generator_function_nodes:\n        #   self._generator_functions.add( node.name )\n        #   if '--native-yield' in sys.argv:\n        #       raise NotImplementedError  ## TODO\n        #   else:\n        #       GeneratorFunctionTransformer( node, compiler=self )\n        #       return\n\n        writer.functions.append(node.name)\n\n        is_worker_entry = False\n        property_decorator = None\n        decorators = []\n        with_dart_decorators = []\n        setter = False\n        return_type = None\n        return_type_keywords = {}\n        fastdef = False\n        javascript = False\n        inline = False\n        threaded = self._with_webworker\n        jsfile = None\n\n        self._typedef_vars = dict()  ## clear typed variables: filled in below by @typedef or in visit_Assign, TODO break this apart into _typed_args and _typed_locals on the node\n        node._typed_args = dict()    ## used in visit class def to get types for struct\n\n        ## TODO deprecate all the glsl code\n        local_typedefs = []\n        typedef_chans = []\n        func_expr = None\n\n        ## deprecated?\n        self._func_typedefs = {}\n\n        if writer.is_at_global_level() and not self._with_webworker:\n            self._global_functions[ node.name ] = node  ## save ast-node\n\n        for decorator in reversed(node.decorator_list):\n            if isinstance(decorator, Name) and decorator.id == 'debugger':\n                writer.write('@debugger')\n            elif isinstance(decorator, Name) and decorator.id == 'classmethod':\n                writer.write('@classmethod')\n            elif isinstance(decorator, Name) and decorator.id == 'virtualoverride':\n                writer.write('@virtualoverride')\n            elif isinstance(decorator, Name) and decorator.id == 'extern':\n                writer.write('@extern')\n\n            elif isinstance(decorator, Call) and decorator.func.id == 'expression':\n                ## js function expressions are now the default, because hoisting is not pythonic.\n                ## when the user writes `a = def(): ...` this gets translated to `@expression( target )\\n def __NAMELESS__()`\n                assert len(decorator.args)==1\n                func_expr = self.visit(decorator.args[0])\n\n            elif isinstance(decorator, Call) and decorator.func.id == '__typedef__':  ## new style\n                c = decorator\n                assert len(c.args) == 3 and len(c.keywords)==0\n                vname = self.visit(c.args[0])\n                vtype = self.visit(c.args[1])\n                vptr  = self.visit(c.args[2])\n\n                self._typedef_vars[ vname ]  = vtype\n                self._instances[ vname ]     = vtype\n                self._func_typedefs[ vname ] = vtype\n                node._typed_args[ vname ]    = vtype\n                local_typedefs.append( '%s=%s' %(vname, vtype))\n                writer.write('@__typedef__(%s, %s, %s)' %(vname, vtype, vptr))\n\n\n            elif isinstance(decorator, Call) and decorator.func.id in ('typedef', 'typedef_chan'):  ## old style\n                c = decorator\n                assert len(c.args) == 0 and len(c.keywords)\n                for kw in c.keywords:\n                    #assert isinstance( kw.value, Name)\n                    kwval = self.visit(kw.value)\n                    self._typedef_vars[ kw.arg ] = kwval\n                    self._instances[ kw.arg ] = kwval\n                    self._func_typedefs[ kw.arg ] = kwval\n                    node._typed_args[ kw.arg ]    = kwval\n                    local_typedefs.append( '%s=%s' %(kw.arg, kwval))\n                    if decorator.func.id=='typedef_chan':\n                        typedef_chans.append( kw.arg )\n                        writer.write('@__typedef_chan__(%s=%s)' %(kw.arg, kwval))\n                    else:\n                        writer.write('@__typedef__(%s=%s)' %(kw.arg, kwval))\n\n\n            elif isinstance(decorator, ast.Call) and isinstance(decorator.func, ast.Name) and decorator.func.id == 'webworker':\n                threaded = True\n                assert len(decorator.args) == 1\n                jsfile = decorator.args[0].s\n\n            elif isinstance(decorator, Call) and isinstance(decorator.func, ast.Name) and decorator.func.id == 'returns':\n                #if decorator.keywords:  ## deprecated\n                #   for k in decorator.keywords:\n                #       key = k.arg\n                #       assert key == 'array' or key == 'vec4'\n                #       return_type_keywords[ key ] = self.visit(k.value)\n                #else:\n                assert len(decorator.args) == 1\n                if isinstance( decorator.args[0], Name):\n                    return_type = decorator.args[0].id\n                elif isinstance(decorator.args[0], ast.Str):\n                    return_type = ' %s ' %decorator.args[0].s\n                else:\n                    raise SyntaxError('invalid @returns argument')\n\n            elif self._with_cpp or self._with_rust:\n                writer.write('@%s' %self.visit(decorator))\n\n            elif isinstance(decorator, Name) and decorator.id == 'fastdef':  ## TODO clean this up\n                fastdef = True\n                raise SyntaxError('@fast is deprecated')\n\n            elif isinstance(decorator, Name) and decorator.id == 'javascript':\n                javascript = True\n                raise SyntaxError('@javascript is deprecated')\n\n            elif isinstance(decorator, Name) and decorator.id == 'property':\n                ## this old style is deprecated, it worked with the old js backend and lua backend\n                #property_decorator = decorator\n                #n = node.name + '__getprop__'\n                #self._decorator_properties[ node.original_name ] = dict( get=n, set=None )\n                #node.name = n\n\n                self._decorator_properties[ node.name ] = dict( get=decorator, set=None )\n                writer.write('@getter')\n\n\n            elif isinstance(decorator, Attribute) and isinstance(decorator.value, Name) and decorator.value.id in self._decorator_properties:\n                if decorator.attr == 'setter':\n                    if self._decorator_properties[ decorator.value.id ]['set'] is not None:\n                        raise SyntaxError( self.format_error( decorator.setter is used more than once ) )\n\n                    ## old deprecated stuff\n                    #n = node.name + '__setprop__'\n                    #self._decorator_properties[ decorator.value.id ]['set'] = n\n                    #node.name = n\n                    #setter = True\n                    #prop_name = node.original_name\n\n                    if node.name != decorator.value.id:\n                        node.name = decorator.value.id\n\n                    self._decorator_properties[ decorator.value.id ]['set'] = decorator\n                    writer.write('@setter')\n\n                elif decorator.attr == 'deleter':\n                    ## javascript has no deleter for properties?\n                    raise NotImplementedError('TODO property deleter')\n                else:\n                    raise SyntaxError('invalid property type')\n\n            elif isinstance(decorator, Call) and decorator.func.id == 'custom_operator':\n                assert len(decorator.args) == 1\n                assert isinstance( decorator.args[0], Str )\n                op = decorator.args[0].s.decode('utf-8')\n                if op not in self._custom_operators:\n                    raise RuntimeError( op, self._custom_operators )\n                self._custom_operators[ op ] = node.name\n\n            else:\n                decorators.append( decorator )\n\n\n        if threaded:\n            if not jsfile: jsfile = 'worker.js'\n            #writer_main.write('%s =  %s ' %(node.name, jsfile))\n            self._webworker_functions[ node.name ] = jsfile\n            writer = get_webworker_writer( jsfile )  ## updates global `writer`\n\n\n\n        ## force python variable scope, and pass user type information to second stage of translation.\n        ## the dart backend can use this extra type information for speed and debugging.\n        ## the Go and GLSL backends require this extra type information.\n        vars = []\n        local_typedef_names = set()\n        if not self._with_coffee:\n            try:\n                local_vars, global_vars = retrieve_vars(node.body)\n            except SyntaxError as err:\n                raise SyntaxError( self.format_error(err) )\n\n            local_vars = local_vars-global_vars\n            inlined_long = False\n            if local_vars:\n                args_typedefs = []\n                args = [ a.id for a in node.args.args ]\n\n                for v in local_vars:\n                    usertype = None\n                    if '=' in v:\n                        t,n = v.split('=')  ## unpack type and name\n                        v = '%s=%s' %(n,t)  ## reverse\n                        local_typedef_names.add( n )\n                        if t == 'long' and inlined_long == False:\n                            inlined_long = True\n                            writer.write('''inline( if (__NODEJS__==true) var long = require('long') )''')  ## this is ugly\n\n                        if n in args:\n                            args_typedefs.append( v )\n                        else:\n                            local_typedefs.append( v )\n                    elif v in args or v in local_typedef_names: pass\n                    else: vars.append( v )\n\n                if args_typedefs:\n                    writer.write('@__typedef__(%s)' %','.join(args_typedefs))\n\n\n        if func_expr:\n            writer.write('@expression(%s)' %func_expr)\n\n\n        if not self._with_js and not javascript:\n            writer.write('@__pyfunction__')\n\n        if return_type or return_type_keywords:\n            if return_type_keywords and return_type:\n                kw = ['%s=%s' %(k,v) for k,v in return_type_keywords.items()]\n                writer.write('@returns(%s, %s)' %(return_type,','.join(kw)) )\n            elif return_type_keywords:\n                writer.write('@returns(%s)' %','.join( ['%s=%s' %(k,v) for k,v in return_type_keywords.items()] ))\n            else:\n                writer.write('@returns(%s)' %return_type)\n\n        ## apply decorators ##\n        for decorator in decorators:\n            writer.write('@%s' %self.visit(decorator))\n\n\n        if self._with_go or self._with_rust or self._with_cpp:  ## pass-thru unchanged to next stage\n            args = []\n            offset = len(node.args.args) - len(node.args.defaults)\n            for i, arg in enumerate(node.args.args):\n                a = arg.id\n                dindex = i - offset\n                if dindex  = 0 and node.args.defaults:\n                    ## try to infer type from named param default,\n                    ## this way the user can simply write `def f(a=0)`\n                    ## rather than `def f(a:int=0)`\n                    default_node = node.args.defaults[dindex]\n                    if a not in node._typed_args:\n                        if isinstance(default_node, ast.Num):\n                            if str(default_node.n).isdigit():\n                                node._typed_args[a] = 'int'\n                            else:\n                                node._typed_args[a] = 'float'  ## default to 32 or 64 bit float?\n                            writer.write('@__typedef__(%s= %s )' %(a, node._typed_args[a]))\n                        elif isinstance(default_node, ast.Str):\n                            node._typed_args[a] = 'string'\n                            writer.write('@__typedef__(%s= %s )' %(a, node._typed_args[a]))\n\n                    default = self.visit(default_node)\n                    args.append( '%s=%s' %(a, default))\n                else:\n                    args.append( a )\n\n            if node.args.vararg: args.append( '*%s' %node.args.vararg )\n            writer.write( 'def %s( %s ):' % (node.name, ','.join(args)) )\n\n\n        elif self._with_js or javascript or self._with_ll:\n\n            kwargs_name = node.args.kwarg or '_kwargs_'\n\n            args = []\n            offset = len(node.args.args) - len(node.args.defaults)\n            for i, arg in enumerate(node.args.args):\n                a = arg.id\n                dindex = i - offset\n                if dindex  = 0 and node.args.defaults:\n                    pass\n                else:\n                    args.append( a )\n\n            if node.args.vararg:\n                if len(node.args.defaults) or node.args.kwarg:\n                    if args:\n                        writer.write( 'def %s( %s, %s, *%s ):' % (node.name, ','.join(args), kwargs_name, node.args.vararg))\n                    else:\n                        writer.write( 'def %s( %s, *%s ):' % (node.name, kwargs_name, node.args.vararg))\n                elif args:\n                    writer.write( 'def %s( %s, *%s ):' % (node.name, ','.join(args), node.args.vararg))\n                else:\n                    writer.write( 'def %s( *%s ):' % (node.name, node.args.vararg))\n            elif len(node.args.defaults) or node.args.kwarg:\n                if args:\n                    writer.write( 'def %s( %s, %s ):' % (node.name, ','.join(args), kwargs_name ) )\n                else:\n                    writer.write( 'def %s( %s ):' % (node.name, kwargs_name) )\n            else:\n                writer.write( 'def %s( %s ):' % (node.name, ','.join(args)) )\n\n        else:\n            if len(node.args.defaults) or node.args.kwarg or len(node.args.args) or node.args.vararg:\n                writer.write('def %s(args, kwargs):' % node.name)\n            else:\n                writer.write('def %s():' % node.name)\n\n        writer.push()\n\n        ## write local typedefs and var scope ##\n        a = ','.join( vars )\n        if local_typedefs:\n            if a: a += ','\n            a += ','.join(local_typedefs)\n        writer.write('var(%s)' %a)\n\n        #####################################################################\n        if self._with_go or self._with_rust or self._with_cpp:\n            pass\n\n        elif (self._with_js or javascript or self._with_ll):\n            if node.args.defaults:\n                if not self._fast_js:\n                    ## this trys to recover when called in a bad way,\n                    ## however, this could be dangerous because the program\n                    ## should fail if a function is called this badly.\n                    kwargs_name = node.args.kwarg or '_kwargs_'\n                    lines = [ 'if (!( %s instanceof Object )) {' %kwargs_name ]\n                    a = ','.join( ['%s: arguments[%s]' %(arg.id, i) for i,arg in enumerate(node.args.args)] )\n                    lines.append( 'var %s = {%s}' %(kwargs_name, a))\n                    lines.append( '}')\n                    for a in lines:\n                        writer.write( inline('''%s''')  %a)\n\n                offset = len(node.args.args) - len(node.args.defaults)\n\n                maxlen = 0\n                maxlen2 = 0\n                for i, arg in enumerate(node.args.args):\n                    dindex = i - offset\n                    if dindex  = 0:\n                        dval = self.visit( node.args.defaults[dindex] )\n\n                        if len(arg.id)   maxlen:\n                            maxlen = len(arg.id)\n\n                        if len(dval)   maxlen2:\n                            maxlen2 = len(dval)\n\n\n                for i, arg in enumerate(node.args.args):\n                    dindex = i - offset\n                    if dindex  = 0:\n                        default_value = self.visit( node.args.defaults[dindex] )\n                        #a = (kwargs_name, kwargs_name, arg.id, arg.id, default_value, arg.id, kwargs_name, arg.id)\n                        #b =  if (%s === undefined || %s.%s === undefined) {var %s = %s} else {var %s=%s.%s}  %a\n                        spaces = ' ' * (maxlen - len(arg.id))\n                        spaces2 = ' ' * (maxlen2 - len(default_value))\n\n                        ## this is fast, but fails in the case where the user has called a function that takes\n                        ## named keyword args, and called it without giving those keyword names. This case can\n                        ## easily popup when the user has refactored the function to use named keyword args,\n                        ## but did not update all code that calls that function.\n                        #a = (arg.id, spaces, kwargs_name, kwargs_name,arg.id, spaces, default_value, spaces2, kwargs_name, arg.id)\n                        #b =  var %s %s= (%s === undefined || %s.%s === undefined)%s?\\t%s %s: %s.%s  %a\n\n                        ## new version throws a runtime error if the function was called improperly.\n                        ERR = 'function `%s` requires named keyword arguments, invalid parameter for `%s`' %(node.name, arg.id)\n                        a = (arg.id, spaces, kwargs_name, kwargs_name, kwargs_name,arg.id, spaces, default_value, spaces2, kwargs_name, kwargs_name, arg.id,ERR)\n                        b =  var %s %s= (%s===undefined || (typeof(%s)=='object'   %s.%s===undefined))%s?\\t%s %s:   typeof(%s)=='object'?%s.%s: __invalid_call__('%s',arguments)  %a\n\n                        c =  inline('''%s''')  %b\n                        writer.write( c )\n\n\n        ################# function body #################\n\n\n        if threaded and is_worker_entry:  ## DEPRECATED - TODO REMOVE\n            for i,arg in enumerate(node.args.args):\n                writer.write( '%s = __webworker_wrap(%s, %s)' %(arg.id, arg.id, i))\n                writer.write('__wargs__.push(%s)'%arg.id)\n\n\n        self._return_type = None # tries to catch a return type in visit_Return\n\n        ## write function body ##\n        ## if sleep() is called or a new webworker is started, the following function body must be wrapped in\n        ## a closure callback and called later by setTimeout\n        timeouts = []\n        #continues = []\n        for b in node.body:\n\n            if self._use_threading and isinstance(b, ast.Assign) and isinstance(b.value, ast.Call):  ## DEPRECATED - TODO REMOVE\n                if isinstance(b.value.func, ast.Attribute) and isinstance(b.value.func.value, Name) and b.value.func.value.id == 'threading':\n                    if b.value.func.attr == 'start_new_thread':\n                        self.visit(b)\n                        writer.write('__run__ = True')\n                        writer.write('def __callback%s():' %len(timeouts))\n                        writer.push()\n                        ## workerjs for nodejs requires at least 100ms to initalize onmessage/postMessage\n                        timeouts.append(0.2)\n                        continue\n                    elif b.value.func.attr == 'start_webworker':\n                        self.visit(b)\n                        writer.write('__run__ = True')\n                        writer.write('def __callback%s():' %len(timeouts))\n                        writer.push()\n                        ## workerjs for nodejs requires at least 100ms to initalize onmessage/postMessage\n                        timeouts.append(0.2)\n                        continue\n\n                elif self._with_webworker and isinstance(b, ast.Assign) and isinstance(b.value, ast.Call) and isinstance(b.value.func, ast.Name) and b.value.func.id in self._global_functions:\n                    #assert b.value.calling_from_worker\n                    #raise SyntaxError(b)\n                    self.visit(b)\n                    writer.write('def __blocking( %s ):' %self.visit(b.targets[0]))\n                    writer.push()\n                    timeouts.append('BLOCKING')\n                    continue\n\n\n            elif self._use_sleep:\n                c = b\n                if isinstance(b, ast.Expr):\n                    b = b.value\n\n                if isinstance(b, ast.Call) and isinstance(b.func, ast.Name) and b.func.id == 'sleep':\n                    writer.write('__run__ = True')\n                    writer.write('def __callback%s():' %len(timeouts))\n                    writer.push()\n                    timeouts.append( self.visit(b.args[0]) )\n                    continue\n\n                elif isinstance(b, ast.While):  ## TODO\n                    has_sleep = False\n                    for bb in b.body:\n                        if isinstance(bb, ast.Expr):\n                            bb = bb.value\n                        if isinstance(bb, ast.Call) and isinstance(bb.func, ast.Name) and bb.func.id == 'sleep':\n                            has_sleep = float(self.visit(bb.args[0]))\n\n                    if has_sleep   0.0:\n                        has_sleep = int(has_sleep*1000)\n                        #writer.write('__run_while__ = True')\n                        writer.write('__continue__ = True')\n                        writer.write('def __while():')\n                        writer.push()\n\n                        for bb in b.body:\n                            if isinstance(bb, ast.Expr):\n                                bb = bb.value\n                            if isinstance(bb, ast.Call) and isinstance(bb.func, ast.Name) and bb.func.id == 'sleep':\n                                continue\n                                #TODO - split body and generate new callback - now sleep is only valid at the end of the while loop\n\n                            else:\n                                e = self.visit(bb)\n                                if e: writer.write( e )\n\n                        writer.write( 'if %s: __run_while__ = True' %self.visit(b.test))\n                        writer.write( 'else: __run_while__ = False')\n\n                        writer.write('if __run_while__: setTimeout(__while, %s)' %(has_sleep))\n                        writer.write('elif __continue__: setTimeout(__callback%s, 0)' %len(timeouts))\n\n                        writer.pull()\n\n                        writer.write('setTimeout(__while, 0)')\n                        writer.write('__run__ = True')\n                        writer.write('def __callback%s():' %len(timeouts))\n                        writer.push()\n                        timeouts.append(None)\n                        continue\n\n                    else:\n                        self.visit(b)\n\n                    continue\n\n                b = c  ## replace orig b\n\n            self.visit(b)\n\n        i = len(timeouts)-1\n        while timeouts:\n            ms = timeouts.pop()\n            if ms == 'BLOCKING':\n                writer.write(   'threading._blocking_callback = None')\n                writer.pull()\n                writer.write('threading._blocking_callback = __blocking')\n            elif ms is not None:\n                writer.pull()\n\n                ms = float(ms)\n                ms *= 1000\n                writer.write('if __run__: setTimeout(__callback%s, %s)' %(i, ms))\n                writer.write('elif __continue__: setTimeout(__callback%s, %s)' %(i+1, ms))\n            i -= 1\n\n        if self._return_type:       ## check if a return type was caught\n            if return_type:\n                assert return_type == self._return_type\n            else:\n                return_type = self._return_type\n            self._function_return_types[ node.name ] = self._return_type\n        self._return_type = None\n\n\n        ############################################################\n        ### DEPRECATED\n        if setter and 'set' in self._injector:  ## inject extra code\n            value_name = node.args.args[1].id\n            inject = [\n                'if self.property_callbacks[ %s ]:' %prop_name,\n                'self.property_callbacks[ %s ]([ %s , %s, self], JSObject())' %(prop_name, prop_name, value_name)\n            ]\n            writer.write( ' '.join(inject) )\n\n        elif self._injector and node.original_name == '__init__':\n            if 'set' in self._injector:\n                writer.write( 'self.property_callbacks = JSObject()' )\n            if 'init' in self._injector:\n                writer.write('if self.__class__.init_callbacks.length:')\n                writer.push()\n                writer.write('for callback in self.__class__.init_callbacks:')\n                writer.push()\n                writer.write('callback( [self], JSObject() )')\n                writer.pull()\n                writer.pull()\n        ############################################################\n\n        writer.pull()  ## end function body\n\n        self._typedef_vars = dict()  ## clear typed variables\n\n        if self._in_js_class:  ## used when making multiple output javascripts, like main.js and webworker.js\n            #writer = writer_main\n            return\n\n\n        types = []\n        for x in zip(node.args.args[-len(node.args.defaults):], node.args.defaults):\n            key = x[0]\n            value = x[1]\n            if isinstance(value, ast.Name):\n                value = value.id\n            else:\n                value = type(value).__name__.lower()\n            types.append( '%s :  %s ' %(self.visit(key), value) )\n\n\n        if self._introspective_functions:\n            ## note, in javascript function.name is a non-standard readonly attribute,\n            ## the compiler creates anonymous functions with name set to an empty string.\n            writer.write('%s.NAME =  %s ' %(node.name,node.name))\n\n            writer.write( '%s.args_signature = [%s]' %(node.name, ','.join([' %s '%n.id for n in node.args.args])) )\n            defaults = ['%s:%s'%(self.visit(x[0]), self.visit(x[1])) for x in zip(node.args.args[-len(node.args.defaults):], node.args.defaults) ]\n            writer.write( '%s.kwargs_signature = {%s}' %(node.name, ','.join(defaults)) )\n            writer.write( '%s.types_signature = {%s}' %(node.name, ','.join(types)) )\n\n            if return_type:\n                writer.write('%s.return_type =  %s '%(node.name, return_type))\n\n\n\n    #################### loops ###################\n    ## the old-style for loop that puts a while loop inside a try/except and catches StopIteration,\n    ## has a problem because at runtime if there is an error inside the loop, it will not show up in a strack trace,\n    ## the error is slient.  FAST_FOR is safer and faster, although it is not strictly Python because in standard\n    ## Python a list is allowed to grow or string while looping over it.  FAST_FOR only deals with a fixed size thing to loop over.\n    FAST_FOR = True\n\n    def visit_Continue(self, node):\n        if self._with_js:\n            writer.write('continue')\n        else:\n            writer.write('continue')\n        return ''\n\n    def visit_Break(self, node):\n        if self._in_loop_with_else:\n            writer.write('__break__ = True')\n        writer.write('break')\n\n    def visit_For(self, node):\n        if node.orelse:\n            raise SyntaxError( self.format_error('the syntax for/else is deprecated') )\n\n\n        if self._with_go:\n            writer.write( 'for %s in %s:' %(self.visit(node.target), self.visit(node.iter)) )\n            writer.push()\n            map(self.visit, node.body)\n            writer.pull()\n            return None\n\n        if self._with_rpc_name and isinstance(node.iter, ast.Attribute) and isinstance(node.iter.value, ast.Name) and node.iter.value.id == self._with_rpc_name:\n            target = self.visit(node.target)\n            writer.write('def __rpc_loop__():')\n            writer.push()\n            writer.write(   '%s = __rpc_iter__(%s,  %s )' %(target, self._with_rpc, node.iter.attr) )\n            writer.write(   'if %s ==  __STOP_ITERATION__ : __continue__()' %target)\n            writer.write(   'else:')\n            writer.push()\n            map(                self.visit, node.body )\n            writer.write(       '__rpc_loop__()')\n            writer.pull()\n            writer.pull()\n            writer.write('__rpc_loop__()')\n\n            writer.write('def __continue__():')  ## because this def comes after, it needs to be `hoisted` up by the javascript VM\n            writer.push()\n            return None\n\n\n        iterid = self._iter_ids\n        self._iter_ids += 1\n\n        target = node.target\n        enumtar = None\n        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, Name) and node.iter.func.id == 'enumerate':\n            iter = node.iter.args[0]\n            if isinstance(target, ast.Tuple):\n                enumtar = target.elts[0]\n                target = target.elts[1]\n            else:\n                raise SyntaxError('for enumerate loop, requires unpacking to a: index,value pair')\n        else:\n            iter = node.iter\n\n        if enumtar:\n            writer.write('var(%s)'%enumtar.id)\n            writer.write('%s = 0' %enumtar.id)\n\n        vars = []\n        multi_target = []\n\n        if isinstance(target, ast.Tuple):\n            vars.append( '__mtarget__%s' %iterid)\n            for elt in target.elts:\n                if isinstance(elt, ast.Name):\n                    multi_target.append( elt.id )\n                    vars.append( elt.id )\n                else:\n                    raise NotImplementedError('unknown iterator sub-target type: %s'%target)\n        elif isinstance(target, ast.Name):\n            vars.append( target.id )\n        else:\n            raise NotImplementedError('unknown iterator target type: %s'%target)\n\n\n        if self._with_ll or self._with_cpp or self._with_rust or self._with_go:\n            writer.write('for %s in %s:' %(self.visit(target), self.visit(iter)))\n            writer.push()\n            map(self.visit, node.body)\n            writer.pull()\n\n        elif self._with_js:\n            if isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in ('range','xrange'):\n                iter_start = '0'\n                if len(iter.args) == 2:\n                    iter_start = self.visit(iter.args[0])\n                    iter_end = self.visit(iter.args[1])\n                else:\n                    iter_end = self.visit(iter.args[0])\n\n                iter_name = target.id\n\n                writer.write('inline( /*for var in range*/ )')\n\n                writer.write('var(%s)' %iter_name)\n                if iter_start == '0':\n                    writer.write('%s = -1' %iter_name)\n                else:\n                    writer.write('%s = %s-1' %(iter_name, iter_start))\n                if '(' in iter_end:  ## if its a function call, cache it to a variable\n                    writer.write('var(%s__end__)' %iter_name)\n                    writer.write('%s__end__ = %s' %(iter_name, iter_end))\n                    writer.write('while inline( ++%s )   %s__end__:' %(iter_name, iter_name))\n                else:\n                    writer.write('while inline( ++%s )   %s:' %(iter_name, iter_end))\n\n                writer.push()\n                map(self.visit, node.body)\n\n                if self._with_js:\n                    #writer.write('inline( %s += 1 )' %iter_name )\n                    if enumtar:\n                        writer.write('inline( %s += 1 )'%enumtar.id)\n                else:\n                    #writer.write('%s += 1' %iter_name )\n                    if enumtar:\n                        writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n\n            elif isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in self._generator_functions:\n                iter_name = self.visit(target)\n                writer.write('var(%s, __generator__%s)' %(iter_name,iterid))\n                writer.write('__generator__%s = %s' %(iterid,self.visit(iter)))\n                writer.write('while __generator__%s.__done__ != 1:'%iterid)\n                writer.push()\n                writer.write('%s = __generator__%s.next()'%(iter_name,iterid))\n                map(self.visit, node.body)\n                writer.pull()\n\n            else:\n                if multi_target:\n                    writer.write('var(%s)' % ','.join(vars))\n                    writer.write('for __mtarget__%s in %s:' %(iterid,self.visit(iter)))\n                    writer.push()\n                    for i,elt in enumerate(multi_target):\n                        writer.write('%s = __mtarget__%s[%s]' %(elt,iterid,i))\n\n                else:\n                    a = self.visit(target)\n                    self._in_assign_target = True\n                    b = self.visit(iter)\n                    self._in_assign_target = False\n                    writer.write('for %s in %s:' %(a, b))\n                    writer.push()\n\n\n                map(self.visit, node.body)\n\n                if enumtar:\n                    writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n        else:\n\n            ## TODO else remove node.target.id from self._instances\n            if isinstance(iter, Name) and iter.id in self._global_typed_lists:\n                self._instances[ target.id ] = list( self._global_typed_lists[ iter.id ] )[0]\n\n\n            vars.append('__iterator__%s'%iterid)\n            if not self._with_coffee:\n                writer.write('var(%s)' % ','.join(vars))\n\n\n            is_range = False\n            is_generator = False\n            iter_start = '0'\n            iter_end = None\n            if self.FAST_FOR and isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in ('range','xrange'):\n                is_range = True\n                if len(iter.args) == 2:\n                    iter_start = self.visit(iter.args[0])\n                    iter_end = self.visit(iter.args[1])\n                else:\n                    iter_end = self.visit(iter.args[0])\n\n            elif isinstance(iter, ast.Call) and isinstance(iter.func, Name) and iter.func.id in self._generator_functions:\n                is_generator = True\n            else:\n                if hasattr(node, 'lineno'):\n                    src = self._source[ node.lineno-1 ]\n                    src = src.replace(' ', '\\\\ ')\n                    err = 'no iterator - line %s: %s'   %(node.lineno, src.strip())\n                    writer.write('__iterator__%s = __get__(__get__(%s,  __iter__ ,  %s ),  __call__ )([], __NULL_OBJECT__)' %(iterid, self.visit(iter), err))\n\n                else:\n                    writer.write('__iterator__%s = __get__(__get__(%s,  __iter__ ),  __call__ )([], __NULL_OBJECT__)' %(iterid, self.visit(iter)))\n\n            if is_generator:\n                iter_name = self.visit(target)\n                if not self._with_coffee:\n                    writer.write('var(%s, __generator__%s)' %(iter_name, iterid))\n                writer.write('__generator__%s = %s' %(iterid,self.visit(iter)))\n                writer.write('while __generator__%s.__done__ != 1:'%iterid)\n                writer.push()\n                writer.write('%s = __generator__%s.next()'%(iter_name,iterid))\n                map(self.visit, node.body)\n                writer.pull()\n\n\n            elif is_range:\n                iter_name = target.id\n                if not self._with_coffee:\n                    writer.write('var(%s, %s__end__)' %(iter_name, iter_name))\n                writer.write('%s = %s' %(iter_name, iter_start))\n                writer.write('%s__end__ = %s' %(iter_name, iter_end))   ## assign to a temp variable.\n                #writer.write('while %s   %s:' %(iter_name, iter_end))  ## this fails with the ternary __add_op\n                writer.write('while %s   %s__end__:' %(iter_name, iter_name))\n\n                writer.push()\n                map(self.visit, node.body)\n                writer.write('%s += 1' %iter_name )\n\n                if enumtar:\n                    writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n            else:\n                if not self._with_coffee:\n                    writer.write('var(__next__%s)'%iterid)\n                writer.write('__next__%s = __get__(__iterator__%s,  next )'%(iterid,iterid))\n                writer.write('while __iterator__%s.index   __iterator__%s.length:'%(iterid,iterid))\n\n                writer.push()\n\n                if multi_target:\n                    writer.write('__mtarget__%s = __next__%s()'%(iterid, iterid))\n                    for i,elt in enumerate(multi_target):\n                        writer.write('%s = __mtarget__%s[%s]' %(elt,iterid,i))\n                else:\n                    writer.write('%s = __next__%s()' %(target.id, iterid))\n\n                map(self.visit, node.body)\n\n                if enumtar:\n                    writer.write('%s += 1'%enumtar.id)\n\n                writer.pull()\n\n            return ''\n\n    _call_ids = 0\n    def visit_While(self, node):\n        if self._cache_while_body_calls:  ## TODO add option for this\n            for n in node.body:\n                calls = collect_calls(n)\n                for c in calls:\n                    if isinstance(c.func, ast.Name):  ## these are constant for sure\n                        i = self._call_ids\n                        writer.write( '__call__%s = __get__(%s, __call__ )' %(i,self.visit(c.func)) )\n                        c.func.id = '__call__%s'%i\n                        c.constant = True\n                        self._call_ids += 1\n\n        if node.orelse:\n            raise SyntaxError( self.format_error('while/else loop is not allowed') )\n            self._in_loop_with_else = True\n            writer.write('var(__break__)')\n            writer.write('__break__ = False')\n\n        self._in_while_test = True\n        writer.write('while %s:' % self.visit(node.test))\n        self._in_while_test = False\n        writer.push()\n        map(self.visit, node.body)\n        writer.pull()\n\n        if node.orelse:\n            self._in_loop_with_else = False\n            writer.write('if __break__ == False:')\n            writer.push()\n            map(self.visit, node.orelse)\n            writer.pull()\n\n    def visit_With(self, node):\n        global writer\n\n        if isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'rpc':\n            self._with_rpc = self.visit( node.context_expr.args[0] )\n            if isinstance(node.optional_vars, ast.Name):\n                self._with_rpc_name = node.optional_vars.id\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            self._with_rpc = None\n            self._with_rpc_name = None\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'webworker':\n            self._with_webworker = True\n            writer = get_webworker_writer( 'worker.js' )\n\n            #writer.write('if typeof(require) !=  undefined : requirejs = require')  ## compatible with nodewebkit\n            #writer.write('else: importScripts( require.js )')\n\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            self._with_webworker = False\n            writer = writer_main\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'lowlevel':\n            self._with_ll = True\n            #map(self.visit, node.body)\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            self._with_ll = False\n\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'atomic':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id == 'static':\n            raise RuntimeError('with static: is reserved for future use')\n\n        elif isinstance( node.context_expr, Name ) and node.context_expr.id in EXTRA_WITH_TYPES:\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id in EXTRA_WITH_TYPES:\n            if node.context_expr.keywords:\n                assert len(node.context_expr.keywords)==1\n                k = node.context_expr.keywords[0].arg\n                v = self.visit(node.context_expr.keywords[0].value)\n                a = 'with %s(%s=%s):' %( self.visit(node.context_expr.func), k,v )\n                writer.write(a)\n            else:\n                writer.write('with %s:' %self.visit(node.context_expr))\n\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'asm':\n            asmcode = []\n            for b in node.body:\n                asmcode.append( b.value.s )\n            args = [ 'code= %s ' % ''.join(asmcode) ]\n            for kw in node.context_expr.keywords:\n                args.append( '%s=%s' %(kw.arg, self.visit(kw.value)) )\n            asm = '__asm__( %s )' %(','.join(args))\n            writer.write( asm )\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'extern':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n        elif isinstance( node.context_expr, ast.Str):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance(node.context_expr, ast.Name) and node.context_expr.id=='syntax':\n            if isinstance(node.optional_vars, ast.Name):\n                writer.write('with syntax(%s):' %self._autotyped_dicts[node.optional_vars.id])\n            else:\n                writer.write('with syntax(%s):' %self.visit(node.optional_vars))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance(node.context_expr, ast.Name) and node.context_expr.id.startswith('return_'):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id.startswith('return_'):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n        elif self.visit( node.context_expr ).startswith('return_'):\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'syntax':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'timeout':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'chain_then':\n            writer.write('with %s:' %self.visit(node.context_expr))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance( node.context_expr, ast.Call ) and isinstance(node.context_expr.func, ast.Name) and node.context_expr.func.id == 'macro':\n            if isinstance(node.context_expr.args[0], ast.Str):\n                writer.write('with %s:' %self.visit(node.context_expr))\n            else:  ## force macro as string\n                writer.write('with macro( %s ):' %self.visit(node.context_expr.args[0]))\n\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n\n        elif isinstance(node.context_expr, ast.Name) or isinstance(node.context_expr, ast.Tuple):  ## assume that backend can support this\n            #if isinstance(node.optional_vars, ast.Subscript) and isinstance(node.optional_vars.slice, ast.Index):\n            if node.optional_vars:\n                writer.write('with %s as %s:' %(self.visit(node.context_expr), self.visit(node.optional_vars)))\n            else:\n                writer.write('with %s:' %self.visit(node.context_expr))\n\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        elif isinstance(node.context_expr, ast.BoolOp) and isinstance(node.context_expr.op, ast.And):\n            writer.write('with [%s] as future:' % ','.join( [self.visit(f) for f in node.context_expr.values] ))\n            writer.push()\n            for b in node.body:\n                a = self.visit(b)\n                if a: writer.write(a)\n            writer.pull()\n\n        else:\n            #raise SyntaxError('invalid use of  with  statement: %s' %self.visit(node.context_expr))\n            raise SyntaxError('invalid use of  with  statement: %s' %node.context_expr)\n\nEXTRA_WITH_TYPES = ('__switch__', '__default__', '__case__', '__select__')\n\n\n\n\n\nclass CollectCalls(NodeVisitor):\n    _calls_ = []\n    def visit_Call(self, node):\n        self._calls_.append( node )\n\ndef collect_calls(node):\n    CollectCalls._calls_ = calls = []\n    CollectCalls().visit( node )\n    return calls\n\n\nclass CollectDictComprehensions(NodeVisitor):\n    _comps_ = []\n    def visit_GeneratorExp(self,node):\n        self._comps_.append( node )\n        self.visit( node.elt )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n    def visit_DictComp(self, node):\n        self._comps_.append( node )\n        self.visit( node.key )\n        self.visit( node.value )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n\ndef collect_dict_comprehensions(node):\n    CollectDictComprehensions._comps_ = comps = []\n    CollectDictComprehensions().visit( node )\n    return comps\n\n\nclass CollectComprehensions(NodeVisitor):\n    _comps_ = []\n    def visit_GeneratorExp(self,node):\n        self._comps_.append( node )\n        self.visit( node.elt )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n    def visit_ListComp(self, node):\n        self._comps_.append( node )\n        self.visit( node.elt )\n        for gen in node.generators:\n            self.visit( gen.iter )\n            self.visit( gen.target )\n\ndef collect_comprehensions(node):\n    CollectComprehensions._comps_ = comps = []\n    CollectComprehensions().visit( node )\n    return comps\n\nclass CollectGenFuncs(NodeVisitor):\n    _funcs = []\n    _genfuncs = []\n    def visit_FunctionDef(self, node):\n        self._funcs.append( node )\n        node._yields = []\n        node._loops = []\n        for b in node.body:\n            self.visit(b)\n        self._funcs.pop()\n\n    def visit_Yield(self, node):\n        func = self._funcs[-1]\n        func._yields.append( node )\n        if func not in self._genfuncs:\n            self._genfuncs.append( func )\n\n    def visit_For(self, node):\n        if len(self._funcs):\n            self._funcs[-1]._loops.append( node )\n        for b in node.body:\n            self.visit(b)\n\n    def visit_While(self, node):\n        if len(self._funcs):\n            self._funcs[-1]._loops.append( node )\n        for b in node.body:\n            self.visit(b)\n\n\ndef collect_generator_functions(node):\n    CollectGenFuncs._funcs = []\n    CollectGenFuncs._genfuncs = gfuncs = []\n    CollectGenFuncs().visit( node )\n    return gfuncs\n\n\n\ndef python_to_pythonjs(script, **kwargs):\n    translator = PythonToPythonJS(\n        source = script,\n        **kwargs\n    )\n\n    code = writer.getvalue()\n\n    if translator.has_webworkers():\n        userimports = [' %s '%imp for imp in translator.get_webworker_imports()]\n        pre = [\n            '__workerimports__ = [%s]' %','.join(userimports),\n            #'__workerpool__ = new(__WorkerPool__(__workersrc__, __workerimports__))',\n            'inline( var \u2ca2\u2c91\u2c91\u2c92 = new __WorkerPool__(__workersrc__, __workerimports__) )',\n            ''\n        ]\n        code = '\\n'.join(pre) + code\n        res = {'main':code}\n        for jsfile in translator.get_webworker_file_names():\n            res[ jsfile ] = get_webworker_writer( jsfile ).getvalue()\n        return res\n    else:\n        if '--debug' in sys.argv:\n            try:\n                open('/tmp/python-to-pythonjs.debug.py', 'wb').write(code)\n            except:\n                pass\n        return code", 
            "title": "Python to Intermediate Form"
        }
    ]
}